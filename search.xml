<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>XML</title>
    <url>/2021/08/24/XML/</url>
    <content><![CDATA[<h3 id="一、XML文件-JavaEE"><a href="#一、XML文件-JavaEE" class="headerlink" title="一、XML文件(JavaEE)"></a>一、XML文件(JavaEE)</h3><ul>
<li>存储数据的语言<ul>
<li>Extensible：扩展</li>
<li>Marup：标记</li>
<li>Language：语言</li>
</ul>
</li>
</ul>
<h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul>
<li>作用<ul>
<li>存储数据</li>
<li>传输数据</li>
</ul>
</li>
<li>优点<ul>
<li>可读性好</li>
<li>维护性好</li>
</ul>
</li>
</ul>
<h3 id="二、XML语言的语法"><a href="#二、XML语言的语法" class="headerlink" title="二、XML语言的语法"></a>二、XML语言的语法</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="xml语法规范"><a href="#xml语法规范" class="headerlink" title="xml语法规范"></a>xml语法规范</h5><ul>
<li>区分大小写</li>
<li>必须正确的嵌套</li>
<li>必须有根元素</li>
<li>属性值必须加引号</li>
</ul>
<p>例：让XML文件保存Person</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span> &lt;--&gt;Person根元素&lt;/--&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">p1</span>&gt;</span>	&lt;--&gt;Person对象&lt;/--&gt;</span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>它是一个标签语言<ul>
<li>标签是成对出现的</li>
</ul>
</li>
</ul>
<h5 id="标签语言"><a href="#标签语言" class="headerlink" title="标签语言"></a>标签语言</h5><ul>
<li>在标签语言中&lt;&gt;中只有一个单词，称为元素标签</li>
<li>在标签语言中 &lt;单词&gt; 在单词后跟的所有的单词，都被称为<font color='#d15252'>属性标签</font>，它可以赋值</li>
</ul>
<h4 id="2-XML声明"><a href="#2-XML声明" class="headerlink" title="2.XML声明"></a>2.XML声明</h4><p><img src="https://i.loli.net/2021/08/18/IdGKFNVAcg672ej.png" alt="image-20210818113055208"></p>
<ul>
<li> version ：版本</li>
<li> encoding：编码格式</li>
<li> standalone：该xml文件是否依赖与其他文件</li>
</ul>
<h5 id="文档声明的注意细节"><a href="#文档声明的注意细节" class="headerlink" title="文档声明的注意细节"></a>文档声明的注意细节</h5><ul>
<li>文档声明<font color='#d15252'>必须在第一行</font></li>
<li>?和xml之间不能有空格</li>
</ul>
<h4 id="3-xml中的大于小于"><a href="#3-xml中的大于小于" class="headerlink" title="3.xml中的大于小于"></a>3.xml中的大于小于</h4><p><img src="https://i.loli.net/2021/08/18/NlnKJZ9XGLR4q7j.png" alt="image-20210818113155510"></p>
<h3 id="三、XML的数据传输：解析XML"><a href="#三、XML的数据传输：解析XML" class="headerlink" title="三、XML的数据传输：解析XML"></a>三、XML的数据传输：解析XML</h3><p><img src="https://i.loli.net/2021/08/18/UOj5b1paegVQFEW.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/08/18/tQj5FU92Cxu3dAm.png" alt="image-20210818114104225"></p>
<ul>
<li><p>浏览器用<font color='#d15252'>Document</font>将整个xml封装起来</p>
</li>
<li><p>Java中解析XML已经由第三方做好了</p>
<ul>
<li>dom4j</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/BKcnLWeg1sfrQJS.png" alt="image-20210818114827519"></p>
</li>
<li><p>下载步骤</p>
<ul>
<li>下载后缀为.zip的文件解压</li>
<li>后缀为.jar的文件就是我们要使用的</li>
<li><font color='#d15252'>docs</font>文件夹中，是官网文档<ul>
<li>找到index.html</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-Java中解析xml的步骤"><a href="#1-Java中解析xml的步骤" class="headerlink" title="1.Java中解析xml的步骤"></a>1.Java中解析xml的步骤</h4><ul>
<li>第一步：导包并解压</li>
<li>第二步：创建SAXReader对象 — 解析器</li>
<li>第三步：使用getResource获取路径</li>
<li>第四步： 读取文档，解析器调用read方法读取文档，并用Document保存</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/8FfTupCy2Pb1cRq.png" alt="image-20210818134337840"></p>
<ul>
<li>第五步：使用Document中的getRootElement()方法<font color='#d15252'>解析根目录</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/6iWrgmXChHwEyeP.png" alt="image-20210818134841873"></p>
<ul>
<li>第六步：使用Document中的elements()方法获取每一个元素<ul>
<li>并存入List集合，注意泛型</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/FE1cGXgaeLMyHTf.png" alt="image-20210818150624257"></p>
<ul>
<li>第七步：遍历List集合中的元素，拿到每一个元素<ul>
<li>同样用元素调用<font color='#d15252'>elements()方法</font>，并带参，获取到<font color='#d15252'>具体的属性对象</font></li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/Xidj71oTtCWh2ED.png" alt="image-20210818150753561"></p>
<ul>
<li>第八步：用每一个元素调用attribute()方法带参，可以取出所有带指定属性值，用来判断某一个具体的元素</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/P18xnRg2aoQDvOh.png" alt="image-20210818151242119"></p>
<ul>
<li>第九步：用获取到的具体对象，调用<font color='#d15252'>getText()</font>方法，获取<font color='#d15252'>具体的值</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/sj1SDUBed3C8zXh.png" alt="image-20210818150854734"></p>
<hr>
<h4 id="2-解析XML的方法"><a href="#2-解析XML的方法" class="headerlink" title="2.解析XML的方法"></a>2.解析XML的方法</h4><h5 id="Ⅰ-getRootElement（）"><a href="#Ⅰ-getRootElement（）" class="headerlink" title="Ⅰ. getRootElement（）"></a>Ⅰ. getRootElement（）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRootElement（）<span class="comment">//解析根目录</span></span><br></pre></td></tr></table></figure>

<ul>
<li>document调用，获取根目录</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/RO2HjFenNQvaZwI.png" alt="image-20210818143500082"></p>
<h5 id="Ⅱ-getResource"><a href="#Ⅱ-getResource" class="headerlink" title="Ⅱ. getResource()"></a>Ⅱ. getResource()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getResource() <span class="comment">//获取目录路径</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/24/nJoPVXRwTYAq4Fj.png" alt="image-20210818143533544"></p>
<h5 id="Ⅲ-elements"><a href="#Ⅲ-elements" class="headerlink" title="Ⅲ. elements()"></a>Ⅲ. elements()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elements() 			<span class="comment">//获取所有元素</span></span><br><span class="line">elements(<span class="string">&quot;标签名&quot;</span>)	  <span class="comment">//获取指定的所有元素</span></span><br><span class="line">element() 			<span class="comment">//获取单个的元素</span></span><br><span class="line">element(String str) <span class="comment">//获取指定元素</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/CfbgayeHFuipVDG.png" alt="image-20210818140157107"></p>
<ul>
<li>获取所有的元素，并存入List数组中，注意给泛型</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/sbyLZMznv7wV8CU.png" alt="image-20210818141034352"></p>
<ul>
<li>返回值List集合</li>
</ul>
<h5 id="Ⅳ-attribute"><a href="#Ⅳ-attribute" class="headerlink" title="Ⅳ. attribute()"></a>Ⅳ. attribute()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Attribute <span class="title">attribute</span><span class="params">(<span class="string">&quot;str&quot;</span>)</span> <span class="comment">//获取属性为str的元素</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/kExhSnz1X2ag7dG.png" alt="image-20210818141819372"></p>
<p><img src="https://i.loli.net/2021/08/18/LeljzUgWaBcvVPy.png" alt="image-20210818141916131"></p>
<ul>
<li>可以看到，获取了所有属性为id的元素<ul>
<li>如果我们要获取其中一个指定的元素，需要对value值进行判断</li>
</ul>
</li>
<li>如果有其他元素，没有带指定的标签，会返回null</li>
<li>返回值Attribute类型</li>
</ul>
<h5 id="Ⅴ-getValue"><a href="#Ⅴ-getValue" class="headerlink" title="Ⅴ. getValue()"></a>Ⅴ. getValue()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getValue()	<span class="comment">//获得元素的值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/xwHW2MNbTEI7iUm.png" alt="image-20210818142150055"></p>
<p><img src="https://i.loli.net/2021/08/18/ZacsrY3f8pW7ytg.png" alt="image-20210818142339756"></p>
<ul>
<li>Attribute调用，获取元素的值</li>
</ul>
<h5 id="Ⅵ-getText"><a href="#Ⅵ-getText" class="headerlink" title="Ⅵ. getText()"></a>Ⅵ. getText()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getText()	<span class="comment">//取出数据</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/JMG8Y4cLbRmdgTi.png" alt="image-20210818143329102"></p>
<ul>
<li>Element调用</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="https://i.loli.net/2021/08/18/HqatLhTz3EDm9rU.png" alt="image-20210818145833898"></p>
<h4 id="将String类转为Int类型"><a href="#将String类转为Int类型" class="headerlink" title="将String类转为Int类型"></a>将String类转为Int类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.parseInt(要转换的数据);</span><br></pre></td></tr></table></figure>



<h3 id="四、约束XML文件"><a href="#四、约束XML文件" class="headerlink" title="四、约束XML文件"></a>四、约束XML文件</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>用来限定xml文件中使用的标签以及属性</li>
<li>约束分类<ul>
<li>DTD</li>
<li>Schema</li>
</ul>
</li>
</ul>
<h3 id="五、DTD"><a href="#五、DTD" class="headerlink" title="五、DTD"></a>五、DTD</h3><h4 id="编写DTD约束的步骤"><a href="#编写DTD约束的步骤" class="headerlink" title="编写DTD约束的步骤"></a>编写DTD约束的步骤</h4><ul>
<li><p><strong>第一步</strong>：创建一个文件，后缀为.dtd</p>
</li>
<li><p><strong>第二步</strong>：看xml文件中使用了哪些元素</p>
</li>
<li><p><strong>第三步</strong>：判断元素是 简单元素，还是 复杂元素</p>
<ul>
<li>简单元素：只有元素自己</li>
<li>复杂元素：包含嵌套其他元素</li>
</ul>
</li>
<li><p><font color='cornflowerblue'><strong>第四步</strong></font>：创建约束</p>
<ul>
<li><p>```dtd</p>
<!ELEMENT 元素名称 类别>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 可以定义元素</span><br><span class="line"></span><br><span class="line">  - 简单元素：`<span class="meta">&lt;!ELEMENT 元素名称&gt;</span>`</span><br><span class="line"></span><br><span class="line">    - 可以加()标明数据类型</span><br><span class="line">    - 字符串类型：`<span class="meta">&lt;!ELEMENT <span class="meta-keyword">sid</span>(<span class="meta-keyword">#PCDATA</span>) &gt;</span>`</span><br><span class="line">    - Int类型：`<span class="meta">&lt;!ELEMENT <span class="meta-keyword">sid</span>(<span class="meta-keyword">#PCDATA</span>) &gt;</span>`</span><br><span class="line"></span><br><span class="line">  - 复杂元素：`<span class="meta">&lt;!ELEMENT 元素名称（子元素名称，子元素名称）&gt;</span>`</span><br><span class="line"></span><br><span class="line">    - 如果有多个元素的话，可以用 `,`或 `|`隔开</span><br><span class="line">    - `，`  可以出现多个，标识顺序</span><br><span class="line">    - `|` 只能写一个其中一个元素，不能写多个</span><br><span class="line"></span><br><span class="line">    可选符号</span><br><span class="line"></span><br><span class="line">    - `?`代表零次或者一次</span><br><span class="line">    - `+`一次或者多次</span><br><span class="line">    - `*`代表零次或者多次</span><br><span class="line"></span><br><span class="line">    如果不写，表示出现一次</span><br><span class="line"></span><br><span class="line">- **第五步**：在xml文件中引入约束文件</span><br><span class="line"></span><br><span class="line">  - <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#d15252&#x27;</span>&gt;</span>引入本地<span class="tag">&lt;/<span class="name">font</span>&gt;</span>：</span><br><span class="line"></span><br><span class="line">    ```xml</span><br><span class="line">    <span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&#x27;DTD文件路径&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/u8SfdJWrDX3joiA.png" alt="image-20210818162615097"></p>
</li>
<li><p>在xml文件内部引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称[dtd文件内容]&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/qQPRY9ZOFemnSu6.png" alt="image-20210818162644301"></p>
</li>
<li><p>引入网络DTD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">PUBLIC</span><span class="meta-string">&quot;DTD文件名称&quot;</span><span class="meta-string">&quot;DTD文档url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第六步</strong>：定义属性的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 类型&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h4><p><img src="https://i.loli.net/2021/08/18/YMsSDquvyfdVNC6.png" alt="image-20210818165443886"></p>
<h3 id="六、Schema"><a href="#六、Schema" class="headerlink" title="六、Schema"></a>六、Schema</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>schema和dtd的区别<ul>
<li>schema的后缀是.xsd</li>
</ul>
</li>
<li>一个XML文件中可以引入多个schema约束文件<ul>
<li>多个schema之间使用名称空间来区分</li>
</ul>
</li>
<li>dtd元素取值比较单一，最常见的是PCDATA类型<ul>
<li>而Schema中，支持多个数据类型</li>
</ul>
</li>
<li>语法更加复杂</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/08/23/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><ul>
<li><p>利用代码区中的数据（.class文件），去创建对象；<font color='#d15252'>省略new</font></p>
<ul>
<li>构造方法</li>
<li>成员变量</li>
<li>成员方法</li>
</ul>
</li>
<li><p>在代码区中存储的class并不是真正的class文件(物理)，而是一个虚拟的对象</p>
<ul>
<li><strong><font color='#d15252'>Class类</font></strong></li>
</ul>
</li>
</ul>
<h3 id="二、Class"><a href="#二、Class" class="headerlink" title="二、Class"></a>二、Class</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>泛型<ul>
<li>class类型很多，不固定</li>
</ul>
</li>
<li>修饰符：final <ul>
<li>不能被继承</li>
</ul>
</li>
<li>Class的实例表示正在运行的类和接口</li>
<li>管理class文件对象</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><p>无</p>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li><p>获取class文件对象的三种方式</p>
<ul>
<li><p>```java<br>方式一：通过Object类中的getClass()方法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-<span class="number">20210817110933068</span>](https:<span class="regexp">//i</span>.loli.net<span class="regexp">/2021/</span><span class="number">08</span><span class="regexp">/17/m</span>1nypAo43bJFBIC.png)</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  方式二：类名.class获取到字节码文件对象(任意数据类型都具有静态的class属性)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/23EShKfXxMYZW5y.png" alt="image-20210817111023597"></p>
</li>
<li><p>```java<br>方式三：forName(“String s”)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - <span class="string">&quot; s &quot;</span> : 类的全路径</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20210817111128606</span>](https:<span class="regexp">//i</span>.loli.net<span class="regexp">/2021/</span><span class="number">08</span><span class="regexp">/17/</span>M2Be6PaLC7wJEpH.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### Ⅰ.forName()</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static Class&lt;?&gt; forName(String className) </span><br><span class="line"><span class="regexp">//</span>返回与给定字符串名称的类或接口相关联的 Class对象。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>className : 类的全路径</p>
</li>
<li><p>static 静态的，可以通过类名调用</p>
</li>
<li><p>Class&lt;?&gt;泛型</p>
</li>
</ul>
<h4 id="4-Class文件的内部成员"><a href="#4-Class文件的内部成员" class="headerlink" title="4.Class文件的内部成员"></a>4.<font color='#d15252'>Class文件</font>的内部成员</h4><ul>
<li>构造方法：Constructor</li>
<li>成员方法：Method</li>
<li>成员变量：Filed</li>
</ul>
<hr>
<h3 id="三、Constructor"><a href="#三、Constructor" class="headerlink" title="三、Constructor"></a>三、Constructor</h3><h4 id="1-获取Class构造方法"><a href="#1-获取Class构造方法" class="headerlink" title="1.获取Class构造方法"></a>1.获取Class构造方法</h4><h5 id="Ⅰ-getConstructors"><a href="#Ⅰ-getConstructors" class="headerlink" title="Ⅰ.getConstructors()"></a>Ⅰ.getConstructors()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors() </span><br><span class="line"><span class="comment">//返回一个包含 Constructor对象的数组， Constructor对象反映了由该 Class对象表示的类的所有公共构造函数。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型Constructor</li>
<li>只能获取到<font color='#d15252'>public修饰</font>的的构造方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/w7yi4ZhWfLXmFd9.png" alt="image-20210817135511279"></p>
<h5 id="Ⅱ-getDeclaredConstructors"><a href="#Ⅱ-getDeclaredConstructors" class="headerlink" title="Ⅱ.getDeclaredConstructors()"></a>Ⅱ.getDeclaredConstructors()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors() </span><br><span class="line"><span class="comment">//返回反映由该 Class对象表示的类声明的所有构造函数的 Constructor对象的数组。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取<font color='#d15252'>所有的</font>构造方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/u6dkrP9piQjFRSE.png" alt="image-20210817135520975"></p>
<h5 id="Ⅲ-getConstructor"><a href="#Ⅲ-getConstructor" class="headerlink" title="Ⅲ.getConstructor()"></a>Ⅲ.getConstructor()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Constructor对象，该对象反映由该 Class对象表示的类的指定公共构造函数。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回指定的构造方法（获取不到private修饰的）</p>
<p><img src="https://i.loli.net/2021/08/17/srX71Oml6BIaCoH.png" alt="image-20210817140725698"></p>
</li>
</ul>
<h5 id="Ⅳ-getDeclaredConstructor"><a href="#Ⅳ-getDeclaredConstructor" class="headerlink" title="Ⅳ. getDeclaredConstructor()"></a>Ⅳ. getDeclaredConstructor()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;T&gt; getDeclaredConstructor​*(Class&lt;?&gt;... parameterTypes) </span><br><span class="line"><span class="comment">//返回一个 Constructor对象，该对象反映由此 Class对象表示的类或接口的指定构造函数。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定的构造方法，private修饰的也可以获取</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/ERUN6MXepbT4OfQ.png" alt="image-20210817140901110"></p>
<h4 id="2-利用构造方法创建Class实例"><a href="#2-利用构造方法创建Class实例" class="headerlink" title="2.利用构造方法创建Class实例"></a>2.利用构造方法<font color='#d15252'>创建Class实例</font></h4><h5 id="Ⅰ-newInstance-Object…-initargs"><a href="#Ⅰ-newInstance-Object…-initargs" class="headerlink" title="Ⅰ.newInstance(Object… initargs)"></a>Ⅰ.newInstance(Object… initargs)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用由此 Constructor对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例。  </span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/MVLpE5fQs8InJxm.png" alt="image-20210817204522820"></p>
<ul>
<li><p>带参传递一要取出的构造方法的参数类型，根据方法的重载，选择对应的构造方法</p>
</li>
<li><p>使用newInstance方法时，根据使用的构造方法进行传值</p>
</li>
<li><p>如果不重写toString()方法，则创建的实例化对象直接输出是一个地址值</p>
</li>
</ul>
<h3 id="四、Field"><a href="#四、Field" class="headerlink" title="四、Field"></a>四、Field</h3><h4 id="1-获取Class成员变量"><a href="#1-获取Class成员变量" class="headerlink" title="1.获取Class成员变量"></a>1.获取Class<font color='#d15252'>成员变量</font></h4><h5 id="Ⅰ-getFields"><a href="#Ⅰ-getFields" class="headerlink" title="Ⅰ.getFields()"></a>Ⅰ.getFields()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() </span><br><span class="line"><span class="comment">//返回包含一个数组 Field对象反射由此表示的类或接口的所有可访问的公共字段 类对象。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出所有Public修饰的成员变量</li>
</ul>
<h5 id="Ⅱ-getDeclaredFields"><a href="#Ⅱ-getDeclaredFields" class="headerlink" title="Ⅱ.getDeclaredFields()"></a>Ⅱ.getDeclaredFields()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getDeclaredFields() </span><br><span class="line"><span class="comment">//返回的数组 Field对象反映此表示的类或接口声明的所有字段 类对象 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出所有成员变量，包括private修饰的</li>
</ul>
<h5 id="Ⅲ-getField-String-name"><a href="#Ⅲ-getField-String-name" class="headerlink" title="Ⅲ.getField(String name)"></a>Ⅲ.getField(String name)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段类对象 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出指定的public修饰的成员变量</li>
</ul>
<h5 id="Ⅳ-getDeclaredField-String-name"><a href="#Ⅳ-getDeclaredField-String-name" class="headerlink" title="Ⅳ.getDeclaredField(String name)"></a>Ⅳ.getDeclaredField(String name)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Field对象，它反映此表示的类或接口的指定已声明字段类对象。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定的成员变量，private也可以取出</li>
</ul>
<h4 id="4-给Class成员变量赋值"><a href="#4-给Class成员变量赋值" class="headerlink" title="4.给Class成员变量赋值"></a>4.给Class成员变量<font color='#d15252'>赋值</font></h4><h5 id="Ⅰ-set-Object-obj-Object-value"><a href="#Ⅰ-set-Object-obj-Object-value" class="headerlink" title="Ⅰ.set(Object obj, Object value)"></a>Ⅰ.set(Object obj, Object value)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取公共的成员变量</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/eo1Hp9LraVjMuOP.png" alt="image-20210817153600751"></p>
<ul>
<li>获取私有的成员变量</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/Hk8viMBxhaSXRAE.png" alt="image-20210817181152287"></p>
<ul>
<li>私有的成员变量赋值时需要暴力破解</li>
</ul>
<hr>
<h3 id="五、Method"><a href="#五、Method" class="headerlink" title="五、Method"></a>五、Method</h3><h4 id="1-获取Class成员方法"><a href="#1-获取Class成员方法" class="headerlink" title="1.获取Class成员方法"></a>1.获取Class成员方法</h4><h5 id="Ⅰ-getMethods"><a href="#Ⅰ-getMethods" class="headerlink" title="Ⅰ.getMethods()"></a>Ⅰ.getMethods()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] getMethods() </span><br><span class="line"><span class="comment">//返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>取出class中的所有<font color='#d15252'>Public修饰的</font>成员方法</p>
</li>
<li><p>会取出包括父类中继承的方法</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/oniWLADSya2NE4e.png" alt="image-20210817155232292"></p>
<h5 id="Ⅱ-getDeclaredMethods"><a href="#Ⅱ-getDeclaredMethods" class="headerlink" title="Ⅱ.getDeclaredMethods()"></a>Ⅱ.getDeclaredMethods()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Methods[] getDeclaredMethods() </span><br><span class="line"><span class="comment">//返回一个包含 方法对象的数组， 方法对象反映由 Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法。 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出class中的所有成员方法，包括private修饰的</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/8GmaHKep6rk35Bn.png" alt="image-20210817155435479"></p>
<h5 id="Ⅲ-getMethod-String-name-Class-lt-gt-…-parameterTypes"><a href="#Ⅲ-getMethod-String-name-Class-lt-gt-…-parameterTypes" class="headerlink" title="Ⅲ.getMethod(String name, Class&lt;?&gt;… parameterTypes)"></a>Ⅲ.getMethod(String name, Class&lt;?&gt;… parameterTypes)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Methods <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法。 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出class中的指定的Public修饰的成员方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/T5awcy9gsUKBGt2.png" alt="image-20210817155835845"></p>
<h5 id="Ⅳ-getDeclaredMethod-String-name-Class-lt-gt-…-parameterTypes"><a href="#Ⅳ-getDeclaredMethod-String-name-Class-lt-gt-…-parameterTypes" class="headerlink" title="Ⅳ.getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)"></a>Ⅳ.getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Methods <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 Class对象。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出指定的成员方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/Rs8FvogtaNVdhib.png" alt="image-20210817160013845"></p>
<h4 id="2-使用成员方法"><a href="#2-使用成员方法" class="headerlink" title="2.使用成员方法"></a>2.使用成员方法</h4><h5 id="Ⅰ-invoke-Object-obj-Object…-args"><a href="#Ⅰ-invoke-Object-obj-Object…-args" class="headerlink" title="Ⅰ.invoke(Object obj, Object… args)"></a>Ⅰ.invoke(Object obj, Object… args)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//在具有指定参数的指定对象上调用此 方法对象表示的基础方法。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将取出的<font color='#d15252'><strong>方法和对象绑定</strong></font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/bv7ZaMqpmjufntk.png" alt="image-20210817212251329"></p>
<hr>
<h3 id="六、AccessibleObject"><a href="#六、AccessibleObject" class="headerlink" title="六、AccessibleObject"></a>六、AccessibleObject</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>AccessibleObject是 Field、Constructor、Method的父类</li>
<li>作用：看你是否除了public修饰 （安全检查机制）</li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-setAccessible-boolean-f-暴力破解"><a href="#Ⅰ-setAccessible-boolean-f-暴力破解" class="headerlink" title="Ⅰ.setAccessible(boolean f) 暴力破解"></a>Ⅰ.setAccessible(boolean f) 暴力破解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//将此反射对象的 accessible标志设置为指示的布尔值。  </span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/foUpWaY9lqKbHv1.png" alt="image-20210817143740180"></p>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><h4 id="1-泛型擦除"><a href="#1-泛型擦除" class="headerlink" title="1.泛型擦除"></a>1.泛型擦除</h4><ul>
<li><img src="https://i.loli.net/2021/08/17/3xXvCpmNDtfj4F2.png" alt="image-20210817171924074"></li>
</ul>
<h4 id="2-获取当前src目录"><a href="#2-获取当前src目录" class="headerlink" title="2.获取当前src目录"></a>2.获取当前src目录<img src="https://i.loli.net/2021/08/18/FBsTqWeIxmafXlR.png" alt="image-20210818093158387"></h4><ul>
<li><p>获取当前src目录</p>
</li>
<li><p>会出现取出字符串带双引号，forName无法识别的问题</p>
</li>
</ul>
<p><img src="C:\Users\GikH\AppData\Roaming\Typora\typora-user-images\image-20210818104512010.png" alt="image-20210818104512010"></p>
<p><img src="https://i.loli.net/2021/08/18/ToLq5lAhDfyrCRY.png" alt="image-20210818104515650"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/08/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、网络编程"><a href="#一、网络编程" class="headerlink" title="一、网络编程"></a>一、网络编程</h3><h4 id="1-网络编程的概念"><a href="#1-网络编程的概念" class="headerlink" title="1.网络编程的概念"></a>1.网络编程的概念</h4><ul>
<li>学习Java的操作<ul>
<li>操作内存</li>
<li>本地存储（IO流）</li>
<li>和互联网中的设备产生关系</li>
</ul>
</li>
</ul>
<h4 id="2-网编的三要素"><a href="#2-网编的三要素" class="headerlink" title="2.网编的三要素"></a>2.网编的三要素</h4><ul>
<li>网络协议（网络通道）</li>
<li>IP(设备的地址)</li>
<li>端口号（具体软件）<ul>
<li>0-65535</li>
</ul>
</li>
</ul>
<h3 id="二、InetAddress"><a href="#二、InetAddress" class="headerlink" title="二、InetAddress"></a>二、InetAddress</h3><h4 id="1-API概述"><a href="#1-API概述" class="headerlink" title="1.API概述"></a>1.API概述</h4><ul>
<li>包java.net.InetAddress<ul>
<li>导包</li>
</ul>
</li>
<li>修饰符public</li>
<li>使用InetAddress<ul>
<li>构造方法<ul>
<li>没有构造方法</li>
</ul>
</li>
<li>使用静态方法<ul>
<li>通过类名直接调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-getByName"><a href="#Ⅰ-getByName" class="headerlink" title="Ⅰ. getByName()"></a>Ⅰ. getByName()</h5><ul>
<li>确定<font color='#d15252'>主机名称</font>和<font color='#d15252'>IP</font>地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> InetAddress getByName​(String host)</span><br><span class="line">    <span class="comment">//确定主机名称和IP地址。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>能获取自己的，也能获取别人的</li>
</ul>
<h5 id="Ⅱ-getLocalHost"><a href="#Ⅱ-getLocalHost" class="headerlink" title="Ⅱ. getLocalHost()"></a>Ⅱ. getLocalHost()</h5><ul>
<li>返回本机的地址<ul>
<li>只能查看自己的，本机的IP </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//返回本地主机的地址。</span></span></span><br></pre></td></tr></table></figure>





<h5 id="Ⅲ-getHostName"><a href="#Ⅲ-getHostName" class="headerlink" title="Ⅲ. getHostName()"></a>Ⅲ. getHostName()</h5><ul>
<li>获取此IP地址的主机名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHostName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//获取此IP地址的主机名。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值String类型</li>
<li>没有static修饰</li>
</ul>
<h5 id="Ⅳ-getHostAddress"><a href="#Ⅳ-getHostAddress" class="headerlink" title="Ⅳ.  getHostAddress()"></a>Ⅳ.  getHostAddress()</h5><ul>
<li>获取IP</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHostAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//返回文本显示中的IP地址字符串。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值String类型</li>
<li>没有static修饰</li>
</ul>
<h3 id="三、网络协议"><a href="#三、网络协议" class="headerlink" title="三、网络协议"></a>三、网络协议</h3><h4 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1. TCP/IP"></a>1. TCP/IP</h4><ul>
<li>应用层 <ul>
<li>http ftp DNS<ul>
<li>应用软件之间的通信   — &gt;  前端开发</li>
</ul>
</li>
</ul>
</li>
<li>传输层<ul>
<li>TCP UDP <ul>
<li>负责网络程序通信 — &gt; 后台开发</li>
</ul>
</li>
</ul>
</li>
<li>网络层<ul>
<li>ip icmp IGMP<ul>
<li>负责数据传输的<font color='#d15252'>目标</font></li>
</ul>
</li>
</ul>
</li>
<li>链路层<ul>
<li>驱动程序、接口   <ul>
<li>硬件部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/cfs5AzeaLEKJvW3.png" alt="image-20210816094838044"></p>
<h4 id="2-传输层UDP-快递"><a href="#2-传输层UDP-快递" class="headerlink" title="2.传输层UDP (快递)"></a>2.传输层UDP (快递)</h4><ul>
<li>面向无连接通信<ul>
<li>发送端和接收端<font color='#d15252'>不建立</font>逻辑关系</li>
<li>不在乎对方是否存在/是否接收</li>
<li>耗费资源比较小，通信效率高，通常被用来音频、视频、普通数据的传输</li>
</ul>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="四、DatagramPacket-报包"><a href="#四、DatagramPacket-报包" class="headerlink" title="四、DatagramPacket (报包)"></a>四、DatagramPacket (报包)</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>包<ul>
<li>java.net.DatagramPacket<ul>
<li>需要导包</li>
</ul>
</li>
</ul>
</li>
<li>修饰符<ul>
<li>final 最终类 <ul>
<li>不能被继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-发送长度为-length的数据包"><a href="#Ⅰ-发送长度为-length的数据包" class="headerlink" title="Ⅰ.发送长度为 length的数据包"></a>Ⅰ.发送长度为 length的数据包</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port) </span><br><span class="line"><span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>发送长度为 length的数据包偏移量为 offset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, SocketAddress address) </span><br><span class="line"><span class="comment">//构造一个数据报包，发送长度为 length的数据包，偏移量为 ioffset到指定主机上的指定端口号。  </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-成员方法-1"><a href="#2-成员方法-1" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-getData"><a href="#Ⅰ-getData" class="headerlink" title="Ⅰ. getData()"></a>Ⅰ. getData()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getData()</span><br><span class="line"> <span class="comment">//返回数据缓冲区。  </span></span><br></pre></td></tr></table></figure>



<h5 id="Ⅱ-getLength"><a href="#Ⅱ-getLength" class="headerlink" title="Ⅱ. getLength()"></a>Ⅱ. getLength()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回要发送的数据的长度或接收到的数据的长度。 </span></span></span><br></pre></td></tr></table></figure>



<h3 id="五、DatagramSocket-发送报包"><a href="#五、DatagramSocket-发送报包" class="headerlink" title="五、DatagramSocket(发送报包)"></a>五、DatagramSocket(发送报包)</h3><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-DatagramSocket"><a href="#Ⅰ-DatagramSocket" class="headerlink" title="Ⅰ. DatagramSocket()"></a>Ⅰ. DatagramSocket()</h5><ul>
<li>```java<br>DatagramSocket()<br>//创建该类的实例，并且将指定的数据报包进行绑定(任意端口号)<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span>成员方法</span><br><span class="line"></span><br><span class="line">##### Ⅰ. send(DatagramPacket p) &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;发送&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">void send(DatagramPacket p) 从此套接字发送数据报包。  </span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/micTFegHh3V9JAl.png" alt="image-20210816111327413"></p>
<h3 id="六、UDP传输接收端"><a href="#六、UDP传输接收端" class="headerlink" title="六、UDP传输接收端"></a>六、UDP传输<font color='#d15252'>接收端</font></h3><h4 id="DatagramSocket：可以用来发送也可以用来接收"><a href="#DatagramSocket：可以用来发送也可以用来接收" class="headerlink" title="DatagramSocket：可以用来发送也可以用来接收"></a>DatagramSocket：可以用来发送也可以用来接收</h4><h4 id="1-构造方法-1"><a href="#1-构造方法-1" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-DatagramSocket-int-port"><a href="#Ⅰ-DatagramSocket-int-port" class="headerlink" title="Ⅰ. DatagramSocket(int port)"></a>Ⅰ. DatagramSocket(int port)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket(<span class="keyword">int</span> port)</span><br><span class="line"><span class="comment">//构造数据报套接字并将其绑定到本地主机上的指定端口。 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建该类实例，并指定要接收的端口号</li>
</ul>
<h4 id="2-成员方法-2"><a href="#2-成员方法-2" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-receive-DatagramPacket-p"><a href="#Ⅰ-receive-DatagramPacket-p" class="headerlink" title="Ⅰ. receive(DatagramPacket p)"></a>Ⅰ. receive(DatagramPacket p)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//从此套接字接收数据报包。 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数需要传递一个DatagramPacket对象<ul>
<li>即创建一个报包，用于接收数据</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/NuHWUCp536ncVk2.png" alt="image-20210816112350372"></p>
<hr>
<h3 id="总结：UDP-发送接收数据报包的步骤"><a href="#总结：UDP-发送接收数据报包的步骤" class="headerlink" title="总结：UDP 发送接收数据报包的步骤"></a>总结：UDP 发送接收数据报包的<font color='#d15252'>步骤</font></h3><h4 id="一、发送"><a href="#一、发送" class="headerlink" title="一、发送"></a>一、发送</h4><ul>
<li><p>将要发送的数据存入byte[]数组</p>
<p><img src="https://i.loli.net/2021/08/16/yUQGD8TclPEWuta.png" alt="image-20210816112518290"></p>
</li>
<li><p>将数据打包</p>
<ul>
<li>使用DatagramPacket的构造方法将数据打包</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/udH9ewWDxJR2Kzj.png" alt="image-20210816112657659"></p>
<ul>
<li>指定byte[]数据，长度，给出InetAddress对象(地址)，端口号</li>
</ul>
</li>
<li><p>准备发送的工具（快递小哥）</p>
<ul>
<li><p>使用DatagtamSocket构建一个对象，调用它的send方法，发送数据</p>
<p><img src="https://i.loli.net/2021/08/16/2fwUVBmbPy3scNj.png" alt="image-20210816112825275"></p>
</li>
<li><p>send方法需要传递一个DatagramPacket类的对象</p>
</li>
</ul>
</li>
</ul>
<h4 id="二、接收"><a href="#二、接收" class="headerlink" title="二、接收"></a>二、接收</h4><ul>
<li><p>首先要准备一个DatagramPacket对象，用于接收发送端发送过来的数据</p>
<ul>
<li><p>使用简单的构造方法，构造一个DatagramPacket，需要一个byte[]数组</p>
<p><img src="https://i.loli.net/2021/08/16/UQJhknG649aYDHj.png" alt="image-20210816113024029"></p>
</li>
</ul>
</li>
<li><p>创建接收数据报包的工具</p>
<ul>
<li><p>使用DatagramSocket构建一个接收数据报包的工具，带参传递一个端口号</p>
<ul>
<li>端口号需要和发送端一致，才能接收到数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/CjWLb57Ofm4FT8l.png" alt="image-20210816113139335"></p>
</li>
</ul>
</li>
<li><p>接收数据</p>
<ul>
<li><p>调用DatagramSocket的<font color='#d15252'>receive</font>方法，接收数据</p>
<ul>
<li>需要传递一个DatagramPacket对象，用于存储接收的数据<ul>
<li>使用之前准备好的dp，接收数据</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/sSLiyVxUnMEzHIZ.png" alt="image-20210816113237009"></p>
</li>
</ul>
</li>
<li><p>将接收到的，存在报包中的数据，<font color='#d15252'>取出</font></p>
<ul>
<li>通过.getLength()方法获取数据报包的长度，因为默认编码不支持中文<ul>
<li>如果需要中文可以进行转换为String类型</li>
</ul>
</li>
<li>通过.getData()方法获取数据包中的数据<ul>
<li>返回值是一个byte[]数组类型，用一个数据进行存储</li>
</ul>
</li>
<li>遍历数组进行查看数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/WhSV6Hntoy8px9r.png" alt="image-20210816113548776"></p>
</li>
</ul>
<hr>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><font color='#d15252'>TCP</font></h2><ul>
<li>严格区分客户端和服务器端<ul>
<li>面向有链接的</li>
</ul>
</li>
<li>客户端 —-&gt; 服务器端<ul>
<li>以VNC为例</li>
</ul>
</li>
</ul>
<h3 id="七、TCP服务器端ServerSocket类"><a href="#七、TCP服务器端ServerSocket类" class="headerlink" title="七、TCP服务器端ServerSocket类"></a>七、TCP服务器端ServerSocket类</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>包：java.net.ServerSocket <ul>
<li>需要导包</li>
</ul>
</li>
<li>修饰符：public 直接使用</li>
<li>属于网络流，一般服务器端不关流</li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-ServerSocket-int-port"><a href="#Ⅰ-ServerSocket-int-port" class="headerlink" title="Ⅰ. ServerSocket(int port)"></a>Ⅰ. ServerSocket(int port)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket(<span class="keyword">int</span> port) </span><br><span class="line"><span class="comment">//创建实例，绑定端口号</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/16/Cc1oB8eETalW5gf.png" alt="image-20210816135448306"></p>
<h5 id="Ⅱ-其他构造"><a href="#Ⅱ-其他构造" class="headerlink" title="Ⅱ.其他构造"></a>Ⅱ.其他构造</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket​() 创建未绑定的服务器套接字。  </span><br><span class="line">ServerSocket​(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog) 创建服务器套接字并将其绑定到指定的本地端口号，并指定了积压。  </span><br><span class="line">ServerSocket​(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr) 创建一个具有指定端口的服务器，侦听backlog和本地IP地址绑定。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><h5 id="Ⅰ-accept"><a href="#Ⅰ-accept" class="headerlink" title="Ⅰ. accept()"></a>Ⅰ. accept()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Socket <span class="title">accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//侦听要连接到此 套接字(报包) 并接受它。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Socket：返回值类型</p>
</li>
<li><p>等待 侦听/接收  客户端数据，没有就一直等待</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/vxTwnerutZHG5Cs.png" alt="image-20210816135423394"></p>
<h5 id="Ⅱ-getInputStream"><a href="#Ⅱ-getInputStream" class="headerlink" title="Ⅱ. getInputStream()"></a>Ⅱ. getInputStream()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回此套接字的输入流。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以客户端为参照物，服务器端用字节输入流，保存数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/chfSwMalk6YEq4B.png" alt="image-20210816141948535"></p>
<h3 id="八、TCP客户端Socket"><a href="#八、TCP客户端Socket" class="headerlink" title="八、TCP客户端Socket"></a>八、TCP客户端Socket</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>包：java.net.Socket </p>
<ul>
<li>需要导包</li>
</ul>
</li>
<li><p>修饰符：public 直接使用</p>
</li>
<li><p>属于网络流，用完需要关流</p>
</li>
</ul>
<h4 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-Socket-InetAddress-a-int-p"><a href="#Ⅰ-Socket-InetAddress-a-int-p" class="headerlink" title="Ⅰ. Socket(InetAddress a, int p)"></a>Ⅰ. Socket(InetAddress a, int p)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket(InetAddress address, <span class="keyword">int</span> port)</span><br><span class="line"><span class="comment">//创建该类实例，并指定服务器端</span></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li>客户端向服务器端发送数据<ul>
<li>实际上依然是通过IO流进行读写</li>
</ul>
</li>
<li>又因为服务器端不能主动请求和发送数据（例如NVC）<ul>
<li>所以IO流要<font color='#d15252'>以客户端为参照物</font></li>
</ul>
</li>
</ul>
<h5 id="Ⅰ-getOutputStream"><a href="#Ⅰ-getOutputStream" class="headerlink" title="Ⅰ. getOutputStream()"></a>Ⅰ. getOutputStream()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回此套接字的输出流。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以客户端为参照物，用字节输出流写入数据到服务器端</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/fBIdhmq84UPrH1v.png" alt="image-20210816141930558"></p>
<h3 id="服务器端回复消息到客户端"><a href="#服务器端回复消息到客户端" class="headerlink" title="服务器端回复消息到客户端"></a>服务器端回复消息到客户端</h3><ul>
<li><p>步骤</p>
<ul>
<li><p>以服务器端为中心</p>
</li>
<li><p>向客户端用字节输出流写入数据</p>
<p><img src="https://i.loli.net/2021/08/16/cdEkNrMyFpvWSbm.png" alt="image-20210816145040488"></p>
</li>
<li><p>客户端用字节输入流接收数据</p>
<p><img src="https://i.loli.net/2021/08/16/SBcoHyIJTW6r3x7.png" alt="image-20210816145113103"></p>
</li>
<li><p>客户端遍历接收到的数据并打印到控制台</p>
</li>
</ul>
</li>
<li><p><font color='#d15252'>注意事项</font>：如果客户端要接收服务器端的返回数据</p>
<ul>
<li>必须先将客户端之前向服务器端写入的输出流关闭<ul>
<li>否则服务器端会一直处于等待数据状态，不会继续执行操作</li>
<li>也就是read处于阻塞状态</li>
</ul>
</li>
<li>通过<font color='#d15252'>关闭客户端输出流</font>，解决阻塞状态</li>
</ul>
</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li>键盘录入<ul>
<li>当录入no时，停止输入</li>
</ul>
</li>
<li>UDP：多线程的聊天室</li>
<li>TCP：图片上传服务器<ul>
<li>客户端获取图片，发送到服务器</li>
<li>服务器将图片写入另一个文件夹</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
