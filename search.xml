<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API之StringBuffer\StringBuilder\Date\DateFormat\Calender</title>
    <url>/2021/08/25/API%E4%B9%8BStringBuffer-StringBuilder-Date-DateFormat-Calender/</url>
    <content><![CDATA[<h3 id="一、StringBuffer"><a href="#一、StringBuffer" class="headerlink" title="一、StringBuffer"></a>一、StringBuffer</h3><h4 id="1-什么是StringBuffer"><a href="#1-什么是StringBuffer" class="headerlink" title="1.什么是StringBuffer?"></a>1.什么是StringBuffer?</h4><ul>
<li>线程安全</li>
<li>可变的<font color='#d15252'>字符序列</font><ul>
<li>任意的改变长度</li>
<li>任意改变内容</li>
</ul>
</li>
</ul>
<h4 id="2-StringBuffer的内容"><a href="#2-StringBuffer的内容" class="headerlink" title="2.StringBuffer的内容"></a>2.StringBuffer的内容</h4><ul>
<li><p>包</p>
<ul>
<li><p>查看所在包</p>
<ul>
<li>java.lang.StringBuffer <ul>
<li>在lang包下，不需要导包就可以使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>修饰符：final 不能被无法继承</p>
</li>
<li><p>构造方法</p>
</li>
<li><p>成员方法</p>
</li>
</ul>
<hr>
<h4 id="3-StringBuffer中的构造方法"><a href="#3-StringBuffer中的构造方法" class="headerlink" title="3.StringBuffer中的构造方法"></a>3.StringBuffer中的构造方法</h4><h5 id="Ⅰ-无参构造"><a href="#Ⅰ-无参构造" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li><p>StringBuffer()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造一个没有字符的字符串缓冲区，<font color='#d15252'>初始容量为16个字符。 </font></li>
<li>超出长度，自动扩容</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-带参一：StringBuffer-int-capacity"><a href="#Ⅱ-带参一：StringBuffer-int-capacity" class="headerlink" title="Ⅱ. 带参一：StringBuffer(int capacity)"></a>Ⅱ. 带参一：StringBuffer(int capacity)</h5><ul>
<li><p>```java<br>public StringBuffer(int capacity)</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 构造一个没有字符的字符串缓冲区和&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;指定的初始容量&lt;/font&gt;</span><br><span class="line">  - 自己给出长度，系统给出默认值</span><br><span class="line"></span><br><span class="line">##### Ⅲ. 带参三：StringBuffer (String str)</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  StringBuffer (String str)</span><br></pre></td></tr></table></figure>

<ul>
<li>构造一个初始化为指定字符串内容的字符串缓冲区。</li>
<li>手动给出默认值，系统给出长度</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-StringBuffer中的成员方法"><a href="#4-StringBuffer中的成员方法" class="headerlink" title="4.StringBuffer中的成员方法"></a>4.StringBuffer中的成员方法</h4><h5 id="Ⅰ-append"><a href="#Ⅰ-append" class="headerlink" title="Ⅰ.append()"></a>Ⅰ.append()</h5><ul>
<li><p>```java<br>public StringBuffer append (数据类型 变量名)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-<span class="number">20210802205642980</span>](https:<span class="regexp">//i</span>.loli.net<span class="regexp">/2021/</span><span class="number">08</span><span class="regexp">/02/</span>aKrjvFO58PQpeV1.png)</span><br><span class="line"></span><br><span class="line">  - 将xxx类型的参数的字符串表示**&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;追加&lt;/font&gt;**到序列</span><br><span class="line">  - 插入使用insert方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### Ⅱ.capacity()</span></span><br><span class="line"></span><br><span class="line">- 返回当前容量（类似于返回数组长度）</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  public int capacity ()</span><br></pre></td></tr></table></figure>

<ul>
<li>容量是新插入字符可用的存储量，超过此值将进行分配。</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-查找序列"><a href="#Ⅲ-查找序列" class="headerlink" title="Ⅲ.查找序列"></a>Ⅲ.查找序列</h5><p><img src="https://i.loli.net/2021/08/02/U3b4IAxLDEKsNPd.png" alt="image-20210802205941815"></p>
<h5 id="Ⅳ-删除序列"><a href="#Ⅳ-删除序列" class="headerlink" title="Ⅳ.删除序列"></a>Ⅳ.删除序列</h5><p><img src="https://i.loli.net/2021/08/02/52pfHShT4nIgZyW.png" alt="image-20210802210033980"></p>
<h5 id="Ⅴ-插入数据到序列"><a href="#Ⅴ-插入数据到序列" class="headerlink" title="Ⅴ.插入数据到序列"></a>Ⅴ.插入数据到序列</h5><p><img src="https://i.loli.net/2021/08/02/65WPFmKTILZ7oXE.png" alt="image-20210802210221577"></p>
<ul>
<li>offset - 偏移量</li>
</ul>
<h5 id="Ⅵ-其他方法"><a href="#Ⅵ-其他方法" class="headerlink" title="Ⅵ.其他方法"></a>Ⅵ.其他方法</h5><ul>
<li>charAt方法同样可以使用，返回指定索引的char值</li>
<li>indexOf方法同样可以使用，查找指定字符串第一次出现的索引</li>
<li>length()返回长度</li>
<li>toString()返回此顺序中的数据的字符串</li>
<li>subString(start , end)  返回一个新的序列，当前的子序列</li>
</ul>
<h3 id="二、StringBuilder"><a href="#二、StringBuilder" class="headerlink" title="二、StringBuilder"></a>二、StringBuilder</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>第一步：打开API，索引搜索StringBuilder类</p>
</li>
<li><p>第二步：查看该类所在的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.StringBuilder </span><br></pre></td></tr></table></figure>

<ul>
<li>lang包下不需要导包，直接使用</li>
</ul>
</li>
<li><p>第三步：查看概述部分</p>
<ul>
<li>一个<code>StringBuilder</code>的主要操作是<code>append</code>和<code>insert</code>方法，它们是重载的，以便接受任何类型的数据。</li>
<li><code>append</code>方法总是在构建器的末尾添加这些字符;  <code>insert</code>方法将字符添加到指定点。 </li>
<li><code>StringBuilder</code>实例不能安全使用多线程。 如果需要同步，那么建议使用[<code>StringBuffer</code>]</li>
<li>修饰符：final<ul>
<li>不能被继承</li>
</ul>
</li>
</ul>
</li>
<li><p>第四步：查看构造方法</p>
</li>
<li><p>第五步：查看成员方法（功能）</p>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><ul>
<li><font color='#d15252'>与StringBuffer基本相同</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder​() 构造一个没有字符的字符串构建器，初始容量为<span class="number">16</span>个字符。  </span><br><span class="line">StringBuilder​(<span class="keyword">int</span> capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。  </span><br><span class="line">StringBuilder​(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。  </span><br><span class="line">StringBuilder​(String str) 构造一个初始化为指定字符串内容的字符串构建器。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li><font color='#d15252'>与StringBuffer基本相同</font></li>
<li>append（）追加字符串到序列</li>
<li>insert（int offset , 数据类型 变量名）插入字符串到序列中</li>
<li>capacity() 返回容量值</li>
<li>其他一些方法也可以使用，具体看API中解释</li>
</ul>
<h3 id="三、Date"><a href="#三、Date" class="headerlink" title="三、Date"></a>三、Date</h3><h4 id="1-步骤-1"><a href="#1-步骤-1" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>查看API，索引查找Date类</p>
</li>
<li><p>查看包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.util.Date </span><br></pre></td></tr></table></figure>

<ul>
<li>在Java.util包下</li>
</ul>
</li>
<li><p>查看修饰符</p>
<ul>
<li>public 公共，可以直接使用</li>
</ul>
</li>
<li><p>查看方法概述</p>
<ul>
<li><code>Date</code>类代表了一个特定的时间，以毫秒的精度。 </li>
</ul>
</li>
<li><p>查看构造方法</p>
</li>
<li><p>查看成员方法</p>
</li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-无参构造Date"><a href="#Ⅰ-无参构造Date" class="headerlink" title="Ⅰ.无参构造Date()"></a>Ⅰ.无参构造Date()</h5><ul>
<li><p>分配一个 <code>Date</code>对象并对其进行初始化，以便它表示分配的时间，以最接近的毫秒为单位。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/03/rmwf8CReIvl1sUD.png" alt="image-20210803102947756"></p>
<ul>
<li>获取当前时间</li>
</ul>
</li>
</ul>
<h5 id="2-带参构造Date-long-date"><a href="#2-带参构造Date-long-date" class="headerlink" title="2.带参构造Date(long date)"></a>2.带参构造Date(long date)</h5><ul>
<li><p>分配一个  <code>Date</code>对象，并将其初始化为表示从标准基准时间（称为“时代”）即1970年1月1日00:00:00 GMT起的指定毫秒数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Date</span><span class="params">(<span class="keyword">long</span> date)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定时间的日期</li>
</ul>
</li>
</ul>
<h4 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><h5 id="Ⅰ-after-Date-when"><a href="#Ⅰ-after-Date-when" class="headerlink" title="Ⅰ.after(Date when)"></a>Ⅰ.after(Date when)</h5><ul>
<li><p>测试此日期是否在指定日期之后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">after</span><span class="params">(Date when)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-before-Date-when"><a href="#Ⅱ-before-Date-when" class="headerlink" title="Ⅱ.before(Date when)"></a>Ⅱ.before(Date when)</h5><ul>
<li><p>测试此日期是否在指定日期之前。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Date when)</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/03/jzO16BSWeZXsJGT.png" alt="image-20210803104241816"></p>
</li>
</ul>
<h5 id="Ⅲ-compareTo"><a href="#Ⅲ-compareTo" class="headerlink" title="Ⅲ.compareTo"></a>Ⅲ.compareTo</h5><ul>
<li><p>比较两个日期进行订购。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Date anotherDate)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>如果参数Date等于此Date，值为0</p>
</li>
<li><p>如果此日期在Date参数之前，该值小于0 </p>
</li>
</ul>
<h5 id="Ⅳ-equals-Object-obj"><a href="#Ⅳ-equals-Object-obj" class="headerlink" title="Ⅳ.equals(Object obj)"></a>Ⅳ.equals(Object obj)</h5><ul>
<li><p>比较两个日期来平等。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>仅当long值相同时，两个Date对象相等</p>
</li>
</ul>
<h3 id="四、DateFormat"><a href="#四、DateFormat" class="headerlink" title="四、DateFormat"></a>四、DateFormat</h3><h4 id="1-步骤-2"><a href="#1-步骤-2" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>看包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.text.Format </span><br><span class="line">java.text.DateFormat </span><br></pre></td></tr></table></figure>

<ul>
<li>需要导包</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li>public</li>
<li>abstract抽象类<ul>
<li>不能直接实例化，要通过子类实例化</li>
</ul>
</li>
</ul>
</li>
<li><p>方法概述</p>
<ul>
<li><code>DateFormat</code>是一个用于日期/时间格式化子类的抽象类，它以语言无关的方式格式化和分析日期或时间。</li>
<li>就是时间和格式的转换</li>
<li>真正实际上的时间是表示的毫秒值，Long类型</li>
</ul>
</li>
<li><p>直接子类SimpleDateFormat，可以拿来使用</p>
</li>
</ul>
<h4 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-无参构造-1"><a href="#Ⅰ-无参构造-1" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li><p>创建一个新的日期格式。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DateFormat</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-成员方法-2"><a href="#3-成员方法-2" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><p><img src="https://i.loli.net/2021/08/03/QTutOcwN198DW7L.png" alt="image-20210803114002719"></p>
<p><strong>如果变量名打印出来是一个地址值，说明没有重写toString方法</strong></p>
<h4 id="4-子类SimpleDateFormat自定义时间格式"><a href="#4-子类SimpleDateFormat自定义时间格式" class="headerlink" title="4.子类SimpleDateFormat自定义时间格式"></a>4.<font color='#d15252'>子类SimpleDateFormat自定义时间格式</font></h4><p><img src="https://i.loli.net/2021/08/03/WgCZvmBzLiVupOq.png" alt="image-20210803142244201"></p>
<h5 id="Ⅰ-无参构造创建对象"><a href="#Ⅰ-无参构造创建对象" class="headerlink" title="Ⅰ.无参构造创建对象"></a>Ⅰ.无参构造创建对象</h5><ul>
<li><p>构造一个 <code>SimpleDateFormat</code>使用默认模式和日期格式符号为默认的 [<code>FORMAT</code>]区域设置。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SimpleDateFormat​()</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-有参构造创建对象"><a href="#Ⅱ-有参构造创建对象" class="headerlink" title="Ⅱ.有参构造创建对象"></a>Ⅱ.有参构造创建对象</h5><ul>
<li><p>使用给定的模式和日期格式符号构造一个 <code>SimpleDateFormat</code> 。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">//通过子类调用    //如果带参则制定规则</span></span><br><span class="line">SimpleDateFormat s = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年M月d日HH:mm:ss&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个时间规则</p>
</li>
</ul>
<h5 id="Ⅲ-成员方法"><a href="#Ⅲ-成员方法" class="headerlink" title="Ⅲ.成员方法"></a>Ⅲ.成员方法</h5><ul>
<li><h5 id="format方法"><a href="#format方法" class="headerlink" title="format方法"></a>format方法</h5><ul>
<li>将给定的 <code>Date</code>为日期/时间字符串，并将结果追加到给定的  <code>StringBuffer</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuffer <span class="title">format</span><span class="params">(Date date,</span></span></span><br><span class="line"><span class="params"><span class="function">                           StringBuffer toAppendTo,</span></span></span><br><span class="line"><span class="params"><span class="function">                           FieldPosition pos)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="五、Calendar"><a href="#五、Calendar" class="headerlink" title="五、Calendar"></a>五、Calendar</h3><h4 id="1-步骤-3"><a href="#1-步骤-3" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>看包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.util.Calendar </span><br></pre></td></tr></table></figure>

<ul>
<li>需要导包后才能使用</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li>public </li>
<li>abstract<ul>
<li>抽象类，不能直接实例化，要用子类</li>
</ul>
</li>
</ul>
</li>
<li><p>方法概述</p>
</li>
<li><p>构造方法</p>
</li>
<li><p>成员方法</p>
</li>
</ul>
<h4 id="2-构造方法-3"><a href="#2-构造方法-3" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-无参构造Calendar"><a href="#Ⅰ-无参构造Calendar" class="headerlink" title="Ⅰ.无参构造Calendar()"></a>Ⅰ.无参构造Calendar()</h5><ul>
<li><p>构造具有默认时区和默认 [<code>FORMAT</code>]语言环境的日历。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Calendar</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-带参构造"><a href="#Ⅱ-带参构造" class="headerlink" title="Ⅱ.带参构造"></a>Ⅱ.带参构造</h5><ul>
<li><p>构造具有指定时区和区域设置的日历。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Calendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="params"><span class="function">                   Locale aLocale)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>zone - 使用的时区</li>
<li>aLocale - 周数据的区域设置</li>
</ul>
</li>
</ul>
<h4 id="4-已知直接子类GregorianCalendar"><a href="#4-已知直接子类GregorianCalendar" class="headerlink" title="4.已知直接子类GregorianCalendar"></a>4.已知直接子类GregorianCalendar</h4><h3 id="六、补充知识点"><a href="#六、补充知识点" class="headerlink" title="六、补充知识点"></a>六、补充知识点</h3><ul>
<li>API中<font color='#d15252'>Fields</font>的区域都是常量</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>StringBuffer</tag>
        <tag>StringBuilder</tag>
        <tag>Date</tag>
        <tag>DateFormat</tag>
        <tag>Calender</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList集合和方法练习</title>
    <url>/2021/08/25/ArrayList%E9%9B%86%E5%90%88%E5%92%8C%E6%96%B9%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="一、练习"><a href="#一、练习" class="headerlink" title="一、练习"></a>一、练习</h3><h4 id="1-编写思路"><a href="#1-编写思路" class="headerlink" title="1.编写思路"></a>1.编写思路</h4><ul>
<li>创建项目，测试环境</li>
<li>需求分析</li>
<li>先实现菜单<ul>
<li>创建菜单方法<ul>
<li>方法位置：并列</li>
<li>格式：修饰符 返回值类型 方法名（）{  }</li>
</ul>
</li>
</ul>
</li>
<li>实现菜单的选择<ul>
<li>创建判断键盘录入选择的方法</li>
<li>调用menu方法，实现每次选择时，展示菜单</li>
<li>Scanner  三个步骤，录入键盘数据</li>
<li>调用加载数据的方法，并创建一个数组名保存</li>
<li>if+else if 实现键盘录入数据的判断</li>
<li>设置死循环，实现菜单的重复选择</li>
<li>当a=5时，退出，break;</li>
</ul>
</li>
<li>实现加载数据<ul>
<li>创建加载数据方法</li>
<li>定义一个数组并初始化数据</li>
<li>return返回值arr数组，返回值类型int[]</li>
</ul>
</li>
<li>实现具体的选择项的功能（查看）<ul>
<li>当choose方法中录入键盘数据为1时</li>
<li>调用show方法，并传递参数arr</li>
</ul>
</li>
<li>实现查看功能<ul>
<li>定义方法</li>
<li>定义一个数组参数，用于接收数据</li>
<li>用for循环遍历数组</li>
<li>if判断不是0再输出</li>
</ul>
</li>
<li>实现修改功能<ul>
<li>定义方法</li>
<li>键盘录入要修改的id</li>
<li>for循环遍历数组，IF查找有没有匹配的id<ul>
<li>在方法定义中，添加参数int[] arr ，用于接收数组</li>
</ul>
</li>
<li>在choose方法中，当选择2时，调用修改方法，并且传递参数–数组</li>
</ul>
</li>
</ul>
<h4 id="2-内存图"><a href="#2-内存图" class="headerlink" title="2.内存图"></a>2.内存图</h4><img src="https://i.loli.net/2021/07/23/8KSZyjmXNIGYVeT.png" alt="image-20210723153545299" style="zoom:200%;" />



<h3 id="二、ArrayList集合"><a href="#二、ArrayList集合" class="headerlink" title="二、ArrayList集合"></a>二、<font color='#d15252'>ArrayList</font>集合</h3><ul>
<li>变量：存一个数</li>
<li>数组：多个数，但长度固定</li>
<li>集合ArrayList</li>
</ul>
<h4 id="1-ArrayList的概念"><a href="#1-ArrayList的概念" class="headerlink" title="1.ArrayList的概念"></a>1.ArrayList的概念</h4><ul>
<li>什么是ArrayList?<ul>
<li>是一个容器，<font color='#d15252'>长度不固定</font></li>
</ul>
</li>
</ul>
<h4 id="2-ArrayList的使用"><a href="#2-ArrayList的使用" class="headerlink" title="2.ArrayList的使用"></a>2.ArrayList的使用</h4><h5 id="①使用前的准备"><a href="#①使用前的准备" class="headerlink" title="①使用前的准备"></a>①使用前的准备</h5><ul>
<li><p>导包</p>
</li>
<li><p><code>import java.util.ArrayList;</code></p>
</li>
<li><p>加载进内存</p>
<ul>
<li><code>ArrayList&lt;数据类型&gt;变量名 = new ArrayList();</code><ul>
<li>数据类型：不能用int ，而是要用 <code>Integer</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="②具体使用"><a href="#②具体使用" class="headerlink" title="②具体使用"></a>②具体使用</h5><ul>
<li><p>添加</p>
<ul>
<li>使用 <code>add();</code> 方法<ul>
<li><code>例：list.add(12); -----&gt;存入12进集合</code></li>
</ul>
</li>
</ul>
</li>
<li><p>删除</p>
<ul>
<li>使用 <code>remove();</code> 方法<ul>
<li><code>例：list.remove(1); ----&gt;删除索引为1的数据</code></li>
</ul>
</li>
</ul>
</li>
<li><p>获取</p>
<ul>
<li><p>使用 <code>get(索引);</code> 方法</p>
<ul>
<li><p>单独调用（无意义）</p>
<ul>
<li><code>例：list.get(1); ----&gt;取出索引为1的数据</code></li>
</ul>
</li>
<li><p>输出调用</p>
<ul>
<li><code>例：System.out.println(list.get(2))---&gt;直接输出索引2数据</code></li>
</ul>
</li>
<li><p>赋值调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = list.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>长度</p>
<ul>
<li>使用 <code>size();</code> 方法</li>
</ul>
</li>
<li><p>更新</p>
<ul>
<li><p>使用 <code>set();</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">id.set(索引，新的数值);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ArrayList</tag>
        <tag>方法</tag>
        <tag>增查删改</tag>
      </tags>
  </entry>
  <entry>
    <title>API的使用之Objece\String</title>
    <url>/2021/08/25/API%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B9%8BObjece-String/</url>
    <content><![CDATA[<h3 id="一、Java的API"><a href="#一、Java的API" class="headerlink" title="一、Java的API"></a>一、Java的API</h3><h4 id="1-API的概念"><a href="#1-API的概念" class="headerlink" title="1.API的概念"></a>1.API的概念</h4><ul>
<li>之前的练习题：面向对象理论知识的总结</li>
<li>JavaApi是对面向对象知识实践的一个总结</li>
</ul>
<ul>
<li><strong>API：应用程序接口 —&gt; src下的内容</strong><ul>
<li>A：Application:应用</li>
<li>P：Programing:程序</li>
<li>I：interface:接口</li>
</ul>
</li>
<li>是使用Java的一份说明书</li>
</ul>
<h4 id="2-API的优势"><a href="#2-API的优势" class="headerlink" title="2.API的优势"></a>2.API的优势</h4><ul>
<li>将Java提供好的工具类，做了调整<ul>
<li>详细描述</li>
<li>构造方法</li>
<li>成员方法</li>
</ul>
</li>
<li>众多的Java工具类，学习哪个都可以，但有一个必须要学<ul>
<li>**<font color='#d15252'>Object</font>**：Java中所有的类的父类<ul>
<li>不管是自定义类还是Java自带的工具类，所有的类最顶层的父类，都是Object类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二、Object类"><a href="#二、Object类" class="headerlink" title="二、Object类"></a>二、Object类</h3><h4 id="1-学习Object类的步骤"><a href="#1-学习Object类的步骤" class="headerlink" title="1.学习Object类的步骤"></a>1.学习Object类的步骤</h4><ul>
<li><p>第一步：打开API的索引，直接搜索想要的类(注意大小写)</p>
</li>
<li><p>第二步：查看该类所在的包（<font color='#d15252'>java.lang</font>）</p>
<ul>
<li>所有Java.lang包下的工具类，直接使用，<font color='orange'>不需要导包</font></li>
</ul>
</li>
<li><p>第三步：查看该类的概述部分</p>
<ul>
<li>查看该类的修饰符</li>
<li>查看具体功能描述</li>
</ul>
</li>
<li><p>第四步：<font color='#d15252'><strong>需要看构造方法</strong></font></p>
<ul>
<li>查看object就是为了使用，要使用就需要创建对象new，就需要调用构造方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li>
<li><p>第五步：<font color='#d15252'>查看该类的方法</font></p>
<ul>
<li>使用该类，真正意义上是使用类中提供的方法</li>
</ul>
</li>
</ul>
<h4 id="2-Object类中的方法"><a href="#2-Object类中的方法" class="headerlink" title="2.Object类中的方法"></a>2.Object类中的方法</h4><ul>
<li>重点：修饰符，返回值，参数</li>
</ul>
<h5 id="Ⅰ-clone-方法"><a href="#Ⅰ-clone-方法" class="headerlink" title="Ⅰ. clone()方法"></a>Ⅰ. clone()方法</h5><ul>
<li>创建并返回此对象的副本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>clone()方法默认由protected修饰，所以子类不能直接访问<ul>
<li>需要重写该方法</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-equals-方法"><a href="#Ⅱ-equals-方法" class="headerlink" title="Ⅱ. equals()方法"></a>Ⅱ. equals()方法</h5><ul>
<li>指示一些其他对象是否等于此.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span> <span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"> Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line"> <span class="keyword">boolean</span> equals = o.equals(<span class="number">02</span>);</span><br><span class="line"> System.out.println(equals);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回结果false</span></span><br></pre></td></tr></table></figure></li>
<li><p>默认情况下，比较的是引用类型的地址值，意义不大，所以通常要重写</p>
</li>
</ul>
<h5 id="Ⅲ-toString-方法"><a href="#Ⅲ-toString-方法" class="headerlink" title="Ⅲ. toString()方法"></a>Ⅲ. toString()方法</h5><ul>
<li>返回对象的字符串表示形式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>当我们在使用输出语句，输出对象名的时候，底层走的就是toString方法</li>
</ul>
<h3 id="三、String类"><a href="#三、String类" class="headerlink" title="三、String类"></a>三、String类</h3><h4 id="1-学习步骤"><a href="#1-学习步骤" class="headerlink" title="1.学习步骤"></a>1.学习步骤</h4><ul>
<li><p>第一步：打开API索引，搜索String类</p>
</li>
<li><p>第二步：查看所在的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.lang.String </span><br></pre></td></tr></table></figure>

<ul>
<li>lang包直接使用，不需要导包</li>
</ul>
</li>
<li><p>第三步：查看该类的概述部分</p>
<ul>
<li><p>String用来final修饰，不能被继承</p>
</li>
<li><p>继承了Object，实现了三个接口</p>
</li>
<li><p>之前我们使用String类型时，并没有使用new关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，底层帮我们做了一系列操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String str = <span class="keyword">new</span> String(data);	<span class="comment">//调用了String的有参构造</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>第四步：需要看构造方法</p>
<ul>
<li>```java<br>String()<br>String(byte[] bytes)<br>String(char[] value, int offset, int count)<br>String(String original)<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 第五步：方法</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">  charAt​(<span class="built_in">int</span> index)</span><br><span class="line">  compareTo​(<span class="keyword">String</span> anotherString)</span><br><span class="line">  <span class="built_in">concat</span>​(<span class="keyword">String</span> <span class="built_in">str</span>)</span><br><span class="line">  endsWith​(<span class="keyword">String</span> suffix)</span><br><span class="line">  equals​(<span class="keyword">Object</span> anObject)</span><br><span class="line">  getBytes​()    </span><br><span class="line">  indexOf​(<span class="keyword">String</span> <span class="built_in">str</span>)</span><br><span class="line">  length​()    </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-String类中的构造方法"><a href="#2-String类中的构造方法" class="headerlink" title="2.String类中的构造方法"></a>2.String类中的构造方法</h4><h5 id="Ⅰ-String"><a href="#Ⅰ-String" class="headerlink" title="Ⅰ. String()"></a>Ⅰ. String()</h5><ul>
<li>初始化新创建的 <code>String</code>对象，以使其表示空字符序列。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span> <span class="params">(String original)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="Ⅱ-String-byte-bytes"><a href="#Ⅱ-String-byte-bytes" class="headerlink" title="Ⅱ. String(byte[] bytes)"></a>Ⅱ. String(byte[] bytes)</h5><ul>
<li>通过使用平台的默认字符集解码指定的字节数组来构造新的 <code>String</code> </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span> <span class="params">(<span class="keyword">byte</span>[] bytes)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="Ⅲ-String-char-value-int-offset-int-count"><a href="#Ⅲ-String-char-value-int-offset-int-count" class="headerlink" title="Ⅲ. String(char[] value, int offset, int count)"></a>Ⅲ. String(char[] value, int offset, int count)</h5><ul>
<li>分配一个新的 <code>String</code> ，其中包含字符数组参数的子阵列中的字符。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span> <span class="params">(<span class="keyword">int</span>[] codePoints,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="keyword">int</span> count)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>offset：初始偏移量<ul>
<li>从数组哪个位置开始取</li>
</ul>
</li>
<li>count：长度、个数<ul>
<li>取多少个数据</li>
</ul>
</li>
</ul>
<h5 id="Ⅳ-String-String-original"><a href="#Ⅳ-String-String-original" class="headerlink" title="Ⅳ. String(String original)"></a>Ⅳ. String(String original)</h5><ul>
<li>初始化新创建的<code>String</code>对象，使其表示与参数相同的字符序列;  换句话说，新创建的字符串是参数字符串的副本。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span> <span class="params">(String original)</span></span></span><br></pre></td></tr></table></figure>



<hr>
<h4 id="3-String类中的成员方法"><a href="#3-String类中的成员方法" class="headerlink" title="3.String类中的成员方法"></a>3.String类中的成员方法</h4><h5 id="Ⅰ-charAt-int-index"><a href="#Ⅰ-charAt-int-index" class="headerlink" title="Ⅰ. charAt(int index)"></a>Ⅰ. charAt(int index)</h5><ul>
<li>返回指定索引处的 <code>char</code>值。<ul>
<li>返回指定索引处的<code>char</code>值。  指数范围从<code>0</code>到<code>length() - 1</code> 。  序列的第一个<code>char</code>值是索引<code>0</code> ，下一个索引为<code>1</code>  ，依此类推，就像数组索引一样。 </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="comment">//创建一个String类型的对象，调用方法</span></span><br><span class="line">      String s = <span class="keyword">new</span> String(<span class="string">&quot;高宇航&quot;</span>);</span><br><span class="line">      System.out.println(s.charAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//控制台输出结果：宇</span></span><br></pre></td></tr></table></figure>

<ul>
<li>简单来说，就是取出对应索引的char数据</li>
<li>案例：键盘录入一串字符，计算大写小写数字个数<ul>
<li>“12ljlfsrAEr5875”</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-compareTo-String-anotherString"><a href="#Ⅱ-compareTo-String-anotherString" class="headerlink" title="Ⅱ. compareTo(String anotherString)"></a>Ⅱ. compareTo(String anotherString)</h5><ul>
<li>按字典顺序比较两个字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span> <span class="params">(String anotherString)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        String s = <span class="string">&quot;高宇航&quot;</span>;</span><br><span class="line">        String s1 = <span class="string">&quot;高宇航&quot;</span>;</span><br><span class="line">        <span class="comment">//测试compareTo方法</span></span><br><span class="line">        System.out.println(s.compareTo(s1));</span><br><span class="line"><span class="comment">//程序输出0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果字符串相等，结果为零</li>
<li>如果字符串s长度大于s1时，返回的值是正数</li>
<li>如果字符串s长度小于s1时，返回的值是负数</li>
</ul>
<h5 id="Ⅲ-concat-String-str"><a href="#Ⅲ-concat-String-str" class="headerlink" title="Ⅲ. concat(String str)"></a>Ⅲ. concat(String str)</h5><ul>
<li>将指定的字符串连接到该字符串的末尾。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//测试String类中的concat方法</span></span><br><span class="line"><span class="comment">//将指定的字符串连接到该字符串的末尾</span></span><br><span class="line">        <span class="comment">//定义一个String对象</span></span><br><span class="line">        String s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        String s1 = s.concat(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        <span class="comment">//返回结果HelloWorld</span></span><br></pre></td></tr></table></figure>

<ul>
<li>即字符串的拼接，在先有字符串后面添加</li>
</ul>
<h5 id="Ⅳ-endsWith-String-suffix"><a href="#Ⅳ-endsWith-String-suffix" class="headerlink" title="Ⅳ. endsWith(String suffix)"></a>Ⅳ. endsWith(String suffix)</h5><ul>
<li>测试此字符串是否以指定的后缀结尾。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>suffix：后缀</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试String类中的endsWith(String suffix)方法</span></span><br><span class="line"><span class="comment">//创建一个字符串</span></span><br><span class="line">String s = <span class="string">&quot;abcdggg&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> g = s.endsWith(<span class="string">&quot;g&quot;</span>);</span><br><span class="line">System.out.println(g);</span><br><span class="line"><span class="comment">//返回值true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回一个布尔类型的值，true或false</li>
</ul>
<h5 id="Ⅴ-equals-Object-anObject"><a href="#Ⅴ-equals-Object-anObject" class="headerlink" title="Ⅴ. equals(Object anObject)"></a>Ⅴ. equals(Object anObject)</h5><ul>
<li>将此字符串与指定对象进行比较。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试String类中的equals方法</span></span><br><span class="line">String s = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">String s1 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> equals = s.equals(s1);</span><br><span class="line">System.out.println(equals);</span><br><span class="line"><span class="comment">//返回flase</span></span><br></pre></td></tr></table></figure>

<ul>
<li>仅当参数不是null并且字符序列相同时，返回true</li>
<li>否则返回false</li>
</ul>
<h5 id="Ⅵ-getBytes"><a href="#Ⅵ-getBytes" class="headerlink" title="Ⅵ.getBytes()"></a>Ⅵ.getBytes()</h5><ul>
<li>使用平台的默认字符集(ASCII)将该 <code>String</code>编码为一系列字节，将结果存储到新的字节数组中。 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试String类的getBytes()</span></span><br><span class="line">        <span class="comment">//创建一个String类型对象</span></span><br><span class="line">        String s = <span class="string">&quot;abcdef&quot;</span>;</span><br><span class="line">        System.out.println(s.getBytes());   <span class="comment">//[B@10f87f48</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;bytes.length;i++)&#123;</span><br><span class="line">            System.out.println(bytes[i]);</span><br><span class="line">            <span class="comment">//97 98 99 100 101 102</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>将该<code>String</code>编码为一系列字节，将结果存储到新的字节数组中。 </li>
</ul>
<h5 id="Ⅶ-indexOf-String-str"><a href="#Ⅶ-indexOf-String-str" class="headerlink" title="Ⅶ.indexOf(String str)"></a>Ⅶ.indexOf(String str)</h5><ul>
<li>返回指定子字符串第一次出现的字符串内的索引。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        测试main方法中的indexOf(String str)方法</span></span><br><span class="line">        <span class="comment">//创建一个String类型对象</span></span><br><span class="line">        String s = <span class="string">&quot;Hello,java&quot;</span>;</span><br><span class="line">        <span class="comment">//使用indexOf方法查找指定字符串第一次出现的索引</span></span><br><span class="line">        System.out.println( s.indexOf(<span class="string">&quot;java&quot;</span>));</span><br><span class="line">        <span class="comment">//得出结果6,在第六个索引出现java</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果没有要查找的值，则返回<code>-1</code> 。</li>
<li>str/ch 要搜索的字符串</li>
</ul>
<h5 id="Ⅷ-length"><a href="#Ⅷ-length" class="headerlink" title="Ⅷ.length()"></a>Ⅷ.length()</h5><ul>
<li>返回此字符串的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试字符串长度</span></span><br><span class="line">    String s = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">    <span class="comment">//返回结果8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回此字符串的长度。 长度等于字符串中的数字<a href="Character.html#unicode">Unicode code units</a> 。 </li>
</ul>
<h4 id="4-作业"><a href="#4-作业" class="headerlink" title="4.作业"></a>4.作业</h4><h5 id="Ⅰ-将字符串中，第一个字母转换成大写，其他的转换成小写。并输出。"><a href="#Ⅰ-将字符串中，第一个字母转换成大写，其他的转换成小写。并输出。" class="headerlink" title="Ⅰ. 将字符串中，第一个字母转换成大写，其他的转换成小写。并输出。"></a>Ⅰ. 将字符串中，第一个字母转换成大写，其他的转换成小写。并输出。</h5><ul>
<li><p>aaslkASGGR</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//作业练习一：将字符串中，第一个字母转换成大写，其他的转换成小写。并输出。</span></span><br><span class="line">    <span class="comment">//aaslkASGGR</span></span><br><span class="line">    <span class="comment">//将所有String字符转为小写 public String toLowerCase​()</span></span><br><span class="line">    <span class="comment">//转换大写toUpperCase()</span></span><br><span class="line">    String s = <span class="string">&quot;aaslkASGGR&quot;</span>;</span><br><span class="line">    <span class="comment">//使用substring提取第一个字符，并转为大写</span></span><br><span class="line">    String substring = s.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase();</span><br><span class="line">    <span class="comment">//提取剩下的字符，并转为小写</span></span><br><span class="line">    String s1 = s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    <span class="comment">//将两个字符串拼接</span></span><br><span class="line">    System.out.println(substring+s1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-”afjpiwqjava9javajavajsjfkaksjafjafealjava”-计算Java个数"><a href="#Ⅱ-”afjpiwqjava9javajavajsjfkaksjafjafealjava”-计算Java个数" class="headerlink" title="Ⅱ.”afjpiwqjava9javajavajsjfkaksjafjafealjava”,计算Java个数"></a>Ⅱ.”afjpiwqjava9javajavajsjfkaksjafjafealjava”,计算Java个数</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//&quot;afjpiwqjava9javajavajsjfkaksjafjafealjava&quot;,计算Java的个数</span></span><br><span class="line">    <span class="comment">//定义一个java的字符串</span></span><br><span class="line">    String str = <span class="string">&quot;afjpiwqjava9javajavajsjfkaksjafjafealjava&quot;</span>;</span><br><span class="line">    String s = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">    <span class="comment">//indexOf​(int ch) 返回指定字符第一次出现的字符串内的索引。</span></span><br><span class="line">    <span class="comment">//str.indexOf(s);得出第一个java在第7个索引位置</span></span><br><span class="line">    <span class="comment">//第二次查找需要在第10个位置继续往下查找</span></span><br><span class="line">    <span class="comment">//定义一个变量保存索引</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((index = str.indexOf(s))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">         str = str.substring(index + s.length());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四、StringBuffer类"><a href="#四、StringBuffer类" class="headerlink" title="四、StringBuffer类"></a>四、StringBuffer类</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>搜索打开StringBuffer类的API</p>
</li>
<li><p>查看所在包</p>
<ul>
<li>java.lang.StringBuffer <ul>
<li>在lang包下，不需要导包就可以使用</li>
</ul>
</li>
</ul>
</li>
<li><p>查看概述</p>
<ul>
<li>修饰符：final 不能被无法继承</li>
<li>这个类已经被一个等同的类补充了，它被设计为使用一个线程， StringBuilder。<ul>
<li>通常应该使用<code>StringBuilder</code>类，因为它支持所有相同的操作，但它更快，因为它不执行同步。 </li>
</ul>
</li>
</ul>
</li>
<li><p>查看构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer​() 构造一个没有字符的字符串缓冲区，初始容量为<span class="number">16</span>个字符。  </span><br><span class="line">StringBuffer​(<span class="keyword">int</span> capacity) 构造一个没有字符的字符串缓冲区和指定的初始容量。  </span><br><span class="line">StringBuffer​(CharSequence seq) 构造一个字符串缓冲区，其中包含与指定的 CharSequence相同的字符。  </span><br><span class="line">StringBuffer​(String str) 构造一个初始化为指定字符串内容的字符串缓冲区。  </span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用成员方法</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">append</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/02/MKIzgrnd7OhtZHU.png" alt="image-20210802204833609"></p>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-无参构造"><a href="#Ⅰ-无参构造" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li><p>StringBuffer()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>构造一个没有字符的字符串缓冲区，<font color='#d15252'>初始容量为16个字符。 </font></li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-带参一：StringBuffer-int-capacity"><a href="#Ⅱ-带参一：StringBuffer-int-capacity" class="headerlink" title="Ⅱ. 带参一：StringBuffer(int capacity)"></a>Ⅱ. 带参一：StringBuffer(int capacity)</h5><ul>
<li>```java<br>public StringBuffer(int capacity)<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - 构造一个没有字符的字符串缓冲区和&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;指定的初始容量&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">##### Ⅲ.带参二、三</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20210802205551809</span>](https:<span class="comment">//i.loli.net/2021/08/02/rTHljxByQSK1o8X.png)</span></span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>成员方法</span><br><span class="line"></span><br><span class="line">##### Ⅰ.append()</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public StringBuffer append (数据类型 变量名)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://i.loli.net/2021/08/02/aKrjvFO58PQpeV1.png" alt="image-20210802205642980"></p>
<ul>
<li>将xxx类型的参数的字符串表示**<font color='#d15252'>追加</font>**到序列</li>
<li>插入使用insert方法</li>
</ul>
<h5 id="Ⅱ-capacity"><a href="#Ⅱ-capacity" class="headerlink" title="Ⅱ.capacity()"></a>Ⅱ.capacity()</h5><ul>
<li><p>返回当前容量（类似于返回数组长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">capacity</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>容量是新插入字符可用的存储量，超过此值将进行分配。</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-查找序列"><a href="#Ⅲ-查找序列" class="headerlink" title="Ⅲ.查找序列"></a>Ⅲ.查找序列</h5><p><img src="https://i.loli.net/2021/08/02/U3b4IAxLDEKsNPd.png" alt="image-20210802205941815"></p>
<h5 id="Ⅳ-删除序列"><a href="#Ⅳ-删除序列" class="headerlink" title="Ⅳ.删除序列"></a>Ⅳ.删除序列</h5><p><img src="https://i.loli.net/2021/08/02/52pfHShT4nIgZyW.png" alt="image-20210802210033980"></p>
<h5 id="Ⅴ-插入数据到序列"><a href="#Ⅴ-插入数据到序列" class="headerlink" title="Ⅴ.插入数据到序列"></a>Ⅴ.插入数据到序列</h5><p><img src="https://i.loli.net/2021/08/02/65WPFmKTILZ7oXE.png" alt="image-20210802210221577"></p>
<ul>
<li>offset - 偏移量</li>
</ul>
<h5 id="Ⅵ-其他方法"><a href="#Ⅵ-其他方法" class="headerlink" title="Ⅵ.其他方法"></a>Ⅵ.其他方法</h5><ul>
<li>charAt方法同样可以使用，返回指定索引的char值</li>
<li>indexOf方法同样可以使用，查找指定字符串第一次出现的索引</li>
<li>length()返回长度</li>
<li>toString()返回此顺序中的数据的字符串</li>
<li>subString(start , end)  返回一个新的序列，当前的子序列</li>
</ul>
<h3 id="五、StringBuilder类"><a href="#五、StringBuilder类" class="headerlink" title="五、StringBuilder类"></a>五、StringBuilder类</h3><h4 id="1-步骤-1"><a href="#1-步骤-1" class="headerlink" title="1.步骤"></a>1.步骤</h4><ul>
<li><p>第一步：打开API，索引搜索StringBuilder类</p>
</li>
<li><p>第二步：查看该类所在的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.StringBuilder </span><br></pre></td></tr></table></figure>

<ul>
<li>lang包下不需要导包，直接使用</li>
</ul>
</li>
<li><p>第三步：查看概述部分</p>
<ul>
<li>一个<code>StringBuilder</code>的主要操作是<code>append</code>和<code>insert</code>方法，它们是重载的，以便接受任何类型的数据。</li>
<li><code>append</code>方法总是在构建器的末尾添加这些字符;  <code>insert</code>方法将字符添加到指定点。 </li>
<li><code>StringBuilder</code>实例不能安全使用多线程。 如果需要同步，那么建议使用[<code>StringBuffer</code>]</li>
</ul>
</li>
<li><p>第四步：查看构造方法</p>
</li>
<li><p>第五步：查看成员方法（功能）</p>
</li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><ul>
<li>与StringBuffer基本相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder​() 构造一个没有字符的字符串构建器，初始容量为<span class="number">16</span>个字符。  </span><br><span class="line">StringBuilder​(<span class="keyword">int</span> capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。  </span><br><span class="line">StringBuilder​(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。  </span><br><span class="line">StringBuilder​(String str) 构造一个初始化为指定字符串内容的字符串构建器。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li>与StringBuffer基本相同</li>
<li>append（）追加字符串到序列</li>
<li>insert（int offset , 数据类型 变量名）插入字符串到序列中</li>
<li>capacity() 返回容量值</li>
<li>其他一些方法也可以使用，具体看API中解释</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>API</tag>
        <tag>Object</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>File类和递归</title>
    <url>/2021/08/25/File%E7%B1%BB%E5%92%8C%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h3 id="一、File"><a href="#一、File" class="headerlink" title="一、File"></a>一、File</h3><ul>
<li>Java可以操作我们的本地硬盘<ul>
<li>文件和目录路径名的抽象表示<ul>
<li>文件</li>
<li>内容</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-什么是File类"><a href="#1-什么是File类" class="headerlink" title="1.什么是File类"></a>1.什么是File类</h4><ul>
<li>就是对我们本地文件管理的类（文件夹在java中是File）</li>
</ul>
<h4 id="2-使用File类"><a href="#2-使用File类" class="headerlink" title="2.使用File类"></a>2.使用File类</h4><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><ul>
<li><h6 id="pathSeparator（了解）"><a href="#pathSeparator（了解）" class="headerlink" title="pathSeparator（了解）"></a>pathSeparator（了解）</h6><ul>
<li> 与系统相关的路径分隔符字符，为方便起见，表示为字符串。</li>
<li> 直接输出可以得到一个 ”；” 分号</li>
</ul>
</li>
</ul>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><h6 id="Ⅰ-File-File-parent-String-child"><a href="#Ⅰ-File-File-parent-String-child" class="headerlink" title="Ⅰ.File(File parent, String child)"></a>Ⅰ.File(File parent, String child)</h6><ul>
<li>从父抽象路径名和子路径名字符串创建新的 File实例。</li>
</ul>
<h6 id="Ⅱ-File-String-pathname"><a href="#Ⅱ-File-String-pathname" class="headerlink" title="Ⅱ.File(String pathname)"></a>Ⅱ.File(String pathname)</h6><ul>
<li>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。  </li>
</ul>
<h6 id="Ⅲ-File-String-parent-String-child"><a href="#Ⅲ-File-String-parent-String-child" class="headerlink" title="Ⅲ.File(String parent, String child)"></a>Ⅲ.File(String parent, String child)</h6><ul>
<li> 从父路径名字符串和子路径名字符串创建新的 File实例。  </li>
</ul>
<p><img src="https://i.loli.net/2021/08/06/2GEvFzH5uYcWSmf.png" alt="image-20210806095327726"></p>
<blockquote>
<p>抽象：File表示的这个目录，可能存在也可能不存在，所以被称为是抽象的</p>
</blockquote>
<blockquote>
<p>三个构造方法的区别：不要从应用层，因为我们还没有遇到这样的案例。 先单独从表层考虑</p>
</blockquote>
<h4 id="3-成员方法-—-File类的获取方法"><a href="#3-成员方法-—-File类的获取方法" class="headerlink" title="3.成员方法 — File类的获取方法"></a>3.成员方法 — File类的获取方法</h4><ul>
<li>getAbsolutePath()<ul>
<li>返回此抽象路径名的绝对路径名字符串。</li>
<li>即返回全路径（<font color='#d15252'>绝对路径</font>）</li>
</ul>
</li>
<li>getName()<ul>
<li>返回由此抽象路径名表示的文件或目录的名称</li>
<li>即返回最后一个路径（<font color='#d15252'>相对路径</font>）</li>
</ul>
</li>
<li>getPath()<ul>
<li>将此<strong>抽象路径名</strong>转换为路径名字符串</li>
</ul>
</li>
<li>length()<ul>
<li>返回由此抽象路径名表示的文件的长度</li>
<li>文件的长度、字节数<ul>
<li>但当获取文件夹的大小时，通常不够准确</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-成员方法-—-文件-文件夹的创建及删除"><a href="#4-成员方法-—-文件-文件夹的创建及删除" class="headerlink" title="4.成员方法 — 文件/文件夹的创建及删除"></a>4.成员方法 — 文件/文件夹的创建及删除</h4><ul>
<li>createNewFile<ul>
<li>当且仅当具有该名称的文件尚不存在时，原地创建一个由该抽象路径名命名的新的空文件<ul>
<li>简单来说就是创建一个文件</li>
<li>创建成功的前提条件：无此文件</li>
</ul>
</li>
</ul>
</li>
<li>mkdir()<ul>
<li>创建目录（单层）</li>
</ul>
</li>
<li>mkdirs()<ul>
<li>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。<ul>
<li>简单来说就是创建文件夹</li>
<li>可以创建多个</li>
</ul>
</li>
</ul>
</li>
<li>isFile()<ul>
<li>测试此抽象路径名表示的文件是否为普通文件。</li>
</ul>
</li>
<li>delete()<ul>
<li><font color='#d15252'>删除</font>由此抽象路径名表示的文件或目录</li>
</ul>
</li>
<li>isDirectory()<ul>
<li>测试此抽象路径名表示的文件是否为目录<ul>
<li>前提条件：目录一定要存在</li>
</ul>
</li>
</ul>
</li>
<li>exists()<ul>
<li>测试此抽象路径名表示的文件或目录是否存在</li>
</ul>
</li>
</ul>
<h4 id="5-成员方法-—-获取文件目录"><a href="#5-成员方法-—-获取文件目录" class="headerlink" title="5.成员方法 — 获取文件目录"></a>5.成员方法 — 获取文件目录</h4><h5 id="Ⅰ-list"><a href="#Ⅰ-list" class="headerlink" title="Ⅰ.list()"></a>Ⅰ.list()</h5><ul>
<li><p>返回一个字符串数组，命名由此抽象路径名表示的目录中的文件和目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] list():获取路径中的子目录/文件</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list方法，返回绝对路径，是String字符串类型的</span></span><br><span class="line">String[] list = f.list();</span><br><span class="line"><span class="comment">//循环遍历查看结果</span></span><br><span class="line"><span class="keyword">for</span> (String i: list)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-listFiles"><a href="#Ⅱ-listFiles" class="headerlink" title="Ⅱ.listFiles()"></a>Ⅱ.<font color='#d15252'>listFiles()</font></h5><ul>
<li><p>与list()功能一样,但返回的是File()类型的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] listFiles()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//listFiles方法，返回File对象，更加灵活，可以再次进行操作</span></span><br><span class="line">File[] files = f.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File i : files)&#123;</span><br><span class="line">    <span class="comment">//返回绝对路径是因为默认重写了toString方法</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用listFiles()更加灵活，因为返回值是File类型，可继续使用File的其他功能</p>
</li>
</ul>
<h5 id="Ⅲ-listFiles-FileFilter-filter-过滤文件（用的比较多）"><a href="#Ⅲ-listFiles-FileFilter-filter-过滤文件（用的比较多）" class="headerlink" title="Ⅲ.listFiles(FileFilter filter) 过滤文件（用的比较多）"></a>Ⅲ.<strong><font color='#d15252'>listFiles(FileFilter filter) </font>过滤文件</strong>（用的比较多）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File[] listFiles(FileFilter filter) </span><br></pre></td></tr></table></figure>

<ul>
<li><p>同样是listFiles，表示方法的重载，传递一个FileFilter类型的参数</p>
</li>
<li><p><font color='#d15252'>FileFilter</font>：由API可知FilleFilter是一个接口，而且没有已知的实现类</p>
<ul>
<li>所以我们要使用它，必须定义一个类，implements是西安接口FileFilter</li>
<li>并且我们需要重写接口中的类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span></span><br><span class="line"><span class="function"><span class="comment">//测试指定文件是否应包含在文件列表中</span></span></span><br><span class="line"><span class="function">dir - 找到该文件的目录。 </span></span><br><span class="line"><span class="function">name - 文件的名称。 </span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/06/bTpwMFlWfIq7GLn.png" alt="image-20210806140719225"></p>
<ul>
<li>pahthname：传过来的参数名</li>
<li>getName()：获取内容</li>
<li>endsWith()：String中的成员方法<ul>
<li><code>endsWith(String suffix)</code></li>
<li>测试此字符串是否以指定的后缀结尾。</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/06/KYSm2TRUZ4gCMJ3.png" alt="image-20210806140740062"></p>
</li>
<li><p>也可以直接通过匿名对象使用</p>
<p><img src="https://i.loli.net/2021/08/06/ly1JWNortYHjh86.png" alt="image-20210806145718867"></p>
</li>
</ul>
<h5 id="Ⅳ-listFiles-FilenameFilter-filter-同样是过滤文件"><a href="#Ⅳ-listFiles-FilenameFilter-filter-同样是过滤文件" class="headerlink" title="Ⅳ.listFiles(FilenameFilter filter)同样是过滤文件"></a>Ⅳ.listFiles(FilenameFilter filter)同样是过滤文件</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles(FilenameFilter filter)</span><br></pre></td></tr></table></figure>

<ul>
<li>返回一个抽象路径名数组，表示由此抽象路径名表示的满足指定过滤器的目录中的文件和目录，同样用方法重载的方法<ul>
<li>返回值类型：File[]</li>
<li>传递参数：FilenameFilter filter</li>
</ul>
</li>
<li><font color='#d15252'>FilenameFilter</font> 同样是一个接口<ul>
<li>成员方法：accept(File dir,String name)</li>
<li>测试指定文件是否应包含在文件列表中</li>
<li>返回boolean类型的值</li>
</ul>
</li>
</ul>
<h3 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h3><h4 id="1-什么是递归"><a href="#1-什么是递归" class="headerlink" title="1.什么是递归"></a>1.什么是递归</h4><ul>
<li>方法自己调用自己就是递归<ul>
<li>要给自己设置出口</li>
<li>构造方法不能使用</li>
<li>不要过多的使用（百万以上最好不要用递归）</li>
</ul>
</li>
</ul>
<h4 id="2-递归练习"><a href="#2-递归练习" class="headerlink" title="2.递归练习"></a>2.递归练习</h4><ul>
<li>遍历文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断如果是目录就继续进入并遍历</span></span><br><span class="line"><span class="keyword">for</span> (File i : files) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i.isDirectory()) &#123;</span><br><span class="line">        find(i);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//保存文件名</span></span><br><span class="line">        String name = i.getName();</span><br><span class="line">        <span class="comment">//判断文件后缀是不是.mp4文件</span></span><br><span class="line">        <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;.mp4&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>File</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Java概述和变量</title>
    <url>/2021/08/25/Java%E6%A6%82%E8%BF%B0%E5%92%8C%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h3 id="Java"><a href="#Java" class="headerlink" title="Java!"></a>Java!</h3><ul>
<li><h4 id="什么是Java？"><a href="#什么是Java？" class="headerlink" title="什么是Java？"></a>什么是Java？</h4><ul>
<li>编程语言</li>
<li>开发平台（JVM）</li>
</ul>
</li>
</ul>
<h3 id="一、编程语言"><a href="#一、编程语言" class="headerlink" title="一、编程语言"></a>一、编程语言</h3><ul>
<li><h4 id="布置平台"><a href="#布置平台" class="headerlink" title="布置平台"></a>布置平台</h4><ul>
<li>官方文档解释：JavaSE是Java平台标准版<ul>
<li>JDK</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK"></a>下载JDK</h4></li>
<li><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><ul>
<li>开发工具</li>
<li>源代码</li>
<li>JRE：JDK包含JRE</li>
</ul>
</li>
<li><h4 id="使用JDK"><a href="#使用JDK" class="headerlink" title="使用JDK"></a>使用JDK</h4><ul>
<li><p>JDK安装目录bin文件夹下</p>
</li>
<li><p>[^javac.exe]: 编译</p>
</li>
<li><p>[^java.exe]: 运行</p>
</li>
</ul>
</li>
<li><p>配置环境变量</p>
<ul>
<li>官网添加JDK路径到系统Path变量</li>
<li>动态获取%JAVA_HOME%</li>
</ul>
</li>
</ul>
<h3 id="二、编程语言"><a href="#二、编程语言" class="headerlink" title="二、编程语言"></a>二、编程语言</h3><ul>
<li><p>基本单位</p>
<ul>
<li>class 类</li>
</ul>
</li>
<li><p>最简单的java程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类名要与文件名一致，后缀为.class</li>
</ul>
</li>
<li><p>main方法是程序的入口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="三、学习Java"><a href="#三、学习Java" class="headerlink" title="三、学习Java"></a>三、学习Java</h3><ul>
<li>java语言的核心本质是对数据的操作</li>
<li>数据的操作最基础的是存数据和取数据</li>
</ul>
<h3 id="四、存取数据"><a href="#四、存取数据" class="headerlink" title="四、存取数据"></a>四、存取数据</h3><ul>
<li><p>变量</p>
<ul>
<li><p>一个可以变化的量</p>
<ul>
<li>本质：存储一个数据</li>
</ul>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型 变量名 = 数值 ；</span><br></pre></td></tr></table></figure></li>
<li><p>注意事项</p>
<ul>
<li>使用变量时需要注意变量有没有数据<ul>
<li>没有数据时，可以完成赋值操作</li>
<li>但是不能完成取值操</li>
</ul>
</li>
<li>变量在{ }内有效，且不能定义同名变量（作用域）</li>
<li>{ } ：代码块，独立存在，运行结束后立即释放，提高内存使用率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="五、Java的数据类型"><a href="#五、Java的数据类型" class="headerlink" title="五、Java的数据类型"></a>五、Java的数据类型</h3><ul>
<li>每一个数据类型的存储范围都不一样，为了提高内存的使用率</li>
</ul>
<h4 id="1-整数"><a href="#1-整数" class="headerlink" title="1.整数"></a>1.整数</h4><table>
<thead>
<tr>
<th align="left">整数</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td>8bit</td>
</tr>
<tr>
<td align="left">short</td>
<td>16bit</td>
</tr>
<tr>
<td align="left"><strong>int(默认)</strong></td>
<td>32bit</td>
</tr>
<tr>
<td align="left">long</td>
<td>64bit</td>
</tr>
</tbody></table>
<ul>
<li>在Java中，出现的所有整数，默认都是int类型</li>
<li>byte在存整数时，如果int类型整数在byte范围内，byte会自动完成转换 int—byte</li>
</ul>
<h4 id="2-小数"><a href="#2-小数" class="headerlink" title="2.小数"></a>2.小数</h4><table>
<thead>
<tr>
<th>小数</th>
<th>长度</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>浮点型 32bit</td>
</tr>
<tr>
<td><strong>double(默认)</strong></td>
<td>双精度 64bit</td>
</tr>
</tbody></table>
<ul>
<li>长整型long后缀使用L标记，表明是长整型</li>
<li>单精度float后缀使用F标记，表名是单精度</li>
</ul>
<h4 id="3-布尔类型"><a href="#3-布尔类型" class="headerlink" title="3.布尔类型"></a>3.布尔类型</h4><ul>
<li>ture</li>
<li>false</li>
</ul>
<h3 id="六、变量补充知识点"><a href="#六、变量补充知识点" class="headerlink" title="六、变量补充知识点"></a>六、变量补充知识点</h3><ul>
<li><p>两个整数相除，得到的是整数部分</p>
</li>
<li><p>数据类型之间的转换</p>
<ul>
<li><p>隐式转换（小的自动转大）</p>
</li>
<li><p>强制转换（大转小）</p>
<ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目标类型 变量名 = （目标类型）被转换数据</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="七、进制"><a href="#七、进制" class="headerlink" title="七、进制"></a>七、进制</h3><h4 id="1-什么是进制？"><a href="#1-什么是进制？" class="headerlink" title="1.什么是进制？"></a>1.什么是进制？</h4><ul>
<li>逢几进一</li>
</ul>
<h4 id="2-Java常见的进制"><a href="#2-Java常见的进制" class="headerlink" title="2.Java常见的进制"></a>2.Java常见的进制</h4><ul>
<li>二进制：0b</li>
<li>八进制：0</li>
<li>十进制：默认</li>
<li>十六进制：0x</li>
</ul>
<h4 id="3-进制间的转换"><a href="#3-进制间的转换" class="headerlink" title="3.进制间的转换"></a>3.进制间的转换</h4><ul>
<li><p>任意进制到十进制</p>
<ul>
<li><p>系数 * 基数的权次幂相加</p>
<ul>
<li>系数：位数是几</li>
<li>基数：原来的进制</li>
<li>权：从个位开始，从0向左依次增加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">x * y^z</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>十进制到任意进制</p>
<ul>
<li>除以基数，倒取余数</li>
</ul>
</li>
<li><p>二进制 &lt;==&gt;八进制</p>
<ul>
<li>421码</li>
</ul>
</li>
<li><p>二进制 &lt;==&gt; 十六进制</p>
<ul>
<li>8421码</li>
</ul>
</li>
</ul>
<h4 id="4-源码、反码、补码"><a href="#4-源码、反码、补码" class="headerlink" title="4.源码、反码、补码"></a>4.源码、反码、补码</h4><ul>
<li>在计算机中，二进制的运算，是以补码的形式进行的(0为正，1为负)</li>
</ul>
<ul>
<li><p>正数：源码 = 反码 = 补码</p>
</li>
<li><p>负数：源码不变</p>
<p>​            反码：符号位不变，其余按位取反</p>
<p>​            补码：反码+1</p>
</li>
</ul>
<h3 id="八、运算符"><a href="#八、运算符" class="headerlink" title="八、运算符"></a>八、运算符</h3><h4 id="1-什么是运算符"><a href="#1-什么是运算符" class="headerlink" title="1.什么是运算符"></a>1.什么是运算符</h4><ul>
<li>运算符是对一个、两个或三个操作数执行特定操作，然后返回结果的特殊符号。</li>
</ul>
<h4 id="2-运算符的分类"><a href="#2-运算符的分类" class="headerlink" title="2.运算符的分类"></a>2.运算符的分类</h4><h5 id="①算数运算符"><a href="#①算数运算符" class="headerlink" title="①算数运算符"></a>①算数运算符</h5><table>
<thead>
<tr>
<th>算数运算符</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>+ 、 -</td>
<td>加、减</td>
</tr>
<tr>
<td>* 、/</td>
<td>乘、除</td>
</tr>
<tr>
<td>%</td>
<td>取模（即取余）</td>
</tr>
</tbody></table>
<h5 id="②一元运算符"><a href="#②一元运算符" class="headerlink" title="②一元运算符"></a>②一元运算符</h5><ul>
<li>只需要一个操作数，就可以对其进行相应的操作</li>
</ul>
<table>
<thead>
<tr>
<th>一元运算符</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>表示正值（可省略）</td>
</tr>
<tr>
<td>-</td>
<td>表示负值，即否定表达式</td>
</tr>
<tr>
<td>++</td>
<td>将值+1</td>
</tr>
<tr>
<td>–</td>
<td>将值-1</td>
</tr>
<tr>
<td>!</td>
<td>反转布尔值</td>
</tr>
</tbody></table>
<p><img src="https://i.loli.net/2021/07/19/UKrzgyR9e5xWNfj.png" alt="image-20210719160154418"></p>
<blockquote>
<p>a++;        ++b;</p>
<ul>
<li>单独使用时，++即自加一，–即自减一，放在前后效果相同</li>
</ul>
<p>int b = a ++;    int c = –b;</p>
<ul>
<li>参与运算时，放在前即先++或–， 放在后面则先运算再++、–</li>
</ul>
</blockquote>
<h5 id="③比较运算符"><a href="#③比较运算符" class="headerlink" title="③比较运算符"></a>③比较运算符</h5><ul>
<li>返回布尔类型的值，即true，false</li>
</ul>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
</tbody></table>
<h5 id="④条件运算符"><a href="#④条件运算符" class="headerlink" title="④条件运算符"></a>④条件运算符</h5><ul>
<li>用来连接比较表达式（即布尔类型）表达式</li>
</ul>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;   AND(与)</td>
<td>有false则false，两个true则true</td>
</tr>
<tr>
<td>|    OR(或)</td>
<td>有true则true，两个false则false</td>
</tr>
<tr>
<td>^    XOR(异或)</td>
<td>相同false，不同true</td>
</tr>
<tr>
<td>!     NOT(非)</td>
<td>结论相反</td>
</tr>
<tr>
<td>&amp;&amp;  AND(短路)</td>
<td>短路效果，即左边有false，右边不执行</td>
</tr>
<tr>
<td>||   OR(短路)</td>
<td>短路效果，即左边有true，右边不执行</td>
</tr>
</tbody></table>
<blockquote>
<p>Java中，若要表达3&lt;x&lt;6 ，应写为 x&gt;3 &amp; x&lt;6</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>什么是Java</tag>
        <tag>变量</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java链接数据库</title>
    <url>/2021/08/25/Java%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="一、Java链接数据库（Mysql）步骤"><a href="#一、Java链接数据库（Mysql）步骤" class="headerlink" title="一、Java链接数据库（Mysql）步骤"></a>一、Java链接数据库（Mysql）步骤</h3><h4 id="1-第一步：创建项目，并进行测试"><a href="#1-第一步：创建项目，并进行测试" class="headerlink" title="1.第一步：创建项目，并进行测试"></a>1.第一步：创建项目，并进行测试</h4><h4 id="2-第二步：找公司（jar）压缩包-jar"><a href="#2-第二步：找公司（jar）压缩包-jar" class="headerlink" title="2.第二步：找公司（jar）压缩包.jar"></a>2.第二步：找公司（jar）压缩包.jar</h4><ul>
<li>项目中创建lib目录，将jar包拖入<ul>
<li><img src="https://i.loli.net/2021/07/09/dXBtUWDkVezPFoQ.png" alt="image-20210709092306325"></li>
</ul>
</li>
<li>右键jar包，解压<ul>
<li><img src="https://i.loli.net/2021/07/09/r4peszySgwOJHYV.png" alt="image-20210709092237690"></li>
</ul>
</li>
</ul>
<h4 id="3-第三步：将Java链接mysql的相关工具类加载进内存"><a href="#3-第三步：将Java链接mysql的相关工具类加载进内存" class="headerlink" title="3.第三步：将Java链接mysql的相关工具类加载进内存"></a>3.第三步：将Java链接mysql的相关工具类加载进内存</h4><ul>
<li><p>用try{}catch(Exception e){} 或 throws Exception 处理异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-第四步：Java链接Mysql"><a href="#4-第四步：Java链接Mysql" class="headerlink" title="4.第四步：Java链接Mysql"></a>4.第四步：Java链接Mysql</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Connection root = DriverManager.getConnection(url:<span class="string">&quot;jdbc:mysql://localhost:3306/m1&quot;</span>,</span><br><span class="line">            user:<span class="string">&quot;root&quot;</span>,</span><br><span class="line">            password:<span class="string">&quot;000909&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>去除时区异常：</p>
<p>?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=true</p>
</blockquote>
<h4 id="5-第五步：获取发送sql的工具"><a href="#5-第五步：获取发送sql的工具" class="headerlink" title="5.第五步：获取发送sql的工具"></a>5.第五步：获取发送sql的工具</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Statement statement = root.createStatement();</span><br></pre></td></tr></table></figure>



<h4 id="6-第六步：定义一个sql语句-查询"><a href="#6-第六步：定义一个sql语句-查询" class="headerlink" title="6.第六步：定义一个sql语句(查询)"></a>6.第六步：定义一个sql语句(查询)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">&quot;SELECT *FROM shop&quot;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-第七步：发送sql语句-查询-，用resultSet保存返回值"><a href="#7-第七步：发送sql语句-查询-，用resultSet保存返回值" class="headerlink" title="7.第七步：发送sql语句(查询)，用resultSet保存返回值"></a>7.第七步：发送sql语句(查询)，用resultSet保存返回值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResultSet resultSet = statement.executeQuery(sql);</span><br></pre></td></tr></table></figure>

<h4 id="8-第八步：调用resuleSet的next-方法，判断是否有值"><a href="#8-第八步：调用resuleSet的next-方法，判断是否有值" class="headerlink" title="8.第八步：调用resuleSet的next()方法，判断是否有值"></a>8.第八步：调用resuleSet的next()方法，判断是否有值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (resultSet.next())</span><br></pre></td></tr></table></figure>



<h4 id="9-第九步：调用getInt-方法，返回int类型值"><a href="#9-第九步：调用getInt-方法，返回int类型值" class="headerlink" title="9.第九步：调用getInt()方法，返回int类型值"></a>9.第九步：调用getInt()方法，返回int类型值</h4><ul>
<li><img src="https://i.loli.net/2021/07/09/GLfpqFbu4Qg3Cx1.png" alt="image-20210709103344911"></li>
</ul>
<hr>
<h4 id="链接数据库并查询—代码："><a href="#链接数据库并查询—代码：" class="headerlink" title="链接数据库并查询—代码："></a>链接数据库并查询—代码：</h4><p><img src="https://i.loli.net/2021/07/09/m9Q42OWGNr7Io3v.png" alt="image-20210709103439844"></p>
<hr>
<h3 id="二、更新数据库数据"><a href="#二、更新数据库数据" class="headerlink" title="二、更新数据库数据"></a>二、更新数据库数据</h3><ul>
<li><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ul>
<li><p>链接mysql数据库、try解决异常、获取链接（通道）、获取发送sql语句工具类</p>
</li>
<li><p>创建键盘录入数据</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">           System.out.println(<span class="string">&quot;请输入要修改的学号&quot;</span>);</span><br><span class="line">           <span class="keyword">int</span> id = sc.nextInt();</span><br><span class="line">           System.out.println(<span class="string">&quot;请输入要修改的姓名&quot;</span>);</span><br><span class="line">           String name = sc.next();</span><br></pre></td></tr></table></figure>

<ul>
<li>打包sql语句</li>
</ul>
<p><code>String sql = &quot;UPDATE student SET sname = &#39;&quot;+name+&quot;&#39; WHERE sid = &quot;+id;</code></p>
<ul>
<li>发送执行sql语句</li>
</ul>
<p><code>int i = statement.executeUpdate(sql);</code></p>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5></li>
</ul>
<p><img src="https://i.loli.net/2021/06/30/fFMH28bBwjXsoSz.png" alt="image-20210630143254189"></p>
<hr>
<h3 id="三、添加数据库数据"><a href="#三、添加数据库数据" class="headerlink" title="三、添加数据库数据"></a>三、添加数据库数据</h3><ul>
<li><h5 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h5><ul>
<li><p>链接mysql数据库、try解决异常、获取链接（通道）、获取发送sql语句工具类</p>
</li>
<li><p>创建键盘录入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">         System.out.println(<span class="string">&quot;请输入要添加的id&quot;</span>);</span><br><span class="line">         <span class="keyword">int</span> id = sc.nextInt();</span><br><span class="line">         System.out.println(<span class="string">&quot;请输入要添加的姓名&quot;</span>);</span><br><span class="line">         String name  = sc.next();</span><br></pre></td></tr></table></figure></li>
<li><p>打包sql语句</p>
<p>[^sql语句]: <code>String sql = &quot;INSERT INTO student (sid,sname) VALUES (&quot;+id+&quot;,&#39;&quot;+name+&quot;&#39;)&quot;;</code></p>
</li>
<li><p>发送执行sql语句</p>
<p><code>int i = statement.executeUpdate(sql);</code></p>
</li>
</ul>
<p>  [^executeUpdate]: 用于添加，更新，删除数据</p>
</li>
<li><h5 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h5><p><img src="https://i.loli.net/2021/06/30/r93VqIyGYm1xtW8.png" alt="image-20210630140131020"></p>
</li>
</ul>
<hr>
<h3 id="四、删除数据库数据"><a href="#四、删除数据库数据" class="headerlink" title="四、删除数据库数据"></a>四、删除数据库数据</h3><ul>
<li><h5 id="步骤：-1"><a href="#步骤：-1" class="headerlink" title="步骤："></a>步骤：</h5><ul>
<li><p>链接mysql数据库、try解决异常、获取链接（通道）、获取发送sql语句工具类</p>
</li>
<li><p>创建键盘录入数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">          System.out.println(<span class="string">&quot;请输入要删除的学号&quot;</span>);</span><br><span class="line">          <span class="keyword">int</span> id = sc.nextInt();</span><br></pre></td></tr></table></figure></li>
<li><p>打包sql语句</p>
<p><code>String sql = &quot;DELETE FROM student WHERE sid = &quot;+id;</code></p>
</li>
<li><p>发送执行sql语句</p>
<p><code>int i = statement.executeUpdate(sql);</code></p>
</li>
</ul>
</li>
<li><h5 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：<img src="https://i.loli.net/2021/06/30/n14xtuQb2wJVsqh.png" alt="image-20210630143508186"></h5></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>增查删改</tag>
        <tag>案例</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/2021/08/25/IO%E6%B5%81/</url>
    <content><![CDATA[<h3 id="一、对文件的操作IO流"><a href="#一、对文件的操作IO流" class="headerlink" title="一、对文件的操作IO流"></a>一、对文件的操作IO流</h3><ul>
<li><font color='#d15252'>IO流</font><ul>
<li>输入输出简称IO</li>
<li>被IO传输的数据，称为流</li>
</ul>
</li>
</ul>
<h4 id="1-IO流的分类"><a href="#1-IO流的分类" class="headerlink" title="1.IO流的分类"></a>1.IO流的分类</h4><h5 id="Ⅰ-按数据的流向（内存）"><a href="#Ⅰ-按数据的流向（内存）" class="headerlink" title="Ⅰ.按数据的流向（内存）"></a>Ⅰ.按数据的流向（内存）</h5><ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
<h5 id="Ⅱ-数据的类型来分"><a href="#Ⅱ-数据的类型来分" class="headerlink" title="Ⅱ.数据的类型来分"></a>Ⅱ.数据的类型来分</h5><ul>
<li><p>字节流</p>
<ul>
<li>字节输入流 InputStream</li>
<li>字节输出流 OutputStream</li>
</ul>
</li>
<li><p>字符流</p>
<ul>
<li>字符输入流 Reader</li>
<li>字符输出流 Writer</li>
</ul>
</li>
</ul>
<h3 id="二、字节输入流—InputStream"><a href="#二、字节输入流—InputStream" class="headerlink" title="二、字节输入流—InputStream"></a>二、字节输入流—InputStream</h3><h4 id="1-概述："><a href="#1-概述：" class="headerlink" title="1.概述："></a>1.概述：</h4><ul>
<li><p>抽象类</p>
</li>
<li><p>是表示输入字节流的所有类的超类</p>
<ul>
<li>要想使用它的功能，需要通过子类实例化</li>
<li>有很多已知子类FileInputStream</li>
</ul>
<p><img src="https://i.loli.net/2021/08/09/L2hslSWfBHC34uo.png" alt="image-20210809093421685"></p>
</li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-read-读取数据"><a href="#Ⅰ-read-读取数据" class="headerlink" title="Ⅰ. read()读取数据"></a>Ⅰ. read()读取数据</h5><ul>
<li><p>返回值Int类型</p>
<ul>
<li>如果想要字符类型，强转为char</li>
</ul>
<p><img src="https://i.loli.net/2021/08/09/K3z2G5PW6inxkfO.png" alt="image-20210809094358422"></p>
</li>
<li><p>读取一个字节的数据</p>
</li>
<li><p>如果到达文件末尾，返回-1</p>
</li>
<li><p>while循环实现读取文件所有数据</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/09/fQzuEbxBjpcNR97.png" alt="image-20210809095444628"></p>
<h5 id="Ⅱ-read-byte-b"><a href="#Ⅱ-read-byte-b" class="headerlink" title="Ⅱ. read(byte[] b)"></a>Ⅱ. read(byte[] b)</h5><ul>
<li>从该输入流读取最多 <code>b.length</code>个字节的数据到一个字节数组。 </li>
<li>如果到达文件末尾，返回-1</li>
<li>直接输出read(buff)返回的是数据个数</li>
</ul>
<h5 id="Ⅲ-close-关闭流，先刷新"><a href="#Ⅲ-close-关闭流，先刷新" class="headerlink" title="Ⅲ.close()关闭流，先刷新"></a>Ⅲ.close()关闭流，先刷新</h5><h3 id="三、字节输出流—OutputStream"><a href="#三、字节输出流—OutputStream" class="headerlink" title="三、字节输出流—OutputStream"></a>三、字节输出流—OutputStream</h3><ul>
<li>写入操作，传递的参数都是<font color='#d15252'>ASCII码类型</font>的数据</li>
</ul>
<h4 id="1-概述-："><a href="#1-概述-：" class="headerlink" title="1.概述 ："></a>1.概述 ：</h4><ul>
<li><p>抽象类</p>
<ul>
<li><p>通过子类实例化</p>
</li>
<li><p>已知子类FileOutputStream</p>
</li>
<li><p>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream(File file) 创建文件输出流以写入由指定的 File对象表示的文件</span><br><span class="line">    <span class="comment">//写入操作会覆盖原有文件内数据</span></span><br><span class="line">    </span><br><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append)创建文件输出流以写入由指定的 File对象表示的文件 </span><br><span class="line">    <span class="comment">//如果第二个参数为true ，则字节将写入文件的末尾而不是开头</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果使用第一种构造方法，每次写入都会覆盖之前的内容</p>
</li>
<li><p>如果使用第二种构造方法，传递参数true，则写入不会覆盖，而是在后面追加</p>
</li>
</ul>
</li>
<li><p>这个抽象类是表示字节输出流的所有类的超类</p>
</li>
<li><p>输出流接收输出字节并将其发送到某个接收器</p>
</li>
</ul>
<h4 id="2-成员方法："><a href="#2-成员方法：" class="headerlink" title="2.成员方法："></a>2.成员方法：</h4><h5 id="Ⅰ-write-int-b"><a href="#Ⅰ-write-int-b" class="headerlink" title="Ⅰ. write(int b)"></a>Ⅰ. write(int b)</h5><ul>
<li>将指定的字节写入此文件输出流</li>
<li>返回值类型void，无返回值</li>
<li>需要处理异常</li>
</ul>
<p><img src="https://i.loli.net/2021/08/09/NSiQ5bY9T4O71fL.png" alt="image-20210809111621616"></p>
<h5 id="Ⅱ-write-byte-b"><a href="#Ⅱ-write-byte-b" class="headerlink" title="Ⅱ. write(byte[] b)"></a>Ⅱ. write(byte[] b)</h5><ul>
<li>将 <code>b.length</code>字节从指定的字节数组写入此文件输出流。 </li>
<li>void无返回值类型</li>
</ul>
<h4 id="3-练习：文件复制粘贴"><a href="#3-练习：文件复制粘贴" class="headerlink" title="3.练习：文件复制粘贴"></a>3.练习：文件复制粘贴</h4><p><img src="https://i.loli.net/2021/08/09/zuyRcKGm3ThYv59.png" alt="image-20210809145503527"></p>
<h3 id="字符编码表"><a href="#字符编码表" class="headerlink" title="字符编码表"></a>字符编码表</h3><h4 id="1-ASCII"><a href="#1-ASCII" class="headerlink" title="1.ASCII"></a>1.ASCII</h4><ul>
<li><p>一个字节中7位就可以表示，对应的字节都是整数</p>
<ul>
<li>0-XXXXXXx</li>
</ul>
<p><img src="https://i.loli.net/2021/08/09/owug8H42manfPUE.png" alt="image-20210809100527848"></p>
</li>
</ul>
<h4 id="2-isi-8859-1"><a href="#2-isi-8859-1" class="headerlink" title="2.isi-8859-1"></a>2.isi-8859-1</h4><ul>
<li>拉丁码表latin。用一个字节数的8位来表<ul>
<li>1-XXXXXX（可以负数）</li>
</ul>
</li>
</ul>
<h4 id="3-GB2312"><a href="#3-GB2312" class="headerlink" title="3.GB2312"></a>3.GB2312</h4><ul>
<li>简体中文码表。包含的是6000-7000中文和符号，用两个字节表示<ul>
<li>其中一部分字节开头1，0</li>
</ul>
</li>
</ul>
<h4 id="4-GBK"><a href="#4-GBK" class="headerlink" title="4.GBK"></a>4.GBK</h4><ul>
<li>目前最常用的中文码表，2万个中和字符，用两个字节表示</li>
</ul>
<h4 id="5-Unicode"><a href="#5-Unicode" class="headerlink" title="5.Unicode"></a>5.Unicode</h4><ul>
<li>国际标准码，无论哪种文字，都用两个字节表示</li>
</ul>
<h4 id="6-UTF-8"><a href="#6-UTF-8" class="headerlink" title="6.UTF-8"></a>6.UTF-8</h4><ul>
<li>基于unicode，一个字节就可以存储数据，更加标准化，目前应用最广</li>
</ul>
<h4 id="能识别中文的码表：GBK，UTF-8"><a href="#能识别中文的码表：GBK，UTF-8" class="headerlink" title="能识别中文的码表：GBK，UTF-8"></a>能识别中文的码表：GBK，UTF-8</h4><ul>
<li>编码：数据—&gt;十进制</li>
<li>解码：十进制—&gt;数据</li>
</ul>
<h3 id="五、字符输入流Reader"><a href="#五、字符输入流Reader" class="headerlink" title="五、字符输入流Reader"></a>五、字符输入流Reader</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>抽象类</p>
<ul>
<li><p>已知实现子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader ， CharArrayReader ， FilterReader ， InputStreamReader ， PipedReader ， StringReader ， URLReader </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>子类必须实现的唯一方法read和close</p>
</li>
<li><p>常量</p>
<ul>
<li>Object lock 用于同步此流上的操作的对象</li>
</ul>
</li>
<li><p>不管代码是否出现异常，流通道一旦打开就需要关闭</p>
<ul>
<li>通过final关流</li>
</ul>
</li>
<li><p>平台默认编码格式</p>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="title">Reader</span><span class="params">()</span> 创建一个新的字符流阅读器，其关键部分将在阅读器本身上同步。  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="title">Reader</span><span class="params">(Object lock)</span> 创建一个新的字符流阅读器，其关键部分将在给定对象上同步。  </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><h5 id="Ⅰ-read-读一个字符"><a href="#Ⅰ-read-读一个字符" class="headerlink" title="Ⅰ.read() 读一个字符"></a>Ⅰ.read() 读一个字符</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Reader r = <span class="keyword">new</span> FileReader(<span class="string">&quot;H:\\瑞通java\\第六周\\Day1\\a.txt&quot;</span>);</span><br><span class="line">       System.out.println(r.read());   <span class="comment">//调用read方法，直接返回的是第一个字符的ASCLL码\</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值int类型，是ASCII码</li>
</ul>
<h5 id="Ⅱ-read-char-cbuf-将字符读入数组"><a href="#Ⅱ-read-char-cbuf-将字符读入数组" class="headerlink" title="Ⅱ.read(char[] cbuf) 将字符读入数组"></a>Ⅱ.read(char[] cbuf) 将字符读入数组</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">     <span class="comment">//创建char数组</span></span><br><span class="line">     <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//  System.out.println(r.read(arr));直接输出得到数据长度</span></span><br><span class="line">       <span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>((a=r.read(arr))!=-<span class="number">1</span>)&#123;</span><br><span class="line">          System.out.println(<span class="keyword">new</span> String(arr,<span class="number">0</span>,a));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//输出abcabcd</span></span><br></pre></td></tr></table></figure>





<h4 id="4-已知实现子类FileReader"><a href="#4-已知实现子类FileReader" class="headerlink" title="4.已知实现子类FileReader"></a>4.已知实现子类FileReader</h4><ul>
<li><p>构造方法</p>
<p><img src="https://i.loli.net/2021/08/09/JEez4RglGXYot8v.png" alt="image-20210809162653985"></p>
</li>
<li><p><img src="https://i.loli.net/2021/08/09/KzcWFLJmxIDwX8j.png" alt="image-20210809162701581"></p>
</li>
<li><p>继承体系</p>
<p><img src="https://i.loli.net/2021/08/10/ayLneKBhlFmp4Xi.png" alt="image-20210810100121551"></p>
</li>
<li><p>编码和解码时 格式需一样 UTF-8</p>
</li>
</ul>
<h3 id="六、字符输出流Writer"><a href="#六、字符输出流Writer" class="headerlink" title="六、字符输出流Writer"></a>六、字符输出流Writer</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>抽象类</p>
<ul>
<li><p>已知实现子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedWriter ， CharArrayWriter ， FilterWriter ， OutputStreamWriter ， PipedWriter ， PrintWriter ， StringWriter </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常量</p>
<ul>
<li><code>lock</code> 用于同步此流上的操作对象</li>
</ul>
</li>
<li><p>平台默认编码格式</p>
</li>
<li><p>在操作完成后需要使用  flush/close</p>
<ul>
<li>刷新或关流</li>
</ul>
</li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="title">Writer</span><span class="params">()</span> 创建一个新的人物流作家，其关键部分将在作者本身上同步。  </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span>  <span class="title">Writer</span><span class="params">(Object lock)</span> 创建一个新的字符流写入器，其关键部分将在给定对象上进行同步。  </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> 写入一个字符数组。  </span></span><br><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符数组的一部分。  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> 写一个字符  </span></span><br></pre></td></tr></table></figure>



<h4 id="4-已知实现子类FileWriter"><a href="#4-已知实现子类FileWriter" class="headerlink" title="4.已知实现子类FileWriter"></a>4.已知实现子类FileWriter</h4><h5 id="Ⅰ-构造方法"><a href="#Ⅰ-构造方法" class="headerlink" title="Ⅰ.构造方法"></a>Ⅰ.构造方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWriter​(File file) 给一个File对象构造一个FileWriter对象。  </span><br><span class="line">FileWriter​(FileDescriptor fd) 构造与文件描述符关联的FileWriter对象。  </span><br><span class="line">FileWriter​(File file, <span class="keyword">boolean</span> append) 给一个File对象构造一个FileWriter对象。  </span><br><span class="line">FileWriter​(String fileName) 构造一个给定文件名的FileWriter对象。  </span><br><span class="line">FileWriter​(String fileName, <span class="keyword">boolean</span> append) 构造一个FileWriter对象，给出一个带有布尔值的文件名，表示是否附加写入的数据。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="Ⅱ-成员方法"><a href="#Ⅱ-成员方法" class="headerlink" title="Ⅱ.成员方法"></a>Ⅱ.成员方法</h5><p><img src="https://i.loli.net/2021/08/10/FRTDgByn9M5Xqdw.png" alt="image-20210810103320925"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2021/08/24/XML/</url>
    <content><![CDATA[<h3 id="一、XML文件-JavaEE"><a href="#一、XML文件-JavaEE" class="headerlink" title="一、XML文件(JavaEE)"></a>一、XML文件(JavaEE)</h3><ul>
<li>存储数据的语言<ul>
<li>Extensible：扩展</li>
<li>Marup：标记</li>
<li>Language：语言</li>
</ul>
</li>
</ul>
<h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul>
<li>作用<ul>
<li>存储数据</li>
<li>传输数据</li>
</ul>
</li>
<li>优点<ul>
<li>可读性好</li>
<li>维护性好</li>
</ul>
</li>
</ul>
<h3 id="二、XML语言的语法"><a href="#二、XML语言的语法" class="headerlink" title="二、XML语言的语法"></a>二、XML语言的语法</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><h5 id="xml语法规范"><a href="#xml语法规范" class="headerlink" title="xml语法规范"></a>xml语法规范</h5><ul>
<li>区分大小写</li>
<li>必须正确的嵌套</li>
<li>必须有根元素</li>
<li>属性值必须加引号</li>
</ul>
<p>例：让XML文件保存Person</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span> &lt;--&gt;Person根元素&lt;/--&gt;</span><br><span class="line">	<span class="tag">&lt;<span class="name">p1</span>&gt;</span>	&lt;--&gt;Person对象&lt;/--&gt;</span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>它是一个标签语言<ul>
<li>标签是成对出现的</li>
</ul>
</li>
</ul>
<h5 id="标签语言"><a href="#标签语言" class="headerlink" title="标签语言"></a>标签语言</h5><ul>
<li>在标签语言中&lt;&gt;中只有一个单词，称为元素标签</li>
<li>在标签语言中 &lt;单词&gt; 在单词后跟的所有的单词，都被称为<font color='#d15252'>属性标签</font>，它可以赋值</li>
</ul>
<h4 id="2-XML声明"><a href="#2-XML声明" class="headerlink" title="2.XML声明"></a>2.XML声明</h4><p><img src="https://i.loli.net/2021/08/18/IdGKFNVAcg672ej.png" alt="image-20210818113055208"></p>
<ul>
<li> version ：版本</li>
<li> encoding：编码格式</li>
<li> standalone：该xml文件是否依赖与其他文件</li>
</ul>
<h5 id="文档声明的注意细节"><a href="#文档声明的注意细节" class="headerlink" title="文档声明的注意细节"></a>文档声明的注意细节</h5><ul>
<li>文档声明<font color='#d15252'>必须在第一行</font></li>
<li>?和xml之间不能有空格</li>
</ul>
<h4 id="3-xml中的大于小于"><a href="#3-xml中的大于小于" class="headerlink" title="3.xml中的大于小于"></a>3.xml中的大于小于</h4><p><img src="https://i.loli.net/2021/08/18/NlnKJZ9XGLR4q7j.png" alt="image-20210818113155510"></p>
<h3 id="三、XML的数据传输：解析XML"><a href="#三、XML的数据传输：解析XML" class="headerlink" title="三、XML的数据传输：解析XML"></a>三、XML的数据传输：解析XML</h3><p><img src="https://i.loli.net/2021/08/18/UOj5b1paegVQFEW.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/08/18/tQj5FU92Cxu3dAm.png" alt="image-20210818114104225"></p>
<ul>
<li><p>浏览器用<font color='#d15252'>Document</font>将整个xml封装起来</p>
</li>
<li><p>Java中解析XML已经由第三方做好了</p>
<ul>
<li>dom4j</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/BKcnLWeg1sfrQJS.png" alt="image-20210818114827519"></p>
</li>
<li><p>下载步骤</p>
<ul>
<li>下载后缀为.zip的文件解压</li>
<li>后缀为.jar的文件就是我们要使用的</li>
<li><font color='#d15252'>docs</font>文件夹中，是官网文档<ul>
<li>找到index.html</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-Java中解析xml的步骤"><a href="#1-Java中解析xml的步骤" class="headerlink" title="1.Java中解析xml的步骤"></a>1.Java中解析xml的步骤</h4><ul>
<li>第一步：导包并解压</li>
<li>第二步：创建SAXReader对象 — 解析器</li>
<li>第三步：使用getResource获取路径</li>
<li>第四步： 读取文档，解析器调用read方法读取文档，并用Document保存</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/8FfTupCy2Pb1cRq.png" alt="image-20210818134337840"></p>
<ul>
<li>第五步：使用Document中的getRootElement()方法<font color='#d15252'>解析根目录</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/6iWrgmXChHwEyeP.png" alt="image-20210818134841873"></p>
<ul>
<li>第六步：使用Document中的elements()方法获取每一个元素<ul>
<li>并存入List集合，注意泛型</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/FE1cGXgaeLMyHTf.png" alt="image-20210818150624257"></p>
<ul>
<li>第七步：遍历List集合中的元素，拿到每一个元素<ul>
<li>同样用元素调用<font color='#d15252'>elements()方法</font>，并带参，获取到<font color='#d15252'>具体的属性对象</font></li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/Xidj71oTtCWh2ED.png" alt="image-20210818150753561"></p>
<ul>
<li>第八步：用每一个元素调用attribute()方法带参，可以取出所有带指定属性值，用来判断某一个具体的元素</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/P18xnRg2aoQDvOh.png" alt="image-20210818151242119"></p>
<ul>
<li>第九步：用获取到的具体对象，调用<font color='#d15252'>getText()</font>方法，获取<font color='#d15252'>具体的值</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/sj1SDUBed3C8zXh.png" alt="image-20210818150854734"></p>
<hr>
<h4 id="2-解析XML的方法"><a href="#2-解析XML的方法" class="headerlink" title="2.解析XML的方法"></a>2.解析XML的方法</h4><h5 id="Ⅰ-getRootElement（）"><a href="#Ⅰ-getRootElement（）" class="headerlink" title="Ⅰ. getRootElement（）"></a>Ⅰ. getRootElement（）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getRootElement（）<span class="comment">//解析根目录</span></span><br></pre></td></tr></table></figure>

<ul>
<li>document调用，获取根目录</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/RO2HjFenNQvaZwI.png" alt="image-20210818143500082"></p>
<h5 id="Ⅱ-getResource"><a href="#Ⅱ-getResource" class="headerlink" title="Ⅱ. getResource()"></a>Ⅱ. getResource()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getResource() <span class="comment">//获取目录路径</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/24/nJoPVXRwTYAq4Fj.png" alt="image-20210818143533544"></p>
<h5 id="Ⅲ-elements"><a href="#Ⅲ-elements" class="headerlink" title="Ⅲ. elements()"></a>Ⅲ. elements()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elements() 			<span class="comment">//获取所有元素</span></span><br><span class="line">elements(<span class="string">&quot;标签名&quot;</span>)	  <span class="comment">//获取指定的所有元素</span></span><br><span class="line">element() 			<span class="comment">//获取单个的元素</span></span><br><span class="line">element(String str) <span class="comment">//获取指定元素</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/CfbgayeHFuipVDG.png" alt="image-20210818140157107"></p>
<ul>
<li>获取所有的元素，并存入List数组中，注意给泛型</li>
</ul>
<p><img src="https://i.loli.net/2021/08/18/sbyLZMznv7wV8CU.png" alt="image-20210818141034352"></p>
<ul>
<li>返回值List集合</li>
</ul>
<h5 id="Ⅳ-attribute"><a href="#Ⅳ-attribute" class="headerlink" title="Ⅳ. attribute()"></a>Ⅳ. attribute()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Attribute <span class="title">attribute</span><span class="params">(<span class="string">&quot;str&quot;</span>)</span> <span class="comment">//获取属性为str的元素</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/kExhSnz1X2ag7dG.png" alt="image-20210818141819372"></p>
<p><img src="https://i.loli.net/2021/08/18/LeljzUgWaBcvVPy.png" alt="image-20210818141916131"></p>
<ul>
<li>可以看到，获取了所有属性为id的元素<ul>
<li>如果我们要获取其中一个指定的元素，需要对value值进行判断</li>
</ul>
</li>
<li>如果有其他元素，没有带指定的标签，会返回null</li>
<li>返回值Attribute类型</li>
</ul>
<h5 id="Ⅴ-getValue"><a href="#Ⅴ-getValue" class="headerlink" title="Ⅴ. getValue()"></a>Ⅴ. getValue()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getValue()	<span class="comment">//获得元素的值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/xwHW2MNbTEI7iUm.png" alt="image-20210818142150055"></p>
<p><img src="https://i.loli.net/2021/08/18/ZacsrY3f8pW7ytg.png" alt="image-20210818142339756"></p>
<ul>
<li>Attribute调用，获取元素的值</li>
</ul>
<h5 id="Ⅵ-getText"><a href="#Ⅵ-getText" class="headerlink" title="Ⅵ. getText()"></a>Ⅵ. getText()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getText()	<span class="comment">//取出数据</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/JMG8Y4cLbRmdgTi.png" alt="image-20210818143329102"></p>
<ul>
<li>Element调用</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="https://i.loli.net/2021/08/18/HqatLhTz3EDm9rU.png" alt="image-20210818145833898"></p>
<h4 id="将String类转为Int类型"><a href="#将String类转为Int类型" class="headerlink" title="将String类转为Int类型"></a>将String类转为Int类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer.parseInt(要转换的数据);</span><br></pre></td></tr></table></figure>



<h3 id="四、约束XML文件"><a href="#四、约束XML文件" class="headerlink" title="四、约束XML文件"></a>四、约束XML文件</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul>
<li>用来限定xml文件中使用的标签以及属性</li>
<li>约束分类<ul>
<li>DTD</li>
<li>Schema</li>
</ul>
</li>
</ul>
<h3 id="五、DTD"><a href="#五、DTD" class="headerlink" title="五、DTD"></a>五、DTD</h3><h4 id="编写DTD约束的步骤"><a href="#编写DTD约束的步骤" class="headerlink" title="编写DTD约束的步骤"></a>编写DTD约束的步骤</h4><ul>
<li><p><strong>第一步</strong>：创建一个文件，后缀为.dtd</p>
</li>
<li><p><strong>第二步</strong>：看xml文件中使用了哪些元素</p>
</li>
<li><p><strong>第三步</strong>：判断元素是 简单元素，还是 复杂元素</p>
<ul>
<li>简单元素：只有元素自己</li>
<li>复杂元素：包含嵌套其他元素</li>
</ul>
</li>
<li><p><font color='cornflowerblue'><strong>第四步</strong></font>：创建约束</p>
<ul>
<li><p>```dtd</p>
<!ELEMENT 元素名称 类别>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - 可以定义元素</span><br><span class="line"></span><br><span class="line">  - 简单元素：`<span class="meta">&lt;!ELEMENT 元素名称&gt;</span>`</span><br><span class="line"></span><br><span class="line">    - 可以加()标明数据类型</span><br><span class="line">    - 字符串类型：`<span class="meta">&lt;!ELEMENT <span class="meta-keyword">sid</span>(<span class="meta-keyword">#PCDATA</span>) &gt;</span>`</span><br><span class="line">    - Int类型：`<span class="meta">&lt;!ELEMENT <span class="meta-keyword">sid</span>(<span class="meta-keyword">#PCDATA</span>) &gt;</span>`</span><br><span class="line"></span><br><span class="line">  - 复杂元素：`<span class="meta">&lt;!ELEMENT 元素名称（子元素名称，子元素名称）&gt;</span>`</span><br><span class="line"></span><br><span class="line">    - 如果有多个元素的话，可以用 `,`或 `|`隔开</span><br><span class="line">    - `，`  可以出现多个，标识顺序</span><br><span class="line">    - `|` 只能写一个其中一个元素，不能写多个</span><br><span class="line"></span><br><span class="line">    可选符号</span><br><span class="line"></span><br><span class="line">    - `?`代表零次或者一次</span><br><span class="line">    - `+`一次或者多次</span><br><span class="line">    - `*`代表零次或者多次</span><br><span class="line"></span><br><span class="line">    如果不写，表示出现一次</span><br><span class="line"></span><br><span class="line">- **第五步**：在xml文件中引入约束文件</span><br><span class="line"></span><br><span class="line">  - <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#d15252&#x27;</span>&gt;</span>引入本地<span class="tag">&lt;/<span class="name">font</span>&gt;</span>：</span><br><span class="line"></span><br><span class="line">    ```xml</span><br><span class="line">    <span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&#x27;DTD文件路径&#x27;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/u8SfdJWrDX3joiA.png" alt="image-20210818162615097"></p>
</li>
<li><p>在xml文件内部引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称[dtd文件内容]&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/18/qQPRY9ZOFemnSu6.png" alt="image-20210818162644301"></p>
</li>
<li><p>引入网络DTD</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 根元素名称 <span class="meta-keyword">PUBLIC</span><span class="meta-string">&quot;DTD文件名称&quot;</span><span class="meta-string">&quot;DTD文档url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>第六步</strong>：定义属性的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!ATTLIST 元素名称 属性名称 属性类型 类型&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h4><p><img src="https://i.loli.net/2021/08/18/YMsSDquvyfdVNC6.png" alt="image-20210818165443886"></p>
<h3 id="六、Schema"><a href="#六、Schema" class="headerlink" title="六、Schema"></a>六、Schema</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ul>
<li>schema和dtd的区别<ul>
<li>schema的后缀是.xsd</li>
</ul>
</li>
<li>一个XML文件中可以引入多个schema约束文件<ul>
<li>多个schema之间使用名称空间来区分</li>
</ul>
</li>
<li>dtd元素取值比较单一，最常见的是PCDATA类型<ul>
<li>而Schema中，支持多个数据类型</li>
</ul>
</li>
<li>语法更加复杂</li>
</ul>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul>
<li><p>文档声明和根元素</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">schema</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>给文件内容起名字</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">targetNamespace=&quot;http://www.easthome.com/javase<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>声明文档的质量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">elementFormDefault=&quot;qualified&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/19/Kq7let8SWpPih3B.png" alt="image-20210819091908874"></p>
</li>
</ul>
<h4 id="2-Schema中的内容"><a href="#2-Schema中的内容" class="headerlink" title="2.Schema中的内容"></a>2.Schema中的内容</h4><p><code>&lt;element name=&quot;Student&quot;&gt;</code> 根标签</p>
<ul>
<li><code>&lt;complexType&gt;</code>复杂标签<ul>
<li><code>&lt;sequence&gt;</code>顺序标签<ul>
<li><code>&lt;element name=&quot;s1&quot;&gt;</code> 定义元素标签</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/h6gC4foXUNyqct3.png" alt="image-20210819092948914"></p>
<h4 id="3-Schema中的引入"><a href="#3-Schema中的引入" class="headerlink" title="3.Schema中的引入"></a>3.Schema中的引入</h4><ul>
<li><p>在根元素中引入xsd文件</p>
</li>
<li><p>第一步：导入xsd</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：要在路径后加<font color='#d15252'>instance</font>，表明它是被约束文件</li>
</ul>
</li>
<li><p>第二步：分配</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">xmlns=&quot;http://www.easthome.com/javase<span class="string">&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>第三步：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation=<span class="string">&quot;http://www.easthome.com/javase a.xsd&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/pql2sDmEh3XKxHt.png" alt="image-20210819095034184"></p>
<h4 id="4-Schema中的属性"><a href="#4-Schema中的属性" class="headerlink" title="4.Schema中的属性"></a>4.Schema中的属性</h4><ul>
<li><p>在sequence顺序标签下面定义属性</p>
<p><img src="https://i.loli.net/2021/08/19/NL7ZWT2hwguGfSc.png" alt="image-20210819100056793"></p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;attribute name=&quot;id&quot; type=&quot;string&quot; use=&quot;required&quot;&gt;&lt;/attribute&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>name：属性名称</p>
<p>type：数据类型</p>
<p>required：必须写属性</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>XML</tag>
      </tags>
  </entry>
  <entry>
    <title>private关键字和get/set方法</title>
    <url>/2021/08/25/private%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8Cget-set%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、权限修饰符—Private"><a href="#一、权限修饰符—Private" class="headerlink" title="一、权限修饰符—Private"></a>一、权限修饰符—<font color='#d15252'>Private</font></h3><h4 id="1-作用："><a href="#1-作用：" class="headerlink" title="1.作用："></a>1.作用：</h4><ul>
<li><p>private所修饰的内容，使用的时候，只能在本类中使用</p>
</li>
<li><p>private：私有的</p>
<ul>
<li><p>只能在本类中，操作private修饰的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Demo1.java:7: 错误: id 在 stu 中是 private 访问控制</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="2-开发中，所有的成员变量都要加private"><a href="#2-开发中，所有的成员变量都要加private" class="headerlink" title="2.开发中，所有的成员变量都要加private"></a>2.开发中，所有的成员变量都要加private</h4><ul>
<li><font color='#d15252'><strong>逻辑使用</strong></font>比较灵活</li>
</ul>
<h5 id="衍生问题：set-get方法"><a href="#衍生问题：set-get方法" class="headerlink" title="衍生问题：set/get方法"></a>衍生问题：set/get方法</h5><h3 id="二、get-set-方法"><a href="#二、get-set-方法" class="headerlink" title="二、get / set 方法"></a>二、get / set 方法</h3><ul>
<li><p><font color='orange'><strong>赋值</strong></font>(set方法)：成员变量加上private后，其他方法（比如main方法）不能给成员变量赋值</p>
<ul>
<li>但是自己的方法能访问自己的私有成员变量，其他类可以访问本类的成员方法<ul>
<li>所以用其他类访问成员方法，成员方法给成员变量修改值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//定义一个由private修饰的成员变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="comment">//完成给age的赋值功能</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.age=age;</span><br><span class="line">	&#125;</span><br><span class="line">======================================</span><br><span class="line">    <span class="comment">//在主方法中创建相应对象，调用赋值方法即可</span></span><br><span class="line">    	<span class="comment">//赋值</span></span><br><span class="line">		s.m(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><strong><font color='orange'>取值</font></strong>(get方法)：创建成员方法，通过return带回返回值给调用方法</p>
<ul>
<li>使用return原因：更加灵活，数据可以重复利用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//完成取值功能</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//使用return取值更加灵活</span></span><br><span class="line">	<span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-private修饰成员变量细节优化"><a href="#3-private修饰成员变量细节优化" class="headerlink" title="3.private修饰成员变量细节优化"></a>3.private修饰成员变量<font color='cornflowerblue'>细节优化</font></h4><ul>
<li>如果没有特殊的需求，在给成员变量赋值的时候，直接赋值即可</li>
<li>给访问private修饰的成员方法<font color='#d15252'>命名规范</font><ul>
<li>set变量名<ul>
<li>变量名首字母大写</li>
</ul>
</li>
<li>get变量名<ul>
<li>变量名首字母大写</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="作业："><a href="#作业：" class="headerlink" title="作业："></a>作业：</h5><ul>
<li>定义学生类<ul>
<li>有参和空参构造</li>
<li>private</li>
<li>学号</li>
<li>姓名</li>
</ul>
</li>
<li>添加到数组中，并做打印</li>
</ul>
<h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><ul>
<li><p>创建项目并进行测试</p>
</li>
<li><p>需求分析</p>
</li>
<li><p>创建自定义的学生类</p>
<ul>
<li><p>class Student</p>
</li>
<li><p>属性 = 成员变量 </p>
<ul>
<li>定义成员变量<ul>
<li>private int id;</li>
<li>private String name;</li>
</ul>
</li>
</ul>
</li>
<li><p>定义无参、有参构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义无参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//定义带参构造</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id,String name)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义相应的get/set方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义相应的get/set方法	=== 学号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>创建存储学生的数组方法</p>
<ul>
<li>public static Student[] init(){}</li>
<li>return返回创建的数组</li>
</ul>
<p><img src="https://i.loli.net/2021/07/28/r1f3Z2gm9Odok7I.png" alt="image-20210728103752639"></p>
</li>
<li><p>创建遍历数组学生对象的方法</p>
<p><img src="https://i.loli.net/2021/07/28/PaCGI3pbHENkK8x.png" alt="image-20210728103827836"></p>
<ul>
<li>用到get方法，取出学生对象的属性</li>
</ul>
</li>
<li><p>在main方法中</p>
<ul>
<li><p>第一步：调用init获取创建的数组</p>
</li>
<li><p>第二步：创建Student的无参对象，带参对象</p>
<ul>
<li>无参：通过.set()方法给属性赋值</li>
<li>带参：直接在初始化值时赋值</li>
</ul>
</li>
<li><p>第三步：将创建的学生对象存入数组</p>
</li>
<li><p>第四步：调用遍历数组学生对象的方法</p>
<p><img src="https://i.loli.net/2021/07/28/EIKidPcfUSOTqtr.png" alt="image-20210728104038704"></p>
</li>
</ul>
</li>
</ul>
<h3 id="三、Java的编程规范"><a href="#三、Java的编程规范" class="headerlink" title="三、Java的编程规范"></a>三、Java的编程规范</h3><ul>
<li>见名知意</li>
<li>确保功能的唯一性</li>
<li>确保逻辑的灵活性</li>
<li>规则和代码没有关系。规则语法</li>
</ul>
<h3 id="四、main方法和可变参"><a href="#四、main方法和可变参" class="headerlink" title="四、main方法和可变参"></a>四、main方法和可变参</h3><h4 id="1-main方法"><a href="#1-main方法" class="headerlink" title="1.main方法"></a>1.main方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-可变参"><a href="#2-可变参" class="headerlink" title="2.可变参"></a>2.可变参</h4><ul>
<li>格式：<code>数据类型 ... 变量名</code> </li>
<li>参数最终会变为数组</li>
<li>固定参和可变参在一起时，可变参必须写在末尾</li>
</ul>
<h3 id="五、方法的重载"><a href="#五、方法的重载" class="headerlink" title="五、方法的重载"></a>五、方法的重载</h3><h4 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h4><ul>
<li><font color='#d15252'>在同一个类中</font>，方法名相同<ul>
<li>与返回值无关，只看方法名和参数列表</li>
<li>参数<ul>
<li>参数个数    </li>
<li>参数类型</li>
</ul>
</li>
<li>修饰符同级</li>
</ul>
</li>
<li>在调用时，Jvm通过区别参数列表的不同，调用相应的方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>private</tag>
        <tag>get/set</tag>
        <tag>成员方法</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>class中的内容</title>
    <url>/2021/08/25/class%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="一、自定义的数据类型：引用类型"><a href="#一、自定义的数据类型：引用类型" class="headerlink" title="一、自定义的数据类型：引用类型"></a>一、自定义的数据类型：引用类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 数据类型 </span>&#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-Java中的数据类型分为："><a href="#1-Java中的数据类型分为：" class="headerlink" title="1.Java中的数据类型分为："></a>1.Java中的数据类型分为：</h4><ul>
<li>基本数据类型：byte、short、int、long、float、double、char、boolean<ul>
<li>整型：byte、short、int、long</li>
<li>浮点型：float、double</li>
<li>字符型：char</li>
<li>布尔型：boolean</li>
</ul>
</li>
<li>引用数据类型：数组、类、接口</li>
</ul>
<h4 id="2-自定义数据类型（自定义类）的构成"><a href="#2-自定义数据类型（自定义类）的构成" class="headerlink" title="2.自定义数据类型（自定义类）的构成"></a>2.自定义数据类型（自定义类）的构成</h4><ul>
<li>属性：成员变量<ul>
<li>成员变量的位置：类中方法外</li>
<li>有默认初始化值（在new时进程进堆内存时初始化）</li>
</ul>
</li>
<li>方法：成员方法</li>
<li>构造方法（构造器）<ul>
<li>系统默认给出的</li>
<li>每个类必须要有的</li>
</ul>
</li>
</ul>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li><p>成员方法的定义</p>
<ul>
<li>位置：自定义的数据类型（类）中，成员变量后</li>
<li>格式： <code>修饰符 返回值类型 方法名 （参数列表）&#123;  &#125;</code><ul>
<li>修饰符：public （不用static）</li>
</ul>
</li>
</ul>
</li>
<li><p>成员方法使用</p>
<ul>
<li>在main方法中创建自定义数据类型的对象</li>
<li>对象.方法名();</li>
</ul>
</li>
<li><p>成员方法调用的内存图</p>
<p><img src="https://i.loli.net/2021/07/27/ueO7sYFM621XdbH.png" alt="image-20210727095531172"></p>
</li>
</ul>
<h4 id="4-练习："><a href="#4-练习：" class="headerlink" title="4.练习："></a>4.练习：</h4><ul>
<li><p>狗的数据类型</p>
</li>
<li><p>属性：体重、姓名</p>
</li>
<li><p>行为：</p>
<ul>
<li>跑<ul>
<li>体重-10</li>
</ul>
</li>
<li>吃饭<ul>
<li>体重+10</li>
</ul>
</li>
<li>打印<ul>
<li>体重和姓名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h5><ul>
<li><p>创建项目，测试环境</p>
</li>
<li><p>需求分析：</p>
<ul>
<li>由需求可知，需要定义一个狗的数据类型，Java没有自带这种类型，所以需要自己创建</li>
</ul>
</li>
<li><p>创建狗的数据类型</p>
<ul>
<li>位置：class之间并列关系</li>
<li>格式： class 类名 {   }</li>
</ul>
</li>
<li><p>根据需求分析，属性=变量，行为=方法，在创建的数据类型中，编写对应的内部数据</p>
<p><img src="https://i.loli.net/2021/07/27/Xki4pUL3OrHQGEt.png" alt="image-20210727103148741"></p>
</li>
<li><p>如果想要实现控制台可以重复选择吃饭或跑的功能，需要定义选择，菜单方法</p>
<ul>
<li><p>方法一</p>
<ul>
<li>在main方法并列的地方编写菜单方法</li>
</ul>
<p><img src="https://i.loli.net/2021/07/27/Du9n1E5c2FgqxWR.png" alt="image-20210727103340527"></p>
<ul>
<li>定义选择方法，调用对应的数据</li>
</ul>
<p><img src="H:\瑞通java\华为云盘\笔记\第四周\V2GJnYeM5cADxIu.png" alt="image-20210727103359720"></p>
</li>
<li><p>方法二</p>
<ul>
<li><p>在自定义的狗类中创建菜单、选择的成员方法</p>
</li>
<li><p>在main主程序中，创建狗类对象，调用狗类选择方法</p>
<p><img src="https://i.loli.net/2021/07/27/i27a4f3wopb6PhM.png" alt="image-20210727103738820"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二、成员变量和成员方法"><a href="#二、成员变量和成员方法" class="headerlink" title="二、成员变量和成员方法"></a>二、成员变量和成员方法</h3><h4 id="1-变量和成员变量的区别"><a href="#1-变量和成员变量的区别" class="headerlink" title="1.变量和成员变量的区别"></a>1.变量和成员变量的区别</h4><h5 id="Ⅰ-位置"><a href="#Ⅰ-位置" class="headerlink" title="Ⅰ.位置"></a>Ⅰ.位置</h5><ul>
<li>变量：方法内/方法的声明上</li>
<li>成员变量：类中方法外</li>
</ul>
<h5 id="Ⅱ-初始化值"><a href="#Ⅱ-初始化值" class="headerlink" title="Ⅱ.初始化值"></a>Ⅱ.初始化值</h5><ul>
<li>变量：使用前，需要手动赋值</li>
<li>成员变量：有<font color='#d15252'>默认初始化值(</font>在new时进堆内存时初始化)</li>
</ul>
<h5 id="Ⅲ-同名"><a href="#Ⅲ-同名" class="headerlink" title="Ⅲ.同名"></a>Ⅲ.同名</h5><ul>
<li>变量和成员变量有同名时，系统不会在变量名前提供默认的 <code>this关键字</code>了</li>
<li>就近原则</li>
</ul>
<h5 id="Ⅳ-生命周期"><a href="#Ⅳ-生命周期" class="headerlink" title="Ⅳ.生命周期"></a>Ⅳ.生命周期</h5><ul>
<li>成员变量：随对象同生共死</li>
<li>变量：方法执行完毕后消失</li>
</ul>
<h4 id="2-方法和成员方法的区别"><a href="#2-方法和成员方法的区别" class="headerlink" title="2.方法和成员方法的区别"></a>2.方法和成员方法的区别</h4><ul>
<li><p>成员方法没有static </p>
<ul>
<li><p>static 静态 ：代码存在与代码区.class文件的静态区中</p>
</li>
<li><p><font color='#d15252'>静态区的内容随着类的加载而存在</font>（<font color='orange'>栈区可以直接操作静态</font>），<font color='#d15252'>优先于对象</font></p>
<ul>
<li>栈区不能操作非静态区，但可以直接操作静态区，静态区属于该类本身</li>
</ul>
</li>
<li><p>静态区的内容属于类，在调用时默认省略的类名</p>
<ul>
<li><p>即静态修饰的可以<font color='#d15252'>直接通过类名调用</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Demo4.B();</span><br><span class="line"><span class="comment">//Demo4类名  B()方法	</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>非静态区的内容属于堆区的实例</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/07/27/xf2mIdvb9L54GrW.png" alt="image-20210727143251525"></p>
</li>
<li><p>static的注意事项：</p>
<ul>
<li>在静态方法中没有this关键字</li>
<li>静态方法只能访问静态的成员变量和静态的成员方法</li>
</ul>
</li>
</ul>
<h4 id="3-类的加载时机"><a href="#3-类的加载时机" class="headerlink" title="3.类的加载时机"></a>3.类的加载时机</h4><ul>
<li>用到类时加载.class进Jvm内存</li>
<li>即碰到new时</li>
</ul>
<h3 id="三、构造方法（构造器）"><a href="#三、构造方法（构造器）" class="headerlink" title="三、构造方法（构造器）"></a>三、<font color='#d15252'>构造方法</font>（构造器）</h3><h4 id="1-构造方法的格式"><a href="#1-构造方法的格式" class="headerlink" title="1.构造方法的格式"></a>1.构造方法的格式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">类名() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法名与类名相同</li>
<li>没有返回值，连void都没有</li>
<li>没有具体的返回值</li>
</ul>
<h4 id="2-什么是构造器"><a href="#2-什么是构造器" class="headerlink" title="2.什么是构造器"></a>2.什么是构造器</h4><ul>
<li>构成类的一个成员<ul>
<li>给对象的数据进行初始化</li>
</ul>
</li>
<li>构建实体 : new 类名</li>
<li>构建实体的时候赋值</li>
</ul>
<h4 id="3-构造方法的细节问题"><a href="#3-构造方法的细节问题" class="headerlink" title="3.构造方法的细节问题"></a>3.构造方法的细节问题</h4><ul>
<li>当构造方法的参数变量名和成员变量名相同时<ul>
<li><font color='#d15252'>添加this关键字</font></li>
</ul>
</li>
<li>构造方法只能<font color='#d15252'>赋值</font>，不能改值（在创建对象时完成数据的初始化）</li>
</ul>
<h4 id="4-补充知识点"><a href="#4-补充知识点" class="headerlink" title="4.补充知识点"></a>4.补充知识点</h4><ul>
<li>如果手动给出构造器，系统不会再自动给出<ul>
<li>如果不给，系统给出默认构造器</li>
<li>建议给出空参构造</li>
</ul>
</li>
<li>构造方法可以重载</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>实体 === 对象</li>
<li>属性 === 成员变量</li>
<li>行为 === 成员方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>成员方法</tag>
        <tag>class</tag>
        <tag>成员变量</tag>
        <tag>构造方法</tag>
      </tags>
  </entry>
  <entry>
    <title>实现前端-Web-数据库</title>
    <url>/2021/08/25/%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF-Web-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h3 id="获取前端数据"><a href="#获取前端数据" class="headerlink" title="获取前端数据"></a>获取前端数据</h3><ul>
<li><p>创建一个JavaWeb程序，用作链接前端、链接数据库</p>
<p><img src="https://i.loli.net/2021/07/12/zVu7OEIBXJn6Mtd.png" alt="image-20210712161124635"></p>
<ul>
<li><p>继承HttpServlet类，调用doGet方法，起名</p>
<p><img src="https://i.loli.net/2021/07/12/1F4kqTlvxRB5Ynd.png" alt="image-20210712161304640"></p>
</li>
<li><p>从数据库获取数据（暂时用数组定义）</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/07/12/XZSKOrTsQtMIRBh.png" alt="image-20210712162838029"></p>
<p>并创建web程序和需要获取数据的前端网页的链接通道</p>
<p><img src="https://i.loli.net/2021/07/12/ewBrSXd9Ijv2sNF.png" alt="image-20210712162849088"></p>
<ul>
<li><p>req调用getRequestDispatcher()方法，返回前端页面</p>
<p><img src="https://i.loli.net/2021/07/12/EhKWv1iCNS42d9X.png"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建index.jsp文件，是前端访问后端的入口</p>
<ul>
<li><p><img src="https://i.loli.net/2021/07/12/nYDjNOe7TJlawCo.png" alt="image-20210712161631994"></p>
</li>
<li><p>跳转到web程序，获取数据，并返回前端页面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/web&quot;</span>&gt;</span>显示数据<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<ul>
<li><p>创建Demo.jsp文件，获取数据，返回前端页面</p>
<ul>
<li><img src="https://i.loli.net/2021/07/12/8IeLMxifDCVcnP7.png" alt="image-20210712161750078"></li>
<li>通过request.getAttribute()通道，获取web程序发送的数据</li>
</ul>
<p><img src="https://i.loli.net/2021/07/12/gTBDefpUuxYHn8K.png" alt="image-20210712163113274"></p>
<p>由于自动保存是Object类型，强制转换为int[]类型，并保存到变量</p>
<p><img src="https://i.loli.net/2021/07/12/qOAWJZLxC5bKHh8.png" alt="image-20210712163232172"></p>
<ul>
<li>创建表格，for循环，输出前端页面</li>
</ul>
<p><img src="https://i.loli.net/2021/07/12/SW4TfJRLKYqOIPH.png" alt="image-20210712164329135"></p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/07/12/fC7dFLh2HkmaPYI.png" alt="image-20210712221449519"></p>
<ul>
<li><p>前端页面使用Form表单获取并发送数据</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    表单--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;02.html&quot;</span>&gt;</span></span><br><span class="line">        用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pass&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>action：发送到xxx</p>
<p>submit：提交按钮</p>
<p>name ：保存数据名称用来接收    </p>
</blockquote>
</li>
<li><p>web程序中用req调用getParameter方法接收数据</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/MypWvdFclrfzj74.png" alt="image-20210713101204523"></li>
</ul>
</li>
</ul>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="一、创建项目并测试环境"><a href="#一、创建项目并测试环境" class="headerlink" title="一、创建项目并测试环境"></a>一、创建项目并测试环境</h4><h4 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h4><h5 id="1-显示商品编号"><a href="#1-显示商品编号" class="headerlink" title="1.显示商品编号"></a>1.显示商品编号</h5><ul>
<li><p>index.jsp中创建超链接，跳转display程序</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/eX8ESPiNIZmfkrH.png" alt="image-20210713110739311"></li>
<li><img src="https://i.loli.net/2021/07/13/S1gC9lzp8FJrNti.png" alt="image-20210713110746819"></li>
<li>发送数据到display.jsp页面，用于显示</li>
</ul>
</li>
<li><p>display负责链接前端页面，链接数据库，从数据库中获取数据并存入数组</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/e7cY8M2DjmHURkC.png" alt="image-20210713110709710"></li>
</ul>
</li>
<li><p>创建display.jsp，接收web程序发送的数据，并显示在页面</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/x7Sk5zpFVK8QnIb.png" alt="image-20210713110859014"></li>
</ul>
</li>
</ul>
<h5 id="2-修改商品编号"><a href="#2-修改商品编号" class="headerlink" title="2.修改商品编号"></a>2.修改商品编号</h5><ul>
<li><p>创建update.jsp、updateWEB程序</p>
<p>index.jsp中超链接跳转update.jsp</p>
<p><img src="https://i.loli.net/2021/07/13/Ot94cLZMfCeDK7l.png" alt="image-20210713121412256"></p>
</li>
<li><p>update.jsp</p>
<ul>
<li><p>获创建表单，获取数据</p>
</li>
<li><p>由web程序update接收数据</p>
<p><img src="https://i.loli.net/2021/07/13/Bgr5VD9fvLCwP2m.png" alt="image-20210713121547204"></p>
</li>
</ul>
</li>
<li><p>update JavaWeb程序</p>
<ul>
<li>链接数据库，接收前端输入数据</li>
<li>打包sql语句，发送sql语句，执行sql语句</li>
<li>跳转回主页面</li>
</ul>
<p><img src="https://i.loli.net/2021/07/13/pqMDV6YPC2NUeTa.png" alt="image-20210713121645948"></p>
</li>
</ul>
<h5 id="3-增加商品编号"><a href="#3-增加商品编号" class="headerlink" title="3.增加商品编号"></a>3.增加商品编号</h5><ul>
<li><p>创建add.jsp、addWeb程序</p>
<p>index.jsp中跳转到add.jsp中</p>
</li>
<li><p>add.jsp创建表单，录入数据，发送到add程序</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/bgYxj3e1vXfzVDN.png" alt="image-20210713121825966"></li>
</ul>
</li>
<li><p>add JavaWeb程序</p>
<ul>
<li><p>链接数据库，打包sql语句，发送，执行，返回首页</p>
<p><img src="https://i.loli.net/2021/07/13/7vGfYXLIwKnt8zr.png" alt="image-20210713121946605"></p>
</li>
</ul>
</li>
</ul>
<h5 id="4-删除商品编号"><a href="#4-删除商品编号" class="headerlink" title="4.删除商品编号"></a>4.删除商品编号</h5><ul>
<li><p>创建delete.jsp、delete Web程序</p>
<p>index.jsp中跳转到delete.jsp中</p>
</li>
<li><p>delete.jsp创建表单，录入数据，发送到add程序</p>
<p><img src="https://i.loli.net/2021/07/13/YFehBzTCfHp2tSm.png" alt="image-20210713122104396"></p>
</li>
<li><p>delete JavaWeb程序</p>
<ul>
<li><img src="https://i.loli.net/2021/07/13/piRLJI4vy1lKNoA.png" alt="image-20210713122155096"></li>
</ul>
</li>
</ul>
<blockquote>
<p>解决向mysql插入中文数据乱码问题</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">?<span class="attribute">useUnicode</span>=<span class="literal">true</span>&amp;characterEncoding=utf8</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>跳转页面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">req.getRequestDispatcher(<span class="string">&quot;show.jsp&quot;</span>).forward(req,resp);</span><br></pre></td></tr></table></figure></li>
<li><p>跳转程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.sendRedirect(<span class="string">&quot;show&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>增查删改</tag>
        <tag>案例</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义数据类型和学生管理系统</title>
    <url>/2021/08/25/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="一、面向对象思想"><a href="#一、面向对象思想" class="headerlink" title="一、面向对象思想"></a>一、面向对象思想</h3><ul>
<li>暂且不提</li>
</ul>
<h3 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h3><ul>
<li>Java提供的数据类型有很多种，但是Java只提供了最基础的</li>
<li>当需要使用自定义的数据类型时，Java提供了方法自行创建</li>
</ul>
<h4 id="1-自定义数据类型-定义类"><a href="#1-自定义数据类型-定义类" class="headerlink" title="1.自定义数据类型(定义类)"></a>1.<font color='#d15252'>自定义数据类型(定义类)</font></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名 </span>&#123; &#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">//class只能是并列关系</span></span><br></pre></td></tr></table></figure>

<ul>
<li>通常叫做<font color='#d15252'>定义一个类</font><ul>
<li>实际上可以理解为自定义了一个数据类型</li>
</ul>
</li>
</ul>
<h4 id="2-如何存储内部数据"><a href="#2-如何存储内部数据" class="headerlink" title="2.如何存储内部数据"></a>2.如何存储内部数据</h4><ul>
<li>用定义变量的方式</li>
</ul>
<h4 id="3-自定义数据类型的使用"><a href="#3-自定义数据类型的使用" class="headerlink" title="3.自定义数据类型的使用"></a>3.自定义数据类型的使用</h4><ul>
<li><p>使用思路</p>
<ul>
<li>通过内存图发现，我们需要用到自定义数据类型的内部数据</li>
<li>而内部数据要存储数据就必须开辟内存空间</li>
<li>遇到复杂类型的数据类型，需要在堆区中开辟内存空间</li>
<li>将CPU执行权有栈区交到堆区<font color='#d15252'>new</font></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//定义变量s  存储 堆区定义的Student()里的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-自定义数据类型的思路"><a href="#4-自定义数据类型的思路" class="headerlink" title="4.自定义数据类型的思路"></a>4.自定义数据类型的思路</h4><ul>
<li>第一步：创建项目，测试环境</li>
<li>Java没有自带学生数据，需要我们<font color='cornflowerblue'>自定义一个数据类型</font></li>
<li>自定义数据类型的格式<ul>
<li>位置：class之间并列关系</li>
<li>内容：用变量存储数据</li>
<li>格式：<code>class 数据类型 &#123;&#125;</code></li>
</ul>
</li>
<li>在定义的数据类型中存储内部数据<ul>
<li>和之间定义变量、数组、集合等一样</li>
</ul>
</li>
<li>创建自定义的数据类型的变量，存储new Student()的地址值。<ul>
<li>因为Student内有许多变量，<font color='cornflowerblue'>遇到复杂数据类型，在堆区中开辟内存空间</font>所以 <code>Student s = new Student();</code></li>
</ul>
</li>
<li>调用对应数据<ul>
<li>赋值<ul>
<li>变量名.内部变量名 = 数值；</li>
</ul>
</li>
<li>取值<ul>
<li>输出取值<ul>
<li>System.out.println(s.id);</li>
</ul>
</li>
<li>赋值取值<ul>
<li>String a =  System.out.println(t.name);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-内存图"><a href="#5-内存图" class="headerlink" title="5.内存图"></a>5.内存图</h4><p><img src="https://i.loli.net/2021/07/26/lw4KUF27ArbqiDV.png" alt="image-20210726103528357"></p>
<h4 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6.注意事项"></a>6.注意事项</h4><ul>
<li>从作用的角度判断Java中类的分类<ul>
<li><font color='orange'>测试类</font>：包含main方法的类（程序入口）<ul>
<li>也是一种自定义的数据类型，不过不用来做存储，而是做Java程序的测试</li>
</ul>
</li>
<li>基础类</li>
</ul>
</li>
<li>内部变量：属性</li>
<li>自定义数据类型：先将小的数据进行封装</li>
</ul>
<h4 id="7-作业"><a href="#7-作业" class="headerlink" title="7.作业"></a>7.作业</h4><h5 id="Ⅰ-需求"><a href="#Ⅰ-需求" class="headerlink" title="Ⅰ.需求:"></a>Ⅰ.需求:</h5><ul>
<li>定义一个学生类<ul>
<li>年龄</li>
<li>姓名</li>
<li>学号</li>
</ul>
</li>
<li>定义一个数组<ul>
<li>在数组中存三个学生</li>
<li>将三个学生信息输出到控制台</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-思路："><a href="#Ⅱ-思路：" class="headerlink" title="Ⅱ.思路："></a>Ⅱ.思路：</h5><ul>
<li><p>创建项目、测试环境</p>
<ul>
<li><img src="https://i.loli.net/2021/07/26/ns6IQq32bGaXVEu.png" alt="image-20210726115908543"></li>
</ul>
</li>
<li><p>需求分析</p>
<ul>
<li>Java没有自带的学生类，需要自定义数据类型</li>
</ul>
</li>
<li><p>自定义数据类型的格式</p>
<ul>
<li>位置：并列</li>
<li>格式：class Student{}</li>
<li><img src="https://i.loli.net/2021/07/26/MqUEif5PvB1LwTY.png" alt="image-20210726115922736"></li>
</ul>
</li>
<li><p>在定义的数据类型中存储内部数据</p>
<ul>
<li>将属性复制进去，并定义相应的变量</li>
</ul>
</li>
<li><p>创建三个学生类型的变量，存储new Student() 的地址值，分别保存到变量s1，s2，s3</p>
<ul>
<li><img src="https://i.loli.net/2021/07/26/dcjbCovmaFA4M3I.png" alt="image-20210726115942137"></li>
</ul>
</li>
<li><p>定义一个数组，存储三个学生变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line">		Student[] arr = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">		arr[<span class="number">0</span>]=s1;</span><br><span class="line">		arr[<span class="number">1</span>]=s2;</span><br><span class="line">		arr[<span class="number">2</span>]=s3;</span><br></pre></td></tr></table></figure></li>
<li><p>初始化学生变量的具体内部数据</p>
<ul>
<li><img src="https://i.loli.net/2021/07/26/MgtkvVeWhuS2ab4.png" alt="image-20210726120053345"></li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-内存图："><a href="#Ⅲ-内存图：" class="headerlink" title="Ⅲ.内存图："></a>Ⅲ.内存图：</h5><p><img src="https://i.loli.net/2021/07/26/B4dFKjpRXLwnErS.png" alt="image-20210726115815170"></p>
<h5 id="Ⅳ-所有代码："><a href="#Ⅳ-所有代码：" class="headerlink" title="Ⅳ.所有代码："></a>Ⅳ.所有代码：</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建项目、测试环境</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">//创建存储变量</span></span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">		Student s3 = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//定义数组</span></span><br><span class="line">		Student[] arr = <span class="keyword">new</span> Student[<span class="number">3</span>];</span><br><span class="line">		<span class="comment">//初始化学生</span></span><br><span class="line">		s1.id = <span class="number">1</span>;</span><br><span class="line">		s1.name = <span class="string">&quot;李玉楷&quot;</span>;</span><br><span class="line">		s1.age = <span class="number">20</span>;</span><br><span class="line">		s2.id = <span class="number">2</span>;</span><br><span class="line">		s2.name = <span class="string">&quot;王俊&quot;</span>;</span><br><span class="line">		s2.age = <span class="number">2</span>;</span><br><span class="line">		s3.id = <span class="number">3</span>;</span><br><span class="line">		s3.name = <span class="string">&quot;谭宇&quot;</span>;</span><br><span class="line">		s3.age = <span class="number">200</span>;</span><br><span class="line">		arr[<span class="number">0</span>]=s1;</span><br><span class="line">		arr[<span class="number">1</span>]=s2;</span><br><span class="line">		arr[<span class="number">2</span>]=s3;</span><br><span class="line">		<span class="comment">//for循环遍历数组输出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//输出学生信息</span></span><br><span class="line">			System.out.println(<span class="string">&quot;ID:&quot;</span>+arr[i].id+<span class="string">&quot;\t姓名：&quot;</span>+arr[i].name+<span class="string">&quot;\t年龄&quot;</span>+arr[i].age);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义学生数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;<span class="comment">/*</span></span><br><span class="line"><span class="comment">- 年龄</span></span><br><span class="line"><span class="comment">- 姓名</span></span><br><span class="line"><span class="comment">- 学号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="三、综合案例-学生管理系统"><a href="#三、综合案例-学生管理系统" class="headerlink" title="三、综合案例-学生管理系统"></a>三、综合案例-学生管理系统</h3><h4 id="1-需求："><a href="#1-需求：" class="headerlink" title="1.需求："></a>1.需求：</h4><ul>
<li>用集合或数组，定义方法，自定义数据类型的方式，完成学生管理系统</li>
</ul>
<h4 id="2-思路："><a href="#2-思路：" class="headerlink" title="2.思路："></a>2.思路：</h4><h5 id="第一步：创建项目，测试环境"><a href="#第一步：创建项目，测试环境" class="headerlink" title="第一步：创建项目，测试环境"></a>第一步：创建项目，测试环境</h5><p><img src="https://i.loli.net/2021/07/26/J8CrIsnU3MyPztV.png" alt="image-20210726120705033"></p>
<h5 id="第二步：需求分析"><a href="#第二步：需求分析" class="headerlink" title="第二步：需求分析"></a>第二步：需求分析</h5><ul>
<li><p>首先，实现显示菜单的方法</p>
</li>
<li><p>方法定义：</p>
<ul>
<li>位置：并列</li>
<li>格式：修饰符 返回值类型 方法名（参数列表）{}</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/ZS5kgzCvJshxTW8.png" alt="image-20210726123428476"></p>
<ul>
<li><p>实现选择功能的方法</p>
<ul>
<li><p>Scanner键盘录入三个步骤</p>
<ul>
<li>导包</li>
<li>加载Scanner进内存</li>
<li>保存键盘录入的数据</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/7BwJIEDLaXU8YlA.png" alt="image-20210726123658745"></p>
</li>
<li><p>在死循环前，调用init()初始化数据方法，获取init初始化的数据,并命名为stu</p>
<p><img src="https://i.loli.net/2021/07/26/cySsguVFIEa4Ur3.png" alt="image-20210726131619353"></p>
</li>
<li><p>在if判断前，调用menu()菜单方法，让每次选择前先显示一下菜单</p>
<p><img src="https://i.loli.net/2021/07/26/FlLhsdwkrIgHMQc.png" alt="image-20210726131635716"></p>
</li>
<li><p>if条件判断录入的值，进行相应的操作</p>
<p><img src="https://i.loli.net/2021/07/26/vsqYjcwyCLlbhn1.png" alt="image-20210726123830612"></p>
</li>
<li><p>设置while(true)死循环，使菜单可以重复选择</p>
<p><code>while(true)&#123; &#125;</code></p>
<p>当键盘录入数据a==5时，退出系统，添加break语句，跳出循环</p>
<p><code>break;</code></p>
</li>
<li></li>
</ul>
</li>
<li><p>实现加载数据的方法</p>
<ul>
<li><p>定义一个加载数据的方法</p>
<ul>
<li>由需求可知要用自定义数据类型的方式完成题目，所以，要加载数据，首先需要创建一个名为Student的自定义数据类型</li>
</ul>
</li>
<li><p>创建三个学生对象</p>
<ul>
<li><code>Student s1 = new Student();</code></li>
</ul>
</li>
<li><p>创建集合</p>
<p><img src="https://i.loli.net/2021/07/26/azQEj27RwLoyH3N.png" alt="image-20210726130119065"></p>
</li>
<li><p>初始化学生数据</p>
<p><img src="https://i.loli.net/2021/07/26/Jt6eLrVfOmvCMKb.png" alt="image-20210726130400721"></p>
</li>
<li><p>将学生存入集合</p>
<p><img src="https://i.loli.net/2021/07/26/SM7Yx2NoWdeAKya.png" alt="image-20210726130612856"></p>
</li>
<li><p>return带回创建好的集合数据</p>
<p><code>return stu;</code></p>
<p>将方法定义上的参数类型，修改为ArrayList</p>
</li>
</ul>
</li>
</ul>
<h5 id="第三步：创建名为Student的自定义数据类型"><a href="#第三步：创建名为Student的自定义数据类型" class="headerlink" title="第三步：创建名为Student的自定义数据类型"></a>第三步：创建名为Student的自定义数据类型</h5><ul>
<li><p>创建：</p>
<ul>
<li>位置：并列</li>
<li>格式：class 名 { }</li>
</ul>
</li>
<li><p>学生属性有 学号、性别 、姓名、年龄</p>
<ul>
<li><p>将这些属性存入自定义数据类型的内部</p>
<p><img src="https://i.loli.net/2021/07/26/OWSqzFtNdQ2m1Yu.png" alt="image-20210726124455231"></p>
</li>
</ul>
<h5 id="第四步：实现具体的显示功能"><a href="#第四步：实现具体的显示功能" class="headerlink" title="第四步：实现具体的显示功能"></a>第四步：实现具体的显示功能</h5></li>
<li><p>定义具体显示功能的方法</p>
<ul>
<li><p>位置：并列</p>
</li>
<li><p>格式：修饰符 返回值类型 方法名（参数列表）{ }</p>
<p><img src="https://i.loli.net/2021/07/26/FC7VOWXM1Da6kNs.png" alt="image-20210726130923154"></p>
</li>
</ul>
</li>
<li><p>分析：要显示数据，首先需要接收到数据</p>
<ul>
<li><p>所以在choose选择方法中，判断当键盘录入数据a==1时，实现选择功能，调用选择方法，同时传递学生信息的集合参数</p>
<p><img src="https://i.loli.net/2021/07/26/cCjdKuEaibROkwy.png" alt="image-20210726131814216"></p>
</li>
<li><p>show()显示方法定义中，添加 ArrayList 数据类型，接收choose()传递的参数</p>
<p><img src="https://i.loli.net/2021/07/26/DxR1W6SutswQ2CV.png" alt="image-20210726132509229"></p>
</li>
<li><p>定义for循环输出数据</p>
<p><img src="https://i.loli.net/2021/07/26/y9c7AYBqwjP5oax.png" alt="image-20210726133552249"></p>
<blockquote>
<p>stu.get(i).id    ：  stu.get(i)取出stu集合中第i个索引的数据</p>
<p>“.”    ： 调用</p>
</blockquote>
</li>
</ul>
<h5 id="第五步：实现具体的修改功能"><a href="#第五步：实现具体的修改功能" class="headerlink" title="第五步：实现具体的修改功能"></a>第五步：实现具体的修改功能</h5></li>
<li><p>创建修改功能的方法</p>
<ul>
<li><p>位置：并列</p>
</li>
<li><p>格式：修饰符 返回值类型 方法名(参数列表) {  }</p>
<p><img src="https://i.loli.net/2021/07/26/ToYWk1iFXUnh5rq.png" alt="image-20210726135243939"></p>
</li>
<li><p>定义参数，接收数据</p>
</li>
</ul>
</li>
<li><p>键盘录入数据，输入要修改的id</p>
</li>
<li><p>if条件判断是否有匹配的Id</p>
<p><img src="https://i.loli.net/2021/07/26/Wl9iKTPS82tsw6Z.png" alt="image-20210726135555188"></p>
<ul>
<li><p>当有匹配的值时，提示输入修改后的数据，用集合中的学生对象调用对应数据，直接修改</p>
<p><img src="https://i.loli.net/2021/07/26/J4rDF6O9T8hvygK.png" alt="image-20210726140056112"></p>
</li>
</ul>
</li>
</ul>
<h5 id="第六步：实现增加功能"><a href="#第六步：实现增加功能" class="headerlink" title="第六步：实现增加功能"></a>第六步：实现增加功能</h5><ul>
<li><p>定义增加功能的方法</p>
<ul>
<li>位置：并列</li>
<li>格式：修饰符 返回值类型 方法名（参数列表） {   }</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/AGJI23yYp59ofmd.png" alt="image-20210726140259481"></p>
</li>
<li><p>键盘录入要添加的数据</p>
</li>
<li><p>创建一个新的学生对象，键盘录入新的学生对象的数据，将对象添加到集合</p>
<p><img src="https://i.loli.net/2021/07/26/4GZeMKYPXcwUQtN.png" alt="image-20210726141051550"></p>
</li>
</ul>
<h5 id="第七步：实现删除功能"><a href="#第七步：实现删除功能" class="headerlink" title="第七步：实现删除功能"></a>第七步：实现删除功能</h5><ul>
<li><p>定义实现删除功能的方法</p>
<ul>
<li>位置：并列</li>
<li>格式：修饰符 返回值类型 方法名（参数列表） {  }</li>
</ul>
<p><img src="https://i.loli.net/2021/07/26/5MjKvp2xhF6wPfr.png" alt="image-20210726141310390"></p>
</li>
<li><p>键盘录入要删除的学生ID</p>
</li>
<li><p>删除对应id上一位的索引数据</p>
<p><img src="https://i.loli.net/2021/08/25/FY9JXHZSIWp3zlU.png" alt="image-20210726141653906"></p>
</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导包</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="comment">//创建项目、测试环境</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;	<span class="comment">//实现学生管理系统</span></span><br><span class="line">		choose();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现显示菜单的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;||\t1.显示学生信息  \t||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;||\t2.修改学生信息  \t||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;||\t3.增加学生信息  \t||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;||\t4.删除学生信息  \t||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;||\t 5.退出 系统    \t||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现选择功能的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">choose</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//键盘录入	</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">//初始化数据</span></span><br><span class="line">		ArrayList stu =init();</span><br><span class="line">		<span class="comment">//死循环实现菜单重复选择</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//每次选择前显示菜单</span></span><br><span class="line">		menu();</span><br><span class="line">		<span class="comment">//保存键盘录入数据</span></span><br><span class="line">		<span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">		<span class="keyword">if</span> (a==<span class="number">1</span>)</span><br><span class="line">		&#123;	<span class="comment">//实现菜单的显示功能</span></span><br><span class="line">			<span class="comment">//调用方法，传递参数</span></span><br><span class="line">			show(stu);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (a==<span class="number">2</span>)</span><br><span class="line">		&#123;	<span class="comment">//实现数据的修改功能</span></span><br><span class="line">			<span class="comment">//调用修改方法，传递数据</span></span><br><span class="line">			update(stu);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (a==<span class="number">3</span>)</span><br><span class="line">		&#123;	<span class="comment">//实现增加的功能</span></span><br><span class="line">			<span class="comment">//调用增加方法,传递集合参数</span></span><br><span class="line">			add(stu);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (a==<span class="number">4</span>)</span><br><span class="line">		&#123;	<span class="comment">//实现删除的功能</span></span><br><span class="line">			<span class="comment">//调用删除方法,传递集合参数</span></span><br><span class="line">			del(stu);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (a==<span class="number">5</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;===退出成功===&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//实现加载数据的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建三个学生对象</span></span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">		Student s3 = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//创建一个集合，存储这些学生</span></span><br><span class="line">		ArrayList&lt;Student&gt; stu = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		s1.id = <span class="number">1</span>;</span><br><span class="line">		s1.name = <span class="string">&quot;宋世杰&quot;</span>;</span><br><span class="line">		s1.sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">		s1.age = <span class="number">18</span>;</span><br><span class="line">		s2.id = <span class="number">2</span>;</span><br><span class="line">		s2.name = <span class="string">&quot;李玉楷&quot;</span>;</span><br><span class="line">		s2.sex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">		s2.age = <span class="number">17</span>;</span><br><span class="line">		s3.id = <span class="number">3</span>;</span><br><span class="line">		s3.name = <span class="string">&quot;王俊&quot;</span>;</span><br><span class="line">		s3.sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">		s3.age = <span class="number">28</span>;</span><br><span class="line">		stu.add(s1);</span><br><span class="line">		stu.add(s2);</span><br><span class="line">		stu.add(s3);</span><br><span class="line">		<span class="comment">//由return带回创建的集合数据</span></span><br><span class="line">		<span class="keyword">return</span> stu;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义实现显示的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(ArrayList&lt;Student&gt; stu)</span></span>&#123;</span><br><span class="line">		<span class="comment">//要显示数据，首先需要获取数据，定义参数ArrayList 接收集合参数</span></span><br><span class="line">		<span class="comment">//定义for循环输出数据</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stu.size();i++)</span><br><span class="line">		&#123;			<span class="comment">//.size()集合长度</span></span><br><span class="line">			System.out.println(<span class="string">&quot;ID:&quot;</span>+stu.get(i).id+<span class="string">&quot;\t姓名:&quot;</span>+stu.get(i).name+<span class="string">&quot;\t性别:&quot;</span>+stu.get(i).sex+<span class="string">&quot;\t年龄:&quot;</span>+stu.get(i).age);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;===显示完成，返回主菜单===&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义实现修改的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(ArrayList&lt;Student&gt; stu)</span></span>&#123;</span><br><span class="line">		<span class="comment">//同样如果要修改，需要先拿到数据，所以定义参数ArrayList&lt;Student&gt;接收数据</span></span><br><span class="line">		<span class="comment">//键盘录入数据，输入要修改的Id</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要修改的学生Id:&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> oid = sc.nextInt();</span><br><span class="line">		<span class="comment">//for+if判断是否有匹配的Id</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stu.size();i++)</span><br><span class="line">		&#123;	<span class="comment">//循环查找</span></span><br><span class="line">			<span class="keyword">if</span> (stu.get(i).id==oid)</span><br><span class="line">			&#123;	<span class="comment">//如果数据匹配时，提示修改</span></span><br><span class="line">				System.out.println(<span class="string">&quot;请输入修改后的学生姓名:&quot;</span>) </span><br><span class="line">				stu.get(i).name = sc.next();</span><br><span class="line">				System.out.println(<span class="string">&quot;请输入修改后的学生性别:&quot;</span>);</span><br><span class="line">				stu.get(i).sex = sc.next();</span><br><span class="line">				System.out.println(<span class="string">&quot;请输入修改后的学生年龄:&quot;</span>);</span><br><span class="line">				stu.get(i).age = sc.nextInt();</span><br><span class="line">				<span class="comment">//修改成功</span></span><br><span class="line">				System.out.println(<span class="string">&quot;===修改成功，返回主菜单===&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义实现增加的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(ArrayList&lt;Student&gt; stu)</span></span>&#123;</span><br><span class="line">		<span class="comment">//因为要添加数据到集合，所以首先要接收集合，往内添加</span></span><br><span class="line">		<span class="comment">//加载Scanner进内存，从键盘录入数据</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">//添加一个学生对象到集合中</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要添加的学生id：&quot;</span>);</span><br><span class="line">		s.id=sc.nextInt();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要添加的学生姓名：&quot;</span>);</span><br><span class="line">		s.name=sc.next();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要添加的学生性别：&quot;</span>);</span><br><span class="line">		s.sex=sc.next();</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要添加的学生年龄：&quot;</span>);</span><br><span class="line">		s.age=sc.nextInt();</span><br><span class="line">		<span class="comment">//添加到集合</span></span><br><span class="line">		stu.add(s);</span><br><span class="line">		System.out.println(<span class="string">&quot;===添加成功，返回主菜单===&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//定义实现删除的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(ArrayList&lt;Student&gt; stu)</span></span>&#123;</span><br><span class="line">		<span class="comment">//同理，如果要删除集合中的一个数据，首先要拿到集合，方法参数接收集合数据</span></span><br><span class="line">		<span class="comment">//键盘录入要删除的id</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入要删除的学生id:&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> del = sc.nextInt();</span><br><span class="line">		<span class="comment">//删除对应的Id</span></span><br><span class="line">		stu.remove(del-<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;===删除成功，返回主菜单===&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建student自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">//学号、姓名、性别、年龄!.</span></span><br><span class="line">	<span class="keyword">int</span> id ;</span><br><span class="line">	String name;</span><br><span class="line">	String sex;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><ul>
<li>方法运行完结束后弹栈，释放内存。</li>
<li>所有字符串类型的数据类型，系统默认值都是null，（包括地址值）</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>class</tag>
        <tag>学生管理系统</tag>
      </tags>
  </entry>
  <entry>
    <title>匿名对象、内部类、代码块、和修饰符等</title>
    <url>/2021/08/25/%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E3%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E3%80%81%E5%92%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%AD%89/</url>
    <content><![CDATA[<h3 id="一、匿名对象"><a href="#一、匿名对象" class="headerlink" title="一、匿名对象"></a>一、匿名对象</h3><h4 id="1-什么是匿名对象"><a href="#1-什么是匿名对象" class="headerlink" title="1.什么是匿名对象"></a>1.什么是匿名对象</h4><ul>
<li>​    没有名字的对象<ul>
<li>即堆区的地址值，没有用变量来保存</li>
</ul>
</li>
</ul>
<h4 id="2-匿名对象的使用"><a href="#2-匿名对象的使用" class="headerlink" title="2.匿名对象的使用"></a>2.匿名对象的使用</h4><ul>
<li><p>快速访问（测试用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个匿名对象，快速访问类中的值，用完即释放</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> A().a);</span><br></pre></td></tr></table></figure></li>
<li><p>传参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建匿名对象传给方法</span></span><br><span class="line">m(<span class="keyword">new</span> A());</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(A a)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二、内部类"><a href="#二、内部类" class="headerlink" title="二、内部类"></a>二、内部类</h3><h4 id="1-什么是内部类"><a href="#1-什么是内部类" class="headerlink" title="1.什么是内部类"></a>1.什么是内部类</h4><ul>
<li>在类中定义类<ul>
<li>通过实验，发现Java语法允许在类的内部定义类</li>
</ul>
</li>
<li>生成Class文件格式 ：  外部类$内部类</li>
</ul>
<h4 id="2-内部类区别"><a href="#2-内部类区别" class="headerlink" title="2.内部类区别"></a>2.内部类区别</h4><ul>
<li><p>成员内部类：类中方法外</p>
<ul>
<li>访问格式：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">外部类.内部类 变量名 = <span class="keyword">new</span> 外部类().new 内部类();</span><br></pre></td></tr></table></figure></li>
<li><p>局部内部类：类中方法中</p>
<ul>
<li>访问：<ul>
<li>在方法中，内部类并列的地方，创建内部类的对象，通过对象调用内部类中的成员</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="comment">//成员方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部内部类</span></span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">			<span class="comment">//内部类中的方法</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>&#123;</span><br><span class="line">				System.out.println(<span class="number">111111</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//创建内部类的对象，调用其中的成员</span></span><br><span class="line">		<span class="keyword">new</span> C().m2();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建A类对象，调用m2方法</span></span><br><span class="line">		A a = <span class="keyword">new</span> A();</span><br><span class="line">		a.m();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-内部类访问特点"><a href="#3-内部类访问特点" class="headerlink" title="3.内部类访问特点"></a>3.内部类访问特点</h4><ul>
<li>内部类可以直接访问外部类的成员，包括私有</li>
<li>外部类要访问内部类的成员，必须创建对象</li>
</ul>
<h4 id="4-匿名内部类"><a href="#4-匿名内部类" class="headerlink" title="4.匿名内部类"></a>4.<font color='#d15252'>匿名内部类</font></h4><ul>
<li><p>快速的实例化接口或者抽象类</p>
<ul>
<li><p>一般采用多态的手法去实例化（用变量来保存该匿名内部类的实体）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//直接输出匿名内部类</span></span><br><span class="line"><span class="comment">//System.out.println(new ....);</span></span><br><span class="line"><span class="comment">//得到一个地址值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">在&#123;&#125;后直接加调用方法 </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="三、代码块"><a href="#三、代码块" class="headerlink" title="三、代码块"></a>三、代码块</h3><ul>
<li><p>{ }</p>
</li>
<li><p>位置区别</p>
<ul>
<li><p>构造代码块（类中方法外）</p>
<ul>
<li>在创建对象时调用</li>
<li>优先于构造方法执行</li>
</ul>
</li>
<li><p>局部代码块（方法内）</p>
<ul>
<li>限定变量生命周期，提高内存利用率</li>
</ul>
</li>
<li><p><font color='#d15252'>静态</font>代码块，在代码块前加static</p>
<ul>
<li>在创建对象时调用</li>
<li>优先与构造代码块（<font color='orange'>优先级最高</font>）</li>
<li><font color='#d15252'>只执行一次</font></li>
</ul>
<blockquote>
<p>比较常用，加载数据，加载驱动</p>
<p>媒介：系统软件和硬件的连接者</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="四、包"><a href="#四、包" class="headerlink" title="四、包"></a>四、包</h3><h4 id="1-什么是包"><a href="#1-什么是包" class="headerlink" title="1.什么是包"></a>1.什么是包</h4><ul>
<li>文件夹<ul>
<li>多个class文件进行管理</li>
<li>增加文件夹</li>
</ul>
</li>
<li>命名<ul>
<li>公司域名倒写<ul>
<li>baidu.com</li>
<li>包名：com.baidu.add</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Java实现自动打包"><a href="#2-Java实现自动打包" class="headerlink" title="2.Java实现自动打包"></a>2.Java实现自动打包</h4><ul>
<li><p>先定义包</p>
<ul>
<li>package com.a；(代码第一行)</li>
</ul>
</li>
<li><p>在当前java文件目录打开cmd命令行</p>
<ul>
<li><p>输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javac -d . 类名.java</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="五、修饰符"><a href="#五、修饰符" class="headerlink" title="五、修饰符"></a>五、修饰符</h3><table>
<thead>
<tr>
<th>修饰符访问权限</th>
<th>类</th>
<th>包</th>
<th>子类</th>
<th>其他包</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>对任何人都是可用的</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>继承的类可以访问以及和private一样的权限</td>
</tr>
<tr>
<td>default(默认)</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>包访问权限，即在整个包内均可被访问</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>除类型创建者和类型的内部方法之外的任何人都不能访问的元素</td>
</tr>
</tbody></table>
<h3 id="六、增强for循环"><a href="#六、增强for循环" class="headerlink" title="六、增强for循环"></a>六、增强for循环</h3><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(变量:遍历对象)&#123;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例如</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i ; arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>弊端：没有索引，不能修改，不能操作s</li>
<li>优点：取值更加方便</li>
</ul>
</li>
</ul>
<ul>
<li>静态绑定：final static private</li>
<li>动态绑定：方法</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>匿名对象</tag>
        <tag>内部类</tag>
        <tag>代码块</tag>
        <tag>包</tag>
        <tag>四种权限修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程</title>
    <url>/2021/08/25/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>清楚三个概念</strong></p>
<ul>
<li>进程</li>
<li>线程</li>
<li>在同一个时间点，一个cpu只能支持一个线程</li>
</ul>
<h3 id="一、进程"><a href="#一、进程" class="headerlink" title="一、进程"></a>一、进程</h3><h4 id="1-什么是进程"><a href="#1-什么是进程" class="headerlink" title="1.什么是进程"></a>1.什么是进程</h4><ul>
<li>程，只是一个静态的概念（内存）</li>
<li>程，就是一个app，exe（应用角度）</li>
<li>进程只是一个静态概念，对于java来说就是机器上的一个.class文件，机器上的.exe文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1:程序代码加载到代码区</span><br><span class="line">2:没有立刻执行，为进程开始做准本</span><br><span class="line">3:当jvm调用main方法时，进程开始执行</span><br><span class="line">4:真正执行的并不是进程，而是main方法</span><br></pre></td></tr></table></figure>



<h3 id="二、线程"><a href="#二、线程" class="headerlink" title="二、线程"></a>二、线程</h3><h4 id="1-什么是线程"><a href="#1-什么是线程" class="headerlink" title="1.什么是线程"></a>1.什么是线程</h4><ul>
<li><p>一个进程可以有很多个分支，每一个分支就被称为线程</p>
<ul>
<li>Java程序，默认就有一个线程，就是main方法，也被称为main线程</li>
</ul>
</li>
<li><p><strong>在同一个时间点上，一个CPU只能支持一个线程在执行</strong></p>
<ul>
<li>双CPU或双核，是确确实实的多线程</li>
</ul>
</li>
<li><p>Java如何实现多线程(类)</p>
<ul>
<li><strong><font color='#d15252'>Thread类</font></strong></li>
<li>Runnable接口</li>
</ul>
</li>
</ul>
<h3 id="三、Thread"><a href="#三、Thread" class="headerlink" title="三、Thread"></a>三、<font color='#d15252'>Thread</font></h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>包：java.lang.Thread<ul>
<li>不需要导包</li>
</ul>
</li>
<li>实现Runnable接口</li>
<li>修饰符：public </li>
<li>概述：管理Java中的线程</li>
</ul>
<h4 id="2-实现线程的步骤"><a href="#2-实现线程的步骤" class="headerlink" title="2.实现线程的步骤"></a>2.实现线程的步骤</h4><h5 id="Ⅰ-继承"><a href="#Ⅰ-继承" class="headerlink" title="Ⅰ.继承"></a>Ⅰ.继承</h5><ul>
<li>第一步：将一个类声明为Thread的子类</li>
<li>第二步：这个子类应该<font color='#d15252'>重写</font>Thread类的<font color='#d15252'>run方法</font></li>
<li>第三步：创建子类实例，调用star方法启动线程</li>
</ul>
<h5 id="Ⅱ-实现接口"><a href="#Ⅱ-实现接口" class="headerlink" title="Ⅱ.实现接口"></a>Ⅱ.实现接口</h5><ul>
<li>第一步：声明一个实现Runnable接口的类</li>
<li>第二步：实现run方法</li>
<li>第三步：创建实例</li>
</ul>
<h4 id="3-构造方法"><a href="#3-构造方法" class="headerlink" title="3.构造方法"></a>3.构造方法</h4><p><img src="https://i.loli.net/2021/08/12/D2KWuoqdQsXFCpH.png" alt="image-20210812095659082"></p>
<h5 id="①-Thread-String-name"><a href="#①-Thread-String-name" class="headerlink" title="① Thread(String name)"></a>① Thread(String name)</h5><ul>
<li>创建线程实例时，给线程名称赋值</li>
</ul>
<p><img src="https://i.loli.net/2021/08/12/7AS92gG3pNuYynq.png" alt="image-20210812172035560"></p>
<h4 id="4-成员方法"><a href="#4-成员方法" class="headerlink" title="4.成员方法"></a>4.成员方法</h4><h5 id="Ⅰ-run"><a href="#Ⅰ-run" class="headerlink" title="Ⅰ. run()"></a>Ⅰ.<font color='#d15252'> run()</font></h5><ul>
<li><p>核心</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>线程相关的代码写在该方法中，一般需要重写</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-start"><a href="#Ⅱ-start" class="headerlink" title="Ⅱ. start()"></a>Ⅱ. start()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动线程</li>
</ul>
<h5 id="Ⅲ-sleep"><a href="#Ⅲ-sleep" class="headerlink" title="Ⅲ. sleep()"></a>Ⅲ. sleep()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> m)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>让线程休眠x毫秒</li>
</ul>
<h5 id="Ⅳ-join"><a href="#Ⅳ-join" class="headerlink" title="Ⅳ. join()"></a>Ⅳ. join()</h5><ul>
<li><pre><code class="java">优先执行调用jion方法的线程
</code></pre>
</li>
</ul>
<h5 id="Ⅴ-其他方法"><a href="#Ⅴ-其他方法" class="headerlink" title="Ⅴ.其他方法"></a>Ⅴ.其他方法</h5><ul>
<li>getName（）获取名</li>
<li>currentThread（）返回正在执行的对象</li>
</ul>
<h4 id="5-Thread实现多线程细节问题-名字"><a href="#5-Thread实现多线程细节问题-名字" class="headerlink" title="5.Thread实现多线程细节问题(名字)"></a>5.Thread实现多线程<font color='#d15252'>细节问题</font>(名字)</h4><ul>
<li><p>同一个Thread实例对象，不能重复的调用start()方法</p>
<ul>
<li>重复开启线程，栈帧名一样，Jvm报异常</li>
</ul>
<p><img src="https://i.loli.net/2021/08/12/asy7Dlo3ICtPqEF.png" alt=" "></p>
</li>
<li><p><font color='#d15252'>获取</font>当前线程<font color='#d15252'>名称</font></p>
<ul>
<li><p>getName()方法</p>
<p><img src="https://i.loli.net/2021/08/12/3cdECOtSqeuy1vb.png" alt="image-20210812111038274"></p>
</li>
<li><p>currentThread()方法</p>
<ul>
<li>返回对当前正在执行的对象的引用</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/12/lQSzR98PrCTkAm1.png" alt="image-20210812110957410"></p>
</li>
</ul>
<ul>
<li><p>给线程<font color='#d15252'>起名字</font></p>
<ul>
<li><p>setName()方法</p>
<p><img src="https://i.loli.net/2021/08/12/C2i9ojrGXBcALJe.png" alt="image-20210812112815580"></p>
</li>
<li><p>带参构造</p>
<p><img src="https://i.loli.net/2021/08/12/hI6PnxSC3L1bior.png" alt="image-20210812113153552"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><font color='#d15252'>匿名内部类</font>的方式实现Thread多线程</p>
<ul>
<li><p>自定义类</p>
<ul>
<li>当run方法中的线程业务复杂，或者需要多次使用该线程类时</li>
</ul>
</li>
<li><p>匿名内部类</p>
<ul>
<li>当run方法中的线程业务只需要使用一次时</li>
</ul>
<p><img src="https://i.loli.net/2021/08/12/2ZDSdaAEcXPyCOL.png" alt="image-20210812113425179"></p>
</li>
</ul>
</li>
</ul>
<h3 id="四、Runnable接口"><a href="#四、Runnable接口" class="headerlink" title="四、Runnable接口"></a>四、Runnable接口</h3><ul>
<li>实现多线程的第二种方法</li>
</ul>
<h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>接口不能直接使用，需要通过子类实现</p>
</li>
<li><p>必须重写run方法</p>
<ul>
<li>run方法 — &gt; 线程业务</li>
</ul>
</li>
<li><p>通过查API可知，Thread是Runnable接口的已知实现类</p>
<ul>
<li>Thread类的带参构造方法中，可以传递一个实现Runnable接口对象参数</li>
</ul>
<p><img src="https://i.loli.net/2021/08/12/wheKM691QbXLU3Y.png" alt="image-20210812135021782"></p>
</li>
<li><p>因为不支持多继承，所以如果我们定义的类要继承其他类的功能时，又需要具备多线程的功能</p>
<ul>
<li>这时就不能用继承了，可以用Runnable接口</li>
</ul>
</li>
<li><p>包：java.lang包下</p>
<ul>
<li>不用导包就能使用 </li>
</ul>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><ul>
<li>接口无构造方法</li>
</ul>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li>run()方法 —-&gt; 实现类重写</li>
</ul>
<h4 id="4-使用"><a href="#4-使用" class="headerlink" title="4.使用"></a>4.使用</h4><ul>
<li><p>创建自定义类，实现接口Runnable</p>
</li>
<li><p>重写run()方法</p>
<p><img src="https://i.loli.net/2021/08/12/rRNX34PlcbgZK2F.png" alt="image-20210812135657924"></p>
</li>
<li><p>创建自定义类对象</p>
</li>
<li><p>调用Thread的构造方法（参数为Runnable）创建对象</p>
</li>
<li><p>start方法启动流</p>
<ul>
<li><img src="https://i.loli.net/2021/08/12/xejV7gKSTIidDah.png" alt="image-20210812135754014"></li>
</ul>
</li>
</ul>
<h4 id="5-Thread和Runnable的区别"><a href="#5-Thread和Runnable的区别" class="headerlink" title="5.Thread和Runnable的区别"></a>5.Thread和Runnable的区别</h4><ul>
<li>实现了数据的共享</li>
<li>避免了单继承的局限性</li>
</ul>
<h4 id="6-起名和获取名字"><a href="#6-起名和获取名字" class="headerlink" title="6.起名和获取名字"></a>6.起名和获取名字</h4><ul>
<li>和Thread基本一样<ul>
<li>SetName()设置名字</li>
</ul>
</li>
</ul>
<hr>
<h3 id="五、线程的特性"><a href="#五、线程的特性" class="headerlink" title="五、线程的特性"></a>五、线程的特性</h3><h4 id="1-线程的状态"><a href="#1-线程的状态" class="headerlink" title="1.线程的状态"></a>1.线程的<font color='#d15252'>状态</font></h4><h5 id="Ⅰ-新建-new"><a href="#Ⅰ-新建-new" class="headerlink" title="Ⅰ.新建(new)"></a>Ⅰ.新建(new)</h5><ul>
<li>创建对象时，线程处于new状态</li>
</ul>
<h5 id="Ⅱ-可运行-Runnable"><a href="#Ⅱ-可运行-Runnable" class="headerlink" title="Ⅱ.可运行(Runnable)"></a>Ⅱ.可运行(Runnable)</h5><ul>
<li>当调用start()方法时，进入Runnable状态<ul>
<li>（正在执行）</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-阻塞-Blocked"><a href="#Ⅲ-阻塞-Blocked" class="headerlink" title="Ⅲ.阻塞(Blocked)"></a>Ⅲ.阻塞(Blocked)</h5><ul>
<li><p>线程暂时停下就是 Blocaked状态</p>
<ul>
<li><p>可能造成线程堵塞状态</p>
<ul>
<li><p>IO流</p>
<ul>
<li>read()方法</li>
</ul>
</li>
<li><p>Scanner</p>
<p><img src="https://i.loli.net/2021/08/12/3zqxRUYo9Sj4Esd.png" alt="image-20210812154345259"></p>
</li>
</ul>
</li>
<li><p>提供造成阻塞状态的方法</p>
<ul>
<li>join()</li>
<li>wait()<ul>
<li>需要用try-catch处理异常</li>
<li>父类没有声明式抛出异常，子类就不能抛</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>notify()和notifyall()可以从阻塞状态返回正在执行Runnable状态</p>
</li>
</ul>
<h5 id="Ⅳ-等待-Waiting"><a href="#Ⅳ-等待-Waiting" class="headerlink" title="Ⅳ.等待(Waiting)"></a>Ⅳ.<font color='#d15252'>等待</font>(Waiting)</h5><ul>
<li><p>没有时间限制的等待</p>
</li>
<li><p>等另一个线程执行完后再执行</p>
</li>
</ul>
<h5 id="Ⅴ-休眠状态-Timed-Waiting"><a href="#Ⅴ-休眠状态-Timed-Waiting" class="headerlink" title="Ⅴ.休眠状态(Timed_Waiting)"></a>Ⅴ.<font color='#d15252'>休眠状态</font>(Timed_Waiting)</h5><ul>
<li>休眠状态<ul>
<li>sleep()</li>
</ul>
</li>
<li>达到指定时间线程再进行运行</li>
</ul>
<h5 id="Ⅵ-终止-Dead"><a href="#Ⅵ-终止-Dead" class="headerlink" title="Ⅵ.终止(Dead)"></a>Ⅵ.终止(Dead)</h5><ul>
<li>当线程运行完后自动结束<ul>
<li>Thread提供了stop()方法，但是已经<font color='#d15252'>弃用</font>了</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>什么是多线程？<ul>
<li>程序的除了main方法外，还有很多个分支</li>
</ul>
</li>
<li>实现多线程的两种方式？<ul>
<li>Thread/Runable  </li>
<li>区别：数据共享</li>
</ul>
</li>
<li>生命周期<ul>
<li>等待 wait join    </li>
<li>休眠 sleep join()</li>
<li>通过API提供的方法让线程声明周期的某个阶段，达到可控状态</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/2021/08/23/%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<h3 id="一、反射"><a href="#一、反射" class="headerlink" title="一、反射"></a>一、反射</h3><h4 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h4><ul>
<li><p>利用代码区中的数据（.class文件），去创建对象；<font color='#d15252'>省略new</font></p>
<ul>
<li>构造方法</li>
<li>成员变量</li>
<li>成员方法</li>
</ul>
</li>
<li><p>在代码区中存储的class并不是真正的class文件(物理)，而是一个虚拟的对象</p>
<ul>
<li><strong><font color='#d15252'>Class类</font></strong></li>
</ul>
</li>
</ul>
<h3 id="二、Class"><a href="#二、Class" class="headerlink" title="二、Class"></a>二、Class</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>泛型<ul>
<li>class类型很多，不固定</li>
</ul>
</li>
<li>修饰符：final <ul>
<li>不能被继承</li>
</ul>
</li>
<li>Class的实例表示正在运行的类和接口</li>
<li>管理class文件对象</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><p>无</p>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li><p>获取class文件对象的三种方式</p>
<ul>
<li><p>```java<br>方式一：通过Object类中的getClass()方法</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![image-<span class="number">20210817110933068</span>](https:<span class="regexp">//i</span>.loli.net<span class="regexp">/2021/</span><span class="number">08</span><span class="regexp">/17/m</span>1nypAo43bJFBIC.png)</span><br><span class="line"></span><br><span class="line">- ```java</span><br><span class="line">  方式二：类名.class获取到字节码文件对象(任意数据类型都具有静态的class属性)</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/23EShKfXxMYZW5y.png" alt="image-20210817111023597"></p>
</li>
<li><p>```java<br>方式三：forName(“String s”)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    - <span class="string">&quot; s &quot;</span> : 类的全路径</span><br><span class="line"></span><br><span class="line">    ![image-<span class="number">20210817111128606</span>](https:<span class="regexp">//i</span>.loli.net<span class="regexp">/2021/</span><span class="number">08</span><span class="regexp">/17/</span>M2Be6PaLC7wJEpH.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##### Ⅰ.forName()</span></span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static Class&lt;?&gt; forName(String className) </span><br><span class="line"><span class="regexp">//</span>返回与给定字符串名称的类或接口相关联的 Class对象。  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>className : 类的全路径</p>
</li>
<li><p>static 静态的，可以通过类名调用</p>
</li>
<li><p>Class&lt;?&gt;泛型</p>
</li>
</ul>
<h4 id="4-Class文件的内部成员"><a href="#4-Class文件的内部成员" class="headerlink" title="4.Class文件的内部成员"></a>4.<font color='#d15252'>Class文件</font>的内部成员</h4><ul>
<li>构造方法：Constructor</li>
<li>成员方法：Method</li>
<li>成员变量：Filed</li>
</ul>
<hr>
<h3 id="三、Constructor"><a href="#三、Constructor" class="headerlink" title="三、Constructor"></a>三、Constructor</h3><h4 id="1-获取Class构造方法"><a href="#1-获取Class构造方法" class="headerlink" title="1.获取Class构造方法"></a>1.获取Class构造方法</h4><h5 id="Ⅰ-getConstructors"><a href="#Ⅰ-getConstructors" class="headerlink" title="Ⅰ.getConstructors()"></a>Ⅰ.getConstructors()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors() </span><br><span class="line"><span class="comment">//返回一个包含 Constructor对象的数组， Constructor对象反映了由该 Class对象表示的类的所有公共构造函数。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型Constructor</li>
<li>只能获取到<font color='#d15252'>public修饰</font>的的构造方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/w7yi4ZhWfLXmFd9.png" alt="image-20210817135511279"></p>
<h5 id="Ⅱ-getDeclaredConstructors"><a href="#Ⅱ-getDeclaredConstructors" class="headerlink" title="Ⅱ.getDeclaredConstructors()"></a>Ⅱ.getDeclaredConstructors()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors() </span><br><span class="line"><span class="comment">//返回反映由该 Class对象表示的类声明的所有构造函数的 Constructor对象的数组。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取<font color='#d15252'>所有的</font>构造方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/u6dkrP9piQjFRSE.png" alt="image-20210817135520975"></p>
<h5 id="Ⅲ-getConstructor"><a href="#Ⅲ-getConstructor" class="headerlink" title="Ⅲ.getConstructor()"></a>Ⅲ.getConstructor()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Constructor对象，该对象反映由该 Class对象表示的类的指定公共构造函数。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>返回指定的构造方法（获取不到private修饰的）</p>
<p><img src="https://i.loli.net/2021/08/17/srX71Oml6BIaCoH.png" alt="image-20210817140725698"></p>
</li>
</ul>
<h5 id="Ⅳ-getDeclaredConstructor"><a href="#Ⅳ-getDeclaredConstructor" class="headerlink" title="Ⅳ. getDeclaredConstructor()"></a>Ⅳ. getDeclaredConstructor()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Constructor&lt;T&gt; getDeclaredConstructor​*(Class&lt;?&gt;... parameterTypes) </span><br><span class="line"><span class="comment">//返回一个 Constructor对象，该对象反映由此 Class对象表示的类或接口的指定构造函数。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定的构造方法，private修饰的也可以获取</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/ERUN6MXepbT4OfQ.png" alt="image-20210817140901110"></p>
<h4 id="2-利用构造方法创建Class实例"><a href="#2-利用构造方法创建Class实例" class="headerlink" title="2.利用构造方法创建Class实例"></a>2.利用构造方法<font color='#d15252'>创建Class实例</font></h4><h5 id="Ⅰ-newInstance-Object…-initargs"><a href="#Ⅰ-newInstance-Object…-initargs" class="headerlink" title="Ⅰ.newInstance(Object… initargs)"></a>Ⅰ.newInstance(Object… initargs)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br><span class="line"><span class="function"><span class="comment">//使用由此 Constructor对象表示的构造函数，使用指定的初始化参数来创建和初始化构造函数的声明类的新实例。  </span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/MVLpE5fQs8InJxm.png" alt="image-20210817204522820"></p>
<ul>
<li><p>带参传递一要取出的构造方法的参数类型，根据方法的重载，选择对应的构造方法</p>
</li>
<li><p>使用newInstance方法时，根据使用的构造方法进行传值</p>
</li>
<li><p>如果不重写toString()方法，则创建的实例化对象直接输出是一个地址值</p>
</li>
</ul>
<h3 id="四、Field"><a href="#四、Field" class="headerlink" title="四、Field"></a>四、Field</h3><h4 id="1-获取Class成员变量"><a href="#1-获取Class成员变量" class="headerlink" title="1.获取Class成员变量"></a>1.获取Class<font color='#d15252'>成员变量</font></h4><h5 id="Ⅰ-getFields"><a href="#Ⅰ-getFields" class="headerlink" title="Ⅰ.getFields()"></a>Ⅰ.getFields()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getFields() </span><br><span class="line"><span class="comment">//返回包含一个数组 Field对象反射由此表示的类或接口的所有可访问的公共字段 类对象。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出所有Public修饰的成员变量</li>
</ul>
<h5 id="Ⅱ-getDeclaredFields"><a href="#Ⅱ-getDeclaredFields" class="headerlink" title="Ⅱ.getDeclaredFields()"></a>Ⅱ.getDeclaredFields()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Field[] getDeclaredFields() </span><br><span class="line"><span class="comment">//返回的数组 Field对象反映此表示的类或接口声明的所有字段 类对象 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出所有成员变量，包括private修饰的</li>
</ul>
<h5 id="Ⅲ-getField-String-name"><a href="#Ⅲ-getField-String-name" class="headerlink" title="Ⅲ.getField(String name)"></a>Ⅲ.getField(String name)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Field对象，它反映此表示的类或接口的指定公共成员字段类对象 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出指定的public修饰的成员变量</li>
</ul>
<h5 id="Ⅳ-getDeclaredField-String-name"><a href="#Ⅳ-getDeclaredField-String-name" class="headerlink" title="Ⅳ.getDeclaredField(String name)"></a>Ⅳ.getDeclaredField(String name)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 Field对象，它反映此表示的类或接口的指定已声明字段类对象。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取指定的成员变量，private也可以取出</li>
</ul>
<h4 id="4-给Class成员变量赋值"><a href="#4-给Class成员变量赋值" class="headerlink" title="4.给Class成员变量赋值"></a>4.给Class成员变量<font color='#d15252'>赋值</font></h4><h5 id="Ⅰ-set-Object-obj-Object-value"><a href="#Ⅰ-set-Object-obj-Object-value" class="headerlink" title="Ⅰ.set(Object obj, Object value)"></a>Ⅰ.set(Object obj, Object value)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将指定的对象参数中由此 Field对象表示的字段设置为指定的新值。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取公共的成员变量</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/eo1Hp9LraVjMuOP.png" alt="image-20210817153600751"></p>
<ul>
<li>获取私有的成员变量</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/Hk8viMBxhaSXRAE.png" alt="image-20210817181152287"></p>
<ul>
<li>私有的成员变量赋值时需要暴力破解</li>
</ul>
<hr>
<h3 id="五、Method"><a href="#五、Method" class="headerlink" title="五、Method"></a>五、Method</h3><h4 id="1-获取Class成员方法"><a href="#1-获取Class成员方法" class="headerlink" title="1.获取Class成员方法"></a>1.获取Class成员方法</h4><h5 id="Ⅰ-getMethods"><a href="#Ⅰ-getMethods" class="headerlink" title="Ⅰ.getMethods()"></a>Ⅰ.getMethods()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Method[] getMethods() </span><br><span class="line"><span class="comment">//返回一个包含 方法对象的数组， 方法对象反映由该 Class对象表示的类或接口的所有公共方法，包括由类或接口声明的对象以及从超类和超级接口继承的类。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>取出class中的所有<font color='#d15252'>Public修饰的</font>成员方法</p>
</li>
<li><p>会取出包括父类中继承的方法</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/oniWLADSya2NE4e.png" alt="image-20210817155232292"></p>
<h5 id="Ⅱ-getDeclaredMethods"><a href="#Ⅱ-getDeclaredMethods" class="headerlink" title="Ⅱ.getDeclaredMethods()"></a>Ⅱ.getDeclaredMethods()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Methods[] getDeclaredMethods() </span><br><span class="line"><span class="comment">//返回一个包含 方法对象的数组， 方法对象反映由 Class对象表示的类或接口的所有声明方法，包括public，protected，default（package）访问和私有方法，但不包括继承方法。 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出class中的所有成员方法，包括private修饰的</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/8GmaHKep6rk35Bn.png" alt="image-20210817155435479"></p>
<h5 id="Ⅲ-getMethod-String-name-Class-lt-gt-…-parameterTypes"><a href="#Ⅲ-getMethod-String-name-Class-lt-gt-…-parameterTypes" class="headerlink" title="Ⅲ.getMethod(String name, Class&lt;?&gt;… parameterTypes)"></a>Ⅲ.getMethod(String name, Class&lt;?&gt;… parameterTypes)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Methods <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回一个 方法对象，该对象反映由该 Class对象表示的类或接口的指定公共成员方法。 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出class中的指定的Public修饰的成员方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/T5awcy9gsUKBGt2.png" alt="image-20210817155835845"></p>
<h5 id="Ⅳ-getDeclaredMethod-String-name-Class-lt-gt-…-parameterTypes"><a href="#Ⅳ-getDeclaredMethod-String-name-Class-lt-gt-…-parameterTypes" class="headerlink" title="Ⅳ.getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)"></a>Ⅳ.getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Methods <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> <span class="comment">//返回一个 方法对象，它反映此表示的类或接口的指定声明的方法 Class对象。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出指定的成员方法</li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/Rs8FvogtaNVdhib.png" alt="image-20210817160013845"></p>
<h4 id="2-使用成员方法"><a href="#2-使用成员方法" class="headerlink" title="2.使用成员方法"></a>2.使用成员方法</h4><h5 id="Ⅰ-invoke-Object-obj-Object…-args"><a href="#Ⅰ-invoke-Object-obj-Object…-args" class="headerlink" title="Ⅰ.invoke(Object obj, Object… args)"></a>Ⅰ.invoke(Object obj, Object… args)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//在具有指定参数的指定对象上调用此 方法对象表示的基础方法。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>将取出的<font color='#d15252'><strong>方法和对象绑定</strong></font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/17/bv7ZaMqpmjufntk.png" alt="image-20210817212251329"></p>
<hr>
<h3 id="六、AccessibleObject"><a href="#六、AccessibleObject" class="headerlink" title="六、AccessibleObject"></a>六、AccessibleObject</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>AccessibleObject是 Field、Constructor、Method的父类</li>
<li>作用：看你是否除了public修饰 （安全检查机制）</li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-setAccessible-boolean-f-暴力破解"><a href="#Ⅰ-setAccessible-boolean-f-暴力破解" class="headerlink" title="Ⅰ.setAccessible(boolean f) 暴力破解"></a>Ⅰ.setAccessible(boolean f) 暴力破解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAccessible</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//将此反射对象的 accessible标志设置为指示的布尔值。  </span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/17/foUpWaY9lqKbHv1.png" alt="image-20210817143740180"></p>
<h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><h4 id="1-泛型擦除"><a href="#1-泛型擦除" class="headerlink" title="1.泛型擦除"></a>1.泛型擦除</h4><ul>
<li><img src="https://i.loli.net/2021/08/17/3xXvCpmNDtfj4F2.png" alt="image-20210817171924074"></li>
</ul>
<h4 id="2-获取当前src目录"><a href="#2-获取当前src目录" class="headerlink" title="2.获取当前src目录"></a>2.获取当前src目录<img src="https://i.loli.net/2021/08/18/FBsTqWeIxmafXlR.png" alt="image-20210818093158387"></h4><ul>
<li><p>获取当前src目录</p>
</li>
<li><p>会出现取出字符串带双引号，forName无法识别的问题</p>
</li>
</ul>
<p><img src="C:\Users\GikH\AppData\Roaming\Typora\typora-user-images\image-20210818104512010.png" alt="image-20210818104512010"></p>
<p><img src="https://i.loli.net/2021/08/18/ToLq5lAhDfyrCRY.png" alt="image-20210818104515650"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化和反序列化\Properties类\瞬态关键字\打印流</title>
    <url>/2021/08/25/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-Properties%E7%B1%BB-%E7%9E%AC%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97-%E6%89%93%E5%8D%B0%E6%B5%81/</url>
    <content><![CDATA[<h3 id="一、Properties类"><a href="#一、Properties类" class="headerlink" title="一、Properties类"></a>一、Properties类</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>修饰符：public 可以直接使用</p>
</li>
<li><p>已知直接子类：Provider</p>
</li>
<li><p>包：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.Object </span><br><span class="line">java.util.Dictionary&lt;K,V&gt; </span><br><span class="line">java.util.Hashtable&lt;Object,Object&gt; </span><br><span class="line">java.util.Properties </span><br></pre></td></tr></table></figure>

<ul>
<li>需要导包使用</li>
</ul>
</li>
<li><p>常量：defaults</p>
<ul>
<li>属性列表，其中包含此属性列表中未找到的任何键的默认值</li>
</ul>
</li>
<li><p>继承关系</p>
<ul>
<li>Map：双列集合<ul>
<li>HashTable<ul>
<li>Properties（可以看作一个双列集合）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='#d15252'>可以和IO流结合，可以保存到流中或从流中加载</font></p>
<ul>
<li>实现本地化的存储<ul>
<li>之前的集合都是存放在内存中的，本地化存储可以实现存储到硬盘中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-无参构造"><a href="#Ⅰ-无参构造" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li><code>Properties()</code><ul>
<li>创建一个没有默认值的空属性列表</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-带参构造-用的不多"><a href="#Ⅱ-带参构造-用的不多" class="headerlink" title="Ⅱ.带参构造(用的不多)"></a>Ⅱ.带参构造(用的不多)</h5><ul>
<li><code>Properties(Properties defaults)</code><ul>
<li>创建具有指定默认值的空属性列表</li>
<li>传递一个Properties对象</li>
</ul>
</li>
</ul>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><h5 id="Ⅰ-setProperty-String-key-String-value"><a href="#Ⅰ-setProperty-String-key-String-value" class="headerlink" title="Ⅰ. setProperty(String key,String value)"></a>Ⅰ. setProperty(String key,String value)</h5><ul>
<li><p>实现添加功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setProperty</span> <span class="params">(String key,String value)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>调用<code>Hashtable</code>方法<code>put</code> <ul>
<li>直接使用父类put方法也可以，但是<font color='orange'>不推荐</font></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/63xLY4tgTPRQ1iF.png" alt="image-20210811104815624"></p>
<h5 id="Ⅱ-stringPropertyNames（）"><a href="#Ⅱ-stringPropertyNames（）" class="headerlink" title="Ⅱ. stringPropertyNames（）"></a>Ⅱ. stringPropertyNames（）</h5><ul>
<li><p>获取所有的键</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">stringPropertyNames</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值类型：Set<String> 集合</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/qVI75zYovs8dhUl.png" alt="image-20210811104848133"></p>
<h5 id="Ⅲ-getProperty"><a href="#Ⅲ-getProperty" class="headerlink" title="Ⅲ. getProperty"></a>Ⅲ. getProperty</h5><ul>
<li><p>通过键找值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>了解即可，用的不多</li>
</ul>
</li>
<li><p>如果找不到，则返回null</p>
</li>
</ul>
<h5 id="Ⅳ-字节-store-OutputStream-out-String-comments"><a href="#Ⅳ-字节-store-OutputStream-out-String-comments" class="headerlink" title="Ⅳ.字节 store(OutputStream out, String comments)"></a>Ⅳ.字节 store(OutputStream out, String comments)</h5><ul>
<li><p>写入输出流  — 字节流方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out, String comments)</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>out ：输出流</li>
<li>comments：属性列表的<font color='#d15252'>描述</font></li>
</ul>
</li>
<li><p>传递OutputStream的对象，文件名必须是.properties</p>
</li>
<li><p>异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IOException - 如果将此属性列表写入指定的输出流</span><br><span class="line">ClassCastException - 如果此 Properties对象包含任何不是 Strings键或值。 </span><br><span class="line">NullPointerException - 如果 out为空。 </span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/SrARVdKQJ34Wso5.png" alt="image-20210811112535575"></p>
<ul>
<li>需要关流</li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/WJrjwEZVoz3D4Ty.png" alt="image-20210811113043771"></p>
<h5 id="Ⅴ-字符store-Writer-w-String-comments"><a href="#Ⅴ-字符store-Writer-w-String-comments" class="headerlink" title="Ⅴ. 字符store(Writer w, String comments)"></a>Ⅴ. 字符store(Writer w, String comments)</h5><ul>
<li>写入输出流中（方法重载） — 字符流方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(Writer w,String comments)</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>comments：描述</li>
</ul>
<h5 id="Ⅵ-字节-load-InputStream-is"><a href="#Ⅵ-字节-load-InputStream-is" class="headerlink" title="Ⅵ. 字节 load(InputStream is)"></a>Ⅵ. 字节 load(InputStream is)</h5><ul>
<li><p>从输入字节流中读取键值对 —- 字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream is)</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>

<ul>
<li>is- 输入流</li>
</ul>
</li>
</ul>
<h5 id="Ⅶ-字符-load-Reader-r"><a href="#Ⅶ-字符-load-Reader-r" class="headerlink" title="Ⅶ.字符 load(Reader r)"></a>Ⅶ.字符 load(Reader r)</h5><ul>
<li><p>从输入字符流读取属性列表（关键字和元素对）—- 字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(Reader reader)</span><span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="二、序列化流和反序列化流（对象流）"><a href="#二、序列化流和反序列化流（对象流）" class="headerlink" title="二、序列化流和反序列化流（对象流）"></a>二、序列化流和反序列化流（对象流）</h3><ul>
<li>学框架有用</li>
</ul>
<h4 id="1-ObjectOutputStream序列化"><a href="#1-ObjectOutputStream序列化" class="headerlink" title="1.ObjectOutputStream序列化"></a>1.ObjectOutputStream序列化</h4><ul>
<li><p>序列化：<font color='#d15252'>将对象写入到文件</font>，这个过程被称为序列化 </p>
</li>
<li><p>使用</p>
<ul>
<li>构造方法</li>
<li>成员方法</li>
</ul>
</li>
<li><p>关流操作，先开后关</p>
</li>
</ul>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><ul>
<li><p>无参构造有protected修饰，不能使用</p>
</li>
<li><p>使用带参构造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream(OutputStream out)</span><br><span class="line"><span class="comment">//创建一个写入指定的OutputStream的ObjectOutputStream。  </span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/11/GIWT6MraYnL4hH2.png" alt="image-20210811134915997"></p>
</li>
</ul>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>writeObject() 将指定对象<font color='#d15252'>写入到流中</font></p>
<p><img src="https://i.loli.net/2021/08/11/XOl8Ck2VJKHEz9a.png" alt="image-20210811135654947"></p>
<p>对象类需实现Serializable具备实例化功能接口</p>
</li>
</ul>
<ul>
<li>Serializable：标志；如果实现了该接口，就意味子类具备了序列化</li>
</ul>
<h4 id="2-ObjectInpuStream反序列化"><a href="#2-ObjectInpuStream反序列化" class="headerlink" title="2.ObjectInpuStream反序列化"></a>2.ObjectInpuStream反序列化</h4><ul>
<li><p>反序列化：<font color='#d15252'>将文件中的对象读出</font>，这个过程被称为反序列化</p>
</li>
<li><p>构造方法</p>
<ul>
<li>同样，无参构造由Protected修饰，无法使用</li>
<li>带参构造，传递一个inputStream对象<ul>
<li>通过FileinputStream子类实例化</li>
</ul>
</li>
</ul>
</li>
<li><p>成员方法</p>
<p><img src="https://i.loli.net/2021/08/11/JBxWApyLTmX2ZR7.png" alt="image-20210811140646610"></p>
</li>
<li><p>关流</p>
</li>
</ul>
<h4 id="3-补充知识点"><a href="#3-补充知识点" class="headerlink" title="3.补充知识点"></a>3.补充知识点</h4><ul>
<li>序列化和反序列化找的是.class文件 //getClass()</li>
<li>类的串行版本：可以看作类的唯一的Id<ul>
<li>固定类uid：public static final long serialVersionUID = xxxL;</li>
<li>如果不固定uid ，每次更新类中数据，都会默认编译，产生新的uid<ul>
<li>如果要反序列化就需要重新先序列化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="三、瞬态关键字transient"><a href="#三、瞬态关键字transient" class="headerlink" title="三、瞬态关键字transient"></a>三、瞬态关键字transient</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h4><ul>
<li>在序列化时，如果有某个对象不想使用，可以加transient关键字修饰<ul>
<li>变成默认值</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/RC2PDV7LKdsXv19.png" alt="image-20210811150114172"></p>
<p><img src="https://i.loli.net/2021/08/11/495wxoltLkTqMJB.png" alt="image-20210811150129064"></p>
<h3 id="四、打印流"><a href="#四、打印流" class="headerlink" title="四、打印流"></a>四、打印流</h3><ul>
<li>更加方便的输出各种形式的数据</li>
</ul>
<h4 id="字节打印流PrintStream"><a href="#字节打印流PrintStream" class="headerlink" title="字节打印流PrintStream"></a>字节打印流PrintStream</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="https://i.loli.net/2021/08/11/gxY7Rv591rDzqtH.png" alt="image-20210811154349545"></p>
<h5 id="成员方法-1"><a href="#成员方法-1" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li>println()</li>
</ul>
<h4 id="字符打印流PrintWriter"><a href="#字符打印流PrintWriter" class="headerlink" title="字符打印流PrintWriter"></a>字符打印流PrintWriter</h4><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><p><img src="https://i.loli.net/2021/08/11/ZJfk9pGoFAsLvX6.png" alt="image-20210811153208397"></p>
<ul>
<li>带参传递一个File类型或OutputStream类型的参数</li>
</ul>
<p><img src="https://i.loli.net/2021/08/11/wrVdKyFi1S2xJkQ.png" alt="image-20210811153358399"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>Properties</tag>
        <tag>瞬态关键字</tag>
        <tag>打印流</tag>
      </tags>
  </entry>
  <entry>
    <title>异常和迭代器</title>
    <url>/2021/08/25/%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    <content><![CDATA[<h3 id="一、迭代器"><a href="#一、迭代器" class="headerlink" title="一、迭代器"></a>一、迭代器</h3><h4 id="1-next"><a href="#1-next" class="headerlink" title="1.next()"></a>1.next()</h4><ul>
<li>取数</li>
<li>先下一个</li>
<li>一次性</li>
</ul>
<h4 id="2-并发修改异常ConcurrentModificationException"><a href="#2-并发修改异常ConcurrentModificationException" class="headerlink" title="2.并发修改异常ConcurrentModificationException"></a>2.并发修改异常ConcurrentModificationException</h4><ul>
<li>当我们使用迭代器做遍历的时候，不能破坏集合的内部结构<ul>
<li>一旦有<font color='#d15252'>破坏集合内部结构的操作就会报错</font></li>
</ul>
</li>
</ul>
<h4 id="3-练习题：斗地主"><a href="#3-练习题：斗地主" class="headerlink" title="3.练习题：斗地主"></a>3.练习题：斗地主</h4><ul>
<li>做四个容器<ul>
<li>分别存玩家和底牌</li>
</ul>
</li>
<li>再做一个容器，存所有扑克牌</li>
</ul>
<h4 id="3-静态导入"><a href="#3-静态导入" class="headerlink" title="3.静态导入"></a>3.静态导入</h4><ul>
<li>在导包过程中，我们可以直接导入静态部分，这样的话某个类的静态成员就可以直接使用了<ul>
<li>看别人的源码时用的比较多</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/05/TdlWUHFeZVRAPLj.png" alt="image-20210805135205026"></p>
<h3 id="二、异常"><a href="#二、异常" class="headerlink" title="二、异常"></a>二、<font color='#d15252'>异常</font></h3><h4 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常"></a>1.什么是异常</h4><ul>
<li>异常就是程序出现了不正常的现象</li>
</ul>
<h4 id="2-Java如何形容异常？"><a href="#2-Java如何形容异常？" class="headerlink" title="2.Java如何形容异常？"></a>2.Java如何形容异常？</h4><p>但凡涉及到Java内的内容，都要用类来处理，所以异常最顶层的类</p>
<ul>
<li><font color='#d15252'><strong>Throwable</strong></font>类<ul>
<li>是Java语言中所有错误和异常的超类</li>
</ul>
</li>
</ul>
<h4 id="3-Throwable类"><a href="#3-Throwable类" class="headerlink" title="3.Throwable类"></a>3.Throwable类</h4><ul>
<li><p><font color='#d15252'>Throwable</font></p>
<ul>
<li>error（错误）一般不会遇到，因为它表示严重的问题</li>
<li>exception（异常）<ul>
<li>编译时异常<ul>
<li>其他类都是编译时异常</li>
</ul>
</li>
<li>运行时异常<ul>
<li>RuntimeException在运行时</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/05/1BUKNkQWzOFSgA7.png" alt="image-20210805141331385"></p>
</li>
<li><p><code>RuntimeException</code>是在Java虚拟机的正常操作期间可以抛出的异常的超类。 </p>
</li>
</ul>
<h4 id="4-编译时异常和运行时异常"><a href="#4-编译时异常和运行时异常" class="headerlink" title="4.编译时异常和运行时异常"></a>4.编译时异常和运行时异常</h4><h5 id="Ⅰ-编译时异常"><a href="#Ⅰ-编译时异常" class="headerlink" title="Ⅰ.编译时异常"></a>Ⅰ.编译时异常</h5><ul>
<li>编译时异常都是Exception的子类，程序卡在编译阶段</li>
<li>出现这类的异常，必须<font color='#d15252'>显示处理</font>（调试代码），否则程序就会出现问题，无法编译</li>
</ul>
<h5 id="Ⅱ-运行时异常"><a href="#Ⅱ-运行时异常" class="headerlink" title="Ⅱ.运行时异常"></a>Ⅱ.运行时异常</h5><ul>
<li>都是RuntimeException的子类，卡在了程序的运行时</li>
<li>必须得修改代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="comment">//运行时异常</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">System.out.println(arr[<span class="number">100</span>]);</span><br><span class="line"><span class="comment">//以上代码可知，编译时是没有错误的</span></span><br><span class="line"><span class="comment">//但运行时报错 : java.lang.ArrayIndexOutOfBoundsException:</span></span><br><span class="line"><span class="comment">//由查看API可知，则异常是RuntimeException下的异常，所以确定它是运行时异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//编译时异常演示</span></span><br><span class="line">      SimpleDateFormat sim = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">      Date date = sim.parse(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="comment">//由以上代码可知，在编译时期就会抛出异常</span></span><br><span class="line"><span class="comment">//Demo2.java:16: 错误: 未报告的异常错误ParseException; 必须对其进行捕获或声明以便抛出</span></span><br><span class="line"><span class="comment">//并且此异常在Throwable 包下，与runtimeException无关。所以时运行时异常</span></span><br></pre></td></tr></table></figure>

<h4 id="5-异常的处理机制"><a href="#5-异常的处理机制" class="headerlink" title="5.异常的处理机制"></a>5.异常的处理机制</h4><h5 id="Ⅰ-默认处理机制（面试问）"><a href="#Ⅰ-默认处理机制（面试问）" class="headerlink" title="Ⅰ.默认处理机制（面试问）"></a>Ⅰ.<font color='#d15252'>默认处理机制</font>（面试问）</h5><ul>
<li>当程序遇到异常时<ul>
<li>将异常抛给调用者（jvm)<ul>
<li>一层一层的抛，最后抛给jvm</li>
</ul>
</li>
<li>jvm会默认的去做相应的处理<ul>
<li><font color='#d15252'>new 异常对象</font> ，产生异常名称、原因，以及出现的位置等信息输出在控制台</li>
<li>停掉程序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Ⅱ-throws-声明式-方式处理异常"><a href="#Ⅱ-throws-声明式-方式处理异常" class="headerlink" title="Ⅱ.throws(声明式)方式处理异常"></a>Ⅱ.throws(声明式)方式处理异常</h5><ul>
<li><p>写在方法的声明部分()</p>
<ul>
<li><p>```java<br>public void method()throws 异常类名</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="bullet">-</span> 给开发者看的，一般也不用</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 特点</span><br><span class="line"></span><br><span class="line"><span class="bullet">  -</span> 处理机制（还是默认的处理机制）</span><br><span class="line"><span class="bullet">  -</span> 为了给以后的调用者看（开发角度）</span><br><span class="line"><span class="bullet">  -</span> <span class="strong">**<span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;#d15252&#x27;</span>&gt;</span></span>运行时异常可以不用声明，编译时异常必须写<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span>**</span>（面试）</span><br><span class="line"></span><br><span class="line"><span class="section">##### Ⅲ.throw抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> throw new 异常类 ：方法内</span><br><span class="line"><span class="bullet">  -</span> 如果是运行时异常，不用在方法上去声明异常</span><br><span class="line"><span class="bullet">  -</span> 如果是编译时异常，必须要在方法上声明</span><br><span class="line"><span class="bullet">  -</span> 从结果上看，和默认机制是一样的，原理是不一样的，throw是自己将异常抛出(直接到控制台上)</span><br><span class="line"><span class="bullet">  -</span> 没有交给jvm，直接自己就抛出异常</span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; Ⅱ.throws声明式异常和Ⅲ.throw抛异常	适用于开发者的角度</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; throw</span></span><br><span class="line"><span class="quote">&gt;</span></span><br><span class="line"><span class="quote">&gt; - 编译时：有声明不一定有抛出，但是有抛出必须有声明</span></span><br><span class="line"><span class="quote">&gt; - 运行时：声明，抛出</span></span><br><span class="line"></span><br><span class="line">![<span class="string">image-20210805170703594</span>](<span class="link">https://i.loli.net/2021/08/05/smAEunHvaFqhJkS.png</span>)</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 格式： throw new 异常类型（）；</span><br><span class="line"></span><br><span class="line"><span class="section">##### Ⅳ.try...catch处理异常机制</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 格式</span><br><span class="line"></span><br><span class="line">  <span class="code">```java</span></span><br><span class="line"><span class="code">  try&#123;</span></span><br><span class="line"><span class="code">  	可能出现异常的语句</span></span><br><span class="line"><span class="code">  &#125;catch(异常类类型 变量名)&#123;</span></span><br><span class="line"><span class="code">      异常的处理</span></span><br><span class="line"><span class="code">  &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>以后做开发使用或测试的时候，有异常建议使用(throw/throws)</p>
</li>
<li><p>在调用方法时遇到异常，建议使用try catch</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> b =i/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="number">111</span>);	<span class="comment">//没有执行，异常跳入catch执行完，结束</span></span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除数为0了&quot;</span>);</span><br><span class="line">        <span class="comment">//输出异常信息</span></span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        一定会执行的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当一个程序有多个错误时</p>
<ul>
<li>catch可以写多个，但要注意异常类型，小的放上面的catch，大的放在下面</li>
</ul>
</li>
<li><p>运行步骤：</p>
<ul>
<li>当进入try..catch中，先执行try()中有可能出现异常的问题</li>
<li>如果遇到异常语句<ul>
<li>跳入catch执行处理异常语句</li>
<li>catch语句执行完后，执行finally内的语句</li>
<li>结束try..catch</li>
</ul>
</li>
<li>执行之后的代码</li>
</ul>
</li>
</ul>
<h5 id="Ⅴ-细节问题"><a href="#Ⅴ-细节问题" class="headerlink" title="Ⅴ.细节问题"></a>Ⅴ.细节问题</h5><ul>
<li>可以多层catch，但是大的类型一定要在最底层</li>
<li>采用try chach，异常代码处理完成后，不影响其他代码的执行</li>
<li>如果有finally，不管异常是否触发，一定会走（IO）</li>
</ul>
<h4 id="6-查看异常信息"><a href="#6-查看异常信息" class="headerlink" title="6.查看异常信息"></a>6.查看异常信息</h4><p><img src="https://i.loli.net/2021/08/05/yh1b53ZoBeH7dmE.png" alt="image-20210805144413257"></p>
<ul>
<li>第一行是异常的类名<ul>
<li>第一行<code>：</code>后的信息是异常产生的原因</li>
</ul>
</li>
<li>第二行是异常产生的原始位置</li>
<li>第三行是异常产生的位置</li>
</ul>
<h4 id="7-Throwable的成员方法"><a href="#7-Throwable的成员方法" class="headerlink" title="7.Throwable的成员方法"></a>7.Throwable的成员方法</h4><table>
<thead>
<tr>
<th>成员方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><font color='#d15252'>printStackTrace()</font></td>
<td>将此throwable和其追溯打印到标准错误流</td>
</tr>
<tr>
<td>getMessage()</td>
<td>返回此throwable的详细消息字符串</td>
</tr>
<tr>
<td>toString()</td>
<td>简短的描述信息</td>
</tr>
</tbody></table>
<ul>
<li>printStackTrace() 开发中用的比较多，因为他会对异常信息进行溯源，比较详细</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    System.out.println(e.getMessage());</span><br><span class="line">    System.out.println(e.toString());</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/ by zero	<span class="comment">//getMessage</span></span><br><span class="line">java.lang.ArithmeticException: / by zero	<span class="comment">//toString</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line">java.lang.ArithmeticException: / by zero	</span><br><span class="line">	at 异常.Demo7.main(Demo7.java:<span class="number">6</span>)<span class="comment">//printStackTrace</span></span><br></pre></td></tr></table></figure>



<h4 id="8-自定义异常信息"><a href="#8-自定义异常信息" class="headerlink" title="8.自定义异常信息"></a>8.自定义异常信息</h4><ul>
<li><p>步骤：</p>
<ul>
<li><p>在有可能出现异常的方法中，实现判断，如果触发异常，就使用throw new 异常类型（） 触发异常</p>
<p><img src="https://i.loli.net/2021/08/05/3LZyG78TbpfcEth.png" alt="image-20210805171208739"></p>
</li>
<li><p>异常类型需要自己自定义一个类，通过继承，实现处理异常的能力</p>
<p><img src="https://i.loli.net/2021/08/05/RgbNl7y8MALHWZX.png" alt="image-20210805171219308"></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>异常</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>方法</title>
    <url>/2021/08/25/%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、方法-函数"><a href="#一、方法-函数" class="headerlink" title="一、方法(函数)"></a>一、<font color='#d15252'>方法</font>(函数)</h3><h4 id="1-什么是方法"><a href="#1-什么是方法" class="headerlink" title="1.什么是方法"></a>1.什么是方法</h4><ul>
<li>就是对业务的一种封装，完成指定业务功能的代码块<ul>
<li>封装：就是业务的容器</li>
</ul>
</li>
<li>编程理论到实际</li>
</ul>
<h4 id="2-如何定义方法"><a href="#2-如何定义方法" class="headerlink" title="2.如何定义方法"></a>2.如何定义方法</h4><ul>
<li><p>位置：方法与方法之间是一种并列关系</p>
</li>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">a:方法名</span><br><span class="line"><span class="keyword">public</span>、<span class="keyword">static</span>：修饰符</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型 参数名,...）&#123;</span><br><span class="line">	方法体；</span><br><span class="line">	<span class="keyword">return</span>返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[^修饰符]: 暂时先用public static </p>
</li>
</ul>
<ul>
<li><p>[^实际参数]: 实际参与运算的</p>
</li>
<li><p>[^形式参数]: 就是方法定义上的，用于接收实际参数</p>
</li>
</ul>
<p>  [^return]: <font color='#d15252'>结束方法，并带回返回值给调用者</font></p>
<ul>
<li><p>参数传递过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据的角度来看</span><br><span class="line">	-----&gt;方法和方法之间是相互独立的</span><br><span class="line">	A();---B();</span><br><span class="line">	-----&gt;在调用方法时，A方法传递数值,B方法接收数值</span><br><span class="line">	-----&gt;所以在定义B方法时，就需要将内存空间开辟好（参数类型 参数名）</span><br><span class="line">    (参数就是变量)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-方法的注意事项"><a href="#3-方法的注意事项" class="headerlink" title="3.方法的注意事项"></a>3.方法的<font color='#d15252'>注意事项</font></h4><ul>
<li>要写一个方法，首先明确返回值类型，参数列表</li>
<li>方法不调用不执行</li>
<li>方法之间是平级关系，不能嵌套</li>
<li>方法定义参数时，用“，”隔开</li>
</ul>
<h4 id="4-方法的调用"><a href="#4-方法的调用" class="headerlink" title="4.方法的调用"></a>4.方法的<font color='#d15252'>调用</font></h4><ul>
<li>直接调用：<code>方法名();</code><ul>
<li>最方便，没有返回值</li>
</ul>
</li>
<li>输出调用：<code>System.out.println(方法名());</code><ul>
<li>想要第一时间看到方法计算结果时(不推荐，因为不一定要将结果输出)<ul>
<li>void方法不能用</li>
</ul>
</li>
</ul>
</li>
<li>赋值调用：<code>int a = add();</code><ul>
<li>void方法不能用</li>
<li>比较繁琐，但是最灵活</li>
</ul>
</li>
</ul>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><ul>
<li>当我们在定义方法时，如果最终的结果值，是直接输出的，返回值是void </li>
</ul>
<h4 id="6-练习"><a href="#6-练习" class="headerlink" title="6.练习"></a>6.练习</h4><ul>
<li><p>1.计算所有三位数水仙花数</p>
<ul>
<li><p>创建项目，测试环境</p>
</li>
<li><p>需求分析：</p>
<ul>
<li>定义一个方法完成计算水仙花的业务</li>
</ul>
</li>
<li><p>定义方法：</p>
<ul>
<li>方法位置并列</li>
<li>修饰符：public static</li>
<li>返回值类型：由最后代码可知，水仙花数是直接输出的，所以不需要返回值，返回值类型是void</li>
<li>方法名：shui();</li>
</ul>
</li>
<li><p>方法中完成计算水仙花数</p>
<ul>
<li>for循环遍历所有三位数</li>
<li>定义三个变量，分别取模，取出个位十位百位</li>
<li>if循环判断，三个变量的三次方相加是否等于i</li>
<li>如果判断成功，直接输出</li>
</ul>
</li>
<li><p>main方法中，直接调用shui();方法</p>
<ul>
<li><p>输出调用（有返回值时）    </p>
</li>
<li><p>赋值调用（有返回值，需要重复使用时）</p>
<hr>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2.键盘录入3个数，比较大小，输出最大的那个数</p>
<ul>
<li><p>创建项目，测试环境</p>
</li>
<li><p>需求分析</p>
<ul>
<li>定义一个方法，实现业务完成录入数据，比较大小，返回值或直接输出</li>
</ul>
</li>
<li><p>定义方法</p>
<ul>
<li>方法位置并列</li>
<li>修饰符：public static </li>
<li>返回值类型：由最后代码决定<ul>
<li>如果直接输出，则返回值用void</li>
<li>如果return返回值，则在main方法中输出调用，或赋值调用，返回值类型为int</li>
</ul>
</li>
<li>方法名：demo();</li>
</ul>
</li>
<li><p>在方法中完成业务</p>
<ul>
<li><p>Scanner键盘录入三步：</p>
<ul>
<li>导包 <code>import java.util.Scanner;</code></li>
<li>加载Scanner进内存 <code>Scanner sc = new Scanner(System.in);</code></li>
<li>定义变量保存键盘录入数据 <code>int a = sc.nextInt();</code></li>
</ul>
</li>
<li><p>比较键盘录入的三个数的大小</p>
<ul>
<li><p>三目运算符，比较三个数大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = (a&gt;b)?((a&gt;c)?a:c):((b&gt;c)?b:c);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>最后输出最大值到控制台</p>
<ul>
<li><p>直接调用：不设置返回值，直接在方法中System输出最大值，在main方法中直接调用方法即可</p>
</li>
<li><p>输出调用：设置返回值，在main方法中，System输出调用方法</p>
</li>
<li><p>赋值调用：设置返回值，在main方法中，定义一个变量，保存方法的返回值 <code>int max = demo();</code>，再直接输出max到控制台（数据可以重复利用）</p>
<hr>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>3.键盘录入三个数，求平均数</p>
<ul>
<li>创建工程，测试环境</li>
<li>需求分析<ul>
<li>定义一个方法完成业务</li>
</ul>
</li>
<li>定义方法<ul>
<li>修饰符：public static </li>
<li>返回值类型：<ul>
<li>方法中直接输出平均数，则没有返回值，返回值类型为void</li>
<li>方法中若设置一个变量并return返回，则返回值类型为int</li>
</ul>
</li>
<li>方法名demo();</li>
</ul>
</li>
<li>完成方法中的业务<ul>
<li>Scanner键盘录入三步：导包、加载Scanner进内存，定义变量存储键盘录入数据</li>
<li>定义一个变量，将键盘录入数据相加求平均数并保存<ul>
<li><code>int var = (a+b+c)/3</code></li>
</ul>
</li>
<li>调用<ul>
<li>直接调用：在方法中完成输出，main方法中调用方法即可</li>
<li>输出调用：方法中定义return返回值，main方法中，输出调用方法即可</li>
<li>赋值调用：方法中定义return返回值，main方法中，定义变量存储返回值，（可以重复操作数据)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>  4.键盘录入三个数，并保存在数组中</p>
<ul>
<li>创建项目，测试环境</li>
<li>需求分析：<ul>
<li>创建一个方法，完成键盘录入，存入数组，并保存至数组中</li>
</ul>
</li>
<li>创建方法：<ul>
<li>位置：并列关系</li>
<li>修饰符：public static </li>
<li>返回值：int[]数组类型或直接调用void</li>
</ul>
</li>
<li>完成方法中的业务<ul>
<li>创建一个数组</li>
<li>键盘录入三个数据并储存</li>
<li>将键盘录入的数据存入数组中</li>
<li>遍历数组</li>
<li>调用<ul>
<li>直接调用：<code>ar();</code> 返回值void</li>
<li>输出调用：return arr; 返回值int[] ,调用 <code>System.out.println(ar());</code></li>
<li>赋值调用：创建数组类型接收数据 <code>int[] arr = ar();</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-方法的传参"><a href="#7-方法的传参" class="headerlink" title="7.方法的传参"></a>7.方法的传参</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名（参数类型<span class="number">1</span> 参数名<span class="number">1</span>,参数类型<span class="number">2</span> 参数名<span class="number">2.</span>...）&#123;</span><br><span class="line">	方法体；</span><br><span class="line">	<span class="keyword">return</span>返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>调用方法时，需要在()中写入对应数据类型的值</p>
</li>
<li><p>创建项目，测试环境</p>
</li>
<li><p>创建方法</p>
<ul>
<li>位置：并列</li>
<li>格式：修饰符 返回值类型 方法名（）{ }</li>
</ul>
</li>
<li><p>需求分析</p>
</li>
<li><p>键盘录入</p>
</li>
<li><p>实现打印</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>方法</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>数组实现数据增查删改和数据库操作</title>
    <url>/2021/08/25/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%A2%9E%E6%9F%A5%E5%88%A0%E6%94%B9%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="一、综合案例：实现商品菜单，数据增查删改"><a href="#一、综合案例：实现商品菜单，数据增查删改" class="headerlink" title="一、综合案例：实现商品菜单，数据增查删改"></a>一、综合案例：实现商品菜单，数据增查删改</h3><h5 id="1-创建工程，测试环境"><a href="#1-创建工程，测试环境" class="headerlink" title="1.创建工程，测试环境"></a>1.创建工程，测试环境</h5><h5 id="2-前奏：实现数据的加载"><a href="#2-前奏：实现数据的加载" class="headerlink" title="2.前奏：实现数据的加载"></a>2.前奏：实现数据的加载</h5><ul>
<li>变量 数组 集合 数据库 （暂时用数组）<ul>
<li>数据类型[] 变量名 = new 数据类型[空间长度]</li>
</ul>
</li>
</ul>
<h5 id="3-需求分析："><a href="#3-需求分析：" class="headerlink" title="3.需求分析："></a>3.需求分析：</h5><ul>
<li><p>菜单：6条输出语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;1.查看商品编号&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;2.修改商品编号&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3.增加商品编号&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;4.删除商品编号&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;5.退出&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;6.请您选择1---5&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>实现交互：即键盘录入数据，使用Scanner三个步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> a = sc.nextInt();</span><br></pre></td></tr></table></figure></li>
<li><p>实现菜单可以重复选择：利用for或者while死循环</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(;;)</span></span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="title">while</span><span class="params">(true)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现菜单的选择：使用if判断语句，判断录入的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现查看功能&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现修改功能&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">3</span>)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现增加功能&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">4</span>)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现删除功能&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">5</span>)&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;退出&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现查看功能：for循环实现遍历数组、if判断不是0再输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;	</span><br><span class="line">	<span class="keyword">if</span> (arr[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;商品的编号:&quot;</span>+arr[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现修改功能：用for循环查看数组，if判断选择要修改的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i]==b)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;请输入修改后的编号&quot;</span>);</span><br><span class="line">		arr[i]=sc.nextInt();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现增加功能：用for+if，将录入数据增加到0上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入要增加的商品编号&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr[i]==<span class="number">0</span>)&#123;</span><br><span class="line">		arr[i]=x;</span><br><span class="line">		i = arr.length; <span class="comment">//跳出循环</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现删除功能：用for+if，匹配和录入数据相同的索引，更改值为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入要删除的商品编号&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> g = sc.nextInt();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr[i]==g)&#123;</span><br><span class="line">			arr[i]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="4-代码："><a href="#4-代码：" class="headerlink" title="4.代码："></a>4.代码：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建工程并测试环境</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">	</span>&#123;	</span><br><span class="line">		<span class="comment">//实现交互效果，需要键盘录入数据</span></span><br><span class="line">		<span class="comment">//键盘录入数据三步，导包，加载进内存，保存录入数据</span></span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">//定义布尔类型变量，控制循环结束</span></span><br><span class="line">		<span class="keyword">boolean</span> f =<span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//数据加载</span></span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">		arr[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">		arr[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">		arr[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">		<span class="comment">//实现可以重复选择菜单</span></span><br><span class="line">		<span class="keyword">for</span> (;f; )</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> j =<span class="number">0</span>;</span><br><span class="line">		<span class="comment">//需求分析：菜单页面即输出语句</span></span><br><span class="line">		System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| 1.查看商品编号 ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| 2.修改商品编号 ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| 3.增加商品编号 ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| 4.删除商品编号 ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| 5.退出系统     ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|| (请您选择1-5)  ||&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">		<span class="comment">//实现菜单的选择</span></span><br><span class="line">		<span class="keyword">if</span> (a==<span class="number">1</span>)&#123;</span><br><span class="line">			<span class="comment">//循环输出遍历数组</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">				&#123;	<span class="comment">//if语句判断不是0再输出</span></span><br><span class="line">					<span class="keyword">if</span> (arr[i]!=<span class="number">0</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;商品的编号:&quot;</span>+arr[i]);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">&quot;===查看成功===&quot;</span>);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">2</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;请输入要修改的商品编号&quot;</span>);</span><br><span class="line">				<span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">				<span class="comment">//for+if判断并选择到需要修改的数据</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (arr[i]==b)</span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;请输入修改后的编号&quot;</span>);</span><br><span class="line">						arr[i]=sc.nextInt();</span><br><span class="line">						i = arr.length;</span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]!=b)</span><br><span class="line">					&#123;</span><br><span class="line">						j++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (arr.length==j)</span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;您要修改的编号不存在&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">3</span>)&#123;</span><br><span class="line">				<span class="comment">//实现增加功能</span></span><br><span class="line">				System.out.println(<span class="string">&quot;请输入要增加的商品编号&quot;</span>);</span><br><span class="line">				<span class="keyword">int</span> x = sc.nextInt();</span><br><span class="line">				<span class="comment">//for+if查询判断，将录入数据加载到0上</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//判断如果商品编号已存在，提示添加失败，跳出循环</span></span><br><span class="line">					<span class="keyword">if</span> (arr[i]==x)</span><br><span class="line">					&#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;您输入的商品编号已存在&quot;</span>);</span><br><span class="line">					i=arr.length;<span class="comment">//跳出循环</span></span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]==<span class="number">0</span>)   <span class="comment">//如果不存在，判断为0的数据，添加</span></span><br><span class="line">						&#123;</span><br><span class="line">							arr[i]=x;</span><br><span class="line">							i = arr.length; <span class="comment">//跳出循环</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">4</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;请输入要删除的商品编号&quot;</span>);</span><br><span class="line">				<span class="keyword">int</span> g = sc.nextInt();</span><br><span class="line">				<span class="comment">//实现删除功能</span></span><br><span class="line">				<span class="comment">//for+if判断</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (arr[i]==g)</span><br><span class="line">					&#123;</span><br><span class="line">						arr[i]=<span class="number">0</span>;</span><br><span class="line">						System.out.println(<span class="string">&quot;===删除成功===&quot;</span>);</span><br><span class="line">						i =arr.length;<span class="comment">//跳出循环</span></span><br><span class="line">					&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]!=g)&#123;</span><br><span class="line">						j++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (arr.length==j)</span><br><span class="line">					&#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;你要删除的商品编号不存在&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(a==<span class="number">5</span>)&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;您已成功退出&quot;</span>);</span><br><span class="line">				f = <span class="keyword">false</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;===输入错误，请选择1-5===&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二、使用数据库-Mysql"><a href="#二、使用数据库-Mysql" class="headerlink" title="二、使用数据库(Mysql)"></a>二、使用数据库(Mysql)</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database 数据库名称</span><br></pre></td></tr></table></figure>


<h4 id="2-创建表格"><a href="#2-创建表格" class="headerlink" title="2. 创建表格"></a>2. 创建表格</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">	列名 数据类型,</span><br><span class="line">	列名 数据类型,</span><br><span class="line">    ....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3. 插入数据"></a>3. 插入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 (列名,...) values(数据,数据);</span><br></pre></td></tr></table></figure>

<h4 id="4-更新数据"><a href="#4-更新数据" class="headerlink" title="4.更新数据"></a>4.更新数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updata 表名 set 字段 = 数值;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 字段 = 数值 WHERE 字段=数值（选择）;</span><br></pre></td></tr></table></figure>

<h4 id="5-删除数据"><a href="#5-删除数据" class="headerlink" title="5.删除数据"></a>5.删除数据</h4><ul>
<li><p>删除全部数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Delete From 表名;</span><br></pre></td></tr></table></figure></li>
<li><p>删除指定数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Delete From 表名 WHERE 字段 = 数值;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-查询数据"><a href="#6-查询数据" class="headerlink" title="6.查询数据"></a>6.查询数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM 表名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>增查删改</tag>
        <tag>案例</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>流程控制和键盘录入</title>
    <url>/2021/08/25/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%92%8C%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5/</url>
    <content><![CDATA[<h3 id="一、表达式、语句体、块"><a href="#一、表达式、语句体、块" class="headerlink" title="一、表达式、语句体、块"></a>一、表达式、语句体、块</h3><h4 id="1-什么是表达式？"><a href="#1-什么是表达式？" class="headerlink" title="1.什么是表达式？"></a>1.什么是表达式？</h4><ul>
<li>一个变量、运算符、或者方法构成的一个新的构建体（一条符合Java语言的代码）</li>
<li>最终的结果是单个值</li>
</ul>
<h4 id="2-什么是语句体"><a href="#2-什么是语句体" class="headerlink" title="2.什么是语句体"></a>2.什么是语句体</h4><ul>
<li>一条语句构成了一个完整的执行单元</li>
<li>java语句中，节点是：结束</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a =  <span class="number">5</span>; <span class="comment">//语句体</span></span><br></pre></td></tr></table></figure>

<h4 id="3-块"><a href="#3-块" class="headerlink" title="3.块"></a>3.块</h4><ul>
<li>{  }</li>
</ul>
<h3 id="二、控制流程语句"><a href="#二、控制流程语句" class="headerlink" title="二、控制流程语句"></a>二、控制流程语句</h3><h4 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h4><ul>
<li>按照代码边学顺序，自上而下运行</li>
</ul>
<h4 id="2-选择结构"><a href="#2-选择结构" class="headerlink" title="2.选择结构"></a>2.选择结构</h4><h5 id="①-IF-语句"><a href="#①-IF-语句" class="headerlink" title="① IF 语句"></a>① IF 语句</h5><ul>
<li><p>格式一 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (比较表达式)&#123;</span><br><span class="line">    <span class="comment">//比较表达式的值为boolean类型 ture或false</span></span><br><span class="line">	执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>格式二</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(比较表达式)&#123;</span><br><span class="line">    代码体    <span class="comment">//(ture)执行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    代码体	   <span class="comment">//(false)执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>格式三</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(比较表达式)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(比较表达式<span class="number">2</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(比较表达式<span class="number">3</span>)&#123;	<span class="comment">//一旦有true即运行相应代码并结束</span></span><br><span class="line">    ...</span><br><span class="line">&#125;   ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">else</span>&#123;		<span class="comment">//如果全是false，则执行else内的内容</span></span><br><span class="line">        ..</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>所有三目运算符都可以转换为if语句表达</p>
</blockquote>
<h5 id="②switch-语句"><a href="#②switch-语句" class="headerlink" title="②switch 语句"></a>②switch 语句</h5><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		语句体<span class="number">1</span>；</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">		语句体<span class="number">2</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	......		......</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>注意事项：① case后面只能跟常量，不能是变量</p>
<p>​                   ②多个case的值不能相同</p>
<p>case击穿：如果不写break关键字，则case匹配时，依次执行后面所有case语句体</p>
</blockquote>
<h5 id="③-If-和-Switch-的区别"><a href="#③-If-和-Switch-的区别" class="headerlink" title="③ If 和 Switch 的区别"></a>③ If 和 Switch 的区别</h5><ul>
<li>if<ul>
<li>针对结果是boolean类型的判断</li>
<li>针对一个范围的判断</li>
<li>针对几个常量的判断</li>
</ul>
</li>
<li>switch<ul>
<li>针对几个常量的判断</li>
</ul>
</li>
</ul>
<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h4><h5 id="①-while循环语句"><a href="#①-while循环语句" class="headerlink" title="① while循环语句"></a>① while循环语句</h5><ul>
<li><p>格式一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">初始化语句;</span><br><span class="line"><span class="keyword">while</span>(比较表达式)&#123;</span><br><span class="line">	语句体；</span><br><span class="line">    (控制条件);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>格式二：do…while</p>
<ul>
<li>最少执行一次代码，然后再进行判断循环</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	循环体语句；</span><br><span class="line">    (控制条件);</span><br><span class="line">&#125;<span class="keyword">while</span>(判断条件语句);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>while语句可以和for循环等价转换</p>
</blockquote>
</li>
</ul>
<h5 id="②for循环语句"><a href="#②for循环语句" class="headerlink" title="②for循环语句"></a>②for循环语句</h5><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句；判断条件语句；控制条件语句)&#123;</span><br><span class="line">	循环体；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>for循环的执行流程：</p>
<ul>
<li>执行初始化语句</li>
<li>执行判断条件语句，看结果是true还是false(true进入循环，false结束)</li>
<li>执行循环体语句</li>
<li>执行控制条件语句</li>
<li>返回第二步</li>
</ul>
</li>
</ul>
<blockquote>
<p>水仙花数：指一个数(最少三位)，其各位的三次方相加等于这个数</p>
<p>例如：157    370   371</p>
</blockquote>
<h5 id="③补充知识点"><a href="#③补充知识点" class="headerlink" title="③补充知识点"></a>③补充知识点</h5><ul>
<li><p>最简单的死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	循环体;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( ; ; )&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输出语句不换行</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>out.print<span class="literal">()</span>;  <span class="comment">//不写ln</span></span><br></pre></td></tr></table></figure></li>
<li><p>循环嵌套时，外循环控制行数，内循环控制列数</p>
</li>
</ul>
<h4 id="4-分支结构—跳转控制语句"><a href="#4-分支结构—跳转控制语句" class="headerlink" title="4.分支结构—跳转控制语句"></a>4.分支结构—跳转控制语句</h4><ul>
<li>三种关键字都有终止的效果，但是作用域不一样</li>
</ul>
<h5 id="①-break-中断"><a href="#①-break-中断" class="headerlink" title="① break 中断"></a>① break 中断</h5><ul>
<li>存在与switch或循环语句中，离开这两个环境时，无意义</li>
<li>作用：<ul>
<li>跳出单层循环（无标签）</li>
<li>跳出多层循环（带标签）<ul>
<li>格式：<code>标签名：循环体语句</code></li>
<li>标签名要符合Java的命名规则</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="②-continue-继续"><a href="#②-continue-继续" class="headerlink" title="② continue 继续"></a>② continue 继续</h5><ul>
<li>存在与循环语句中，离开循环无意义</li>
<li>作用：<ul>
<li>break退出当前循环</li>
<li>continue退出本次循环，继续下一次循环</li>
<li>也可以带标签使用</li>
</ul>
</li>
</ul>
<h5 id="③-return-返回"><a href="#③-return-返回" class="headerlink" title="③ return 返回"></a>③ return 返回</h5><ul>
<li>return不是为了跳出循环，而是为了结束方法</li>
<li>return后面的语句全部不执行</li>
</ul>
<h3 id="三、键盘录入数据"><a href="#三、键盘录入数据" class="headerlink" title="三、键盘录入数据"></a>三、键盘录入数据</h3><h5 id="第一步：导包（java封装好的Scanner方法）"><a href="#第一步：导包（java封装好的Scanner方法）" class="headerlink" title="第一步：导包（java封装好的Scanner方法）"></a>第一步：导包（java封装好的Scanner方法）</h5><p><code>import java.util.Scanner;</code></p>
<h5 id="第二步：Scanner加载进内存"><a href="#第二步：Scanner加载进内存" class="headerlink" title="第二步：Scanner加载进内存"></a>第二步：Scanner加载进内存</h5><p><code>Scanner sc = new Scanner(System.in);</code></p>
<blockquote>
<p>new关键字将栈区的CPU执行权交给堆区，堆区运行完后交还给栈区</p>
</blockquote>
<h5 id="第三步：捕获键盘录入数据并保存"><a href="#第三步：捕获键盘录入数据并保存" class="headerlink" title="第三步：捕获键盘录入数据并保存"></a>第三步：捕获键盘录入数据并保存</h5><p><code>int a = sc.nextInt();</code></p>
<blockquote>
<p>nextInt()录入int类型 / next()字符串类型</p>
</blockquote>
<p><img src="https://i.loli.net/2021/07/06/lvw8Aca4Kk2MRPJ.png" alt="image-20210706121609079"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>流程控制</tag>
        <tag>Scanner</tag>
        <tag>If</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举和注解</title>
    <url>/2021/08/25/%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="二、枚举"><a href="#二、枚举" class="headerlink" title="二、枚举"></a>二、枚举</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>发开中，一些固定的值通常用常量存储<ul>
<li>常量书写麻烦</li>
<li>不能对其进行其他操作</li>
</ul>
</li>
<li>为了间接的表示一些固定的值，Java就提供了枚举<ul>
<li>将固定的数据，一 一 列举出来</li>
</ul>
</li>
</ul>
<h4 id="2-定义枚举"><a href="#2-定义枚举" class="headerlink" title="2.定义枚举"></a>2.定义枚举</h4><ul>
<li><p>创建枚举类</p>
<ul>
<li><img src="https://i.loli.net/2021/08/19/okBYMgLDTay69Au.png" alt="image-20210819103354026"></li>
<li>枚举中的数据，通常全部用大写（书写习惯）</li>
</ul>
</li>
<li><p>定义枚举项</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Year</span></span>&#123;</span><br><span class="line">	枚举项一，枚举项二.....;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-枚举的特点"><a href="#3-枚举的特点" class="headerlink" title="3.枚举的特点"></a>3.枚举的特点</h4><ul>
<li><p>所有的枚举都是Enum的子类</p>
<p><img src="https://i.loli.net/2021/08/19/dR2IbYeBmw9WLXG.png" alt="image-20210819105029681"></p>
</li>
<li><p>我们可以通过 <font color='#d15252'>“枚举类名.枚举项名称” </font>去访问指定的枚举项</p>
<ul>
<li>枚举项，也是数据本身</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/XMFPCKsobaDYdyi.png" alt="image-20210819105149041"></p>
</li>
<li><p>每一个枚举项，都是该枚举的一个对象</p>
<ul>
<li>每个枚举项都会默认走一次构造方法</li>
</ul>
</li>
<li><p>枚举本质也是一个类，可以定义成员变量</p>
<ul>
<li>枚举中<font color='#d15252'>第一行</font>必须是<font color='#d15252'>枚举项</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/jXMW1nCaLtHNhsQ.png" alt="image-20210819105310021"></p>
</li>
<li><p>最后一个枚举项后的 <code>; </code>可以省略的，但是建议不要省略</p>
</li>
<li><p>枚举类可以有构造方法，但是修饰符必须是private</p>
<ul>
<li>不写修饰符，默认也是private</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/wKt6Crc8YbT3f4u.png" alt="image-20210819105350697"></p>
</li>
<li><p>枚举类可以有抽象方法，但是<font color='#d15252'>所有枚举项</font>必须重写该方法</p>
<p><img src="https://i.loli.net/2021/08/19/qB4AlW2tUardCD9.png" alt="image-20210819105431838"></p>
</li>
</ul>
<h4 id="4-枚举中的方法"><a href="#4-枚举中的方法" class="headerlink" title="4.枚举中的方法"></a>4.枚举中的方法</h4><h5 id="Ⅰ-ordinal"><a href="#Ⅰ-ordinal" class="headerlink" title="Ⅰ. ordinal()"></a>Ⅰ. ordinal()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回此枚举常数的序数（其枚举声明中的位置，其中初始常数的序数为零）。 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取枚举项的索引值</li>
</ul>
<h5 id="Ⅱ-name"><a href="#Ⅱ-name" class="headerlink" title="Ⅱ. name()"></a>Ⅱ. name()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">name</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回此枚举常量的名称，与其枚举声明中声明的完全相同。  </span></span></span><br></pre></td></tr></table></figure>





<h5 id="Ⅲ-compareTo-E-o"><a href="#Ⅲ-compareTo-E-o" class="headerlink" title="Ⅲ. compareTo(E o)"></a>Ⅲ. compareTo(E o)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(E o)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//将此枚举与指定的对象进行比较以进行订购。  </span></span></span><br></pre></td></tr></table></figure>


<ul>
<li>通常用来比较两个枚举项</li>
<li>返回值是索引值的差值</li>
</ul>
<h5 id="Ⅳ-toString"><a href="#Ⅳ-toString" class="headerlink" title="Ⅳ. toString()"></a>Ⅳ. toString()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回声明中包含的此枚举常量的名称。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回对象的内部信息</li>
</ul>
<h5 id="Ⅴ-valueOf"><a href="#Ⅴ-valueOf" class="headerlink" title="Ⅴ. valueOf()"></a>Ⅴ. valueOf()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt;</span><br><span class="line"><span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回具有指定名称的指定枚举类型的枚举常量。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>获取枚举类中<font color='#d15252'>指定名称</font>的枚举</li>
</ul>
<h5 id="Ⅵ-values"><a href="#Ⅵ-values" class="headerlink" title="Ⅵ.values()"></a>Ⅵ.values()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">values()</span><br></pre></td></tr></table></figure>

<ul>
<li>获取所有的枚举项</li>
</ul>
<h3 id="三、注解"><a href="#三、注解" class="headerlink" title="三、注解"></a>三、注解</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><code>@</code><ul>
<li>对我们的程序进行标注和解释</li>
</ul>
</li>
<li>注解和注释的区别：<ul>
<li>注释是给人看的</li>
<li>注解是给编译器看的</li>
</ul>
</li>
<li>注解的优点：<ul>
<li>更加简洁，方便</li>
</ul>
</li>
<li>注解的作用：就是一个标注的作用</li>
</ul>
<h4 id="2-自定义注解"><a href="#2-自定义注解" class="headerlink" title="2.自定义注解"></a>2.自定义注解</h4><ul>
<li><p>格式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名称 &#123; &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> 属性类型 属性名() <span class="keyword">default</span> 默认值</span><br></pre></td></tr></table></figure></li>
</ul>
<p>  [^属性类型]: 基本数据类型、String类型、Class类型、注解类型、枚举类型、一维数组+以上类型<br>  [^default]: 赋一个默认的初始化值</p>
<p>  <img src="https://i.loli.net/2021/08/19/ZPHFq1m8GnVcoQt.png" alt="image-20210819140308394"></p>
</li>
</ul>
<h4 id="3-练习"><a href="#3-练习" class="headerlink" title="3.练习"></a>3.练习</h4><ul>
<li>自定义一个注解@Test，用于指定类的方法上<ul>
<li>如果某一个类的方法上有该注解时，就执行这个方法</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、元注解"><a href="#四、元注解" class="headerlink" title="四、元注解"></a>四、元注解</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ul>
<li><p>就是描述注解的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="meta">@Inherited()</span></span><br></pre></td></tr></table></figure></li>
<li><p>即给注解注解的注解</p>
<p><img src="https://i.loli.net/2021/08/19/px5RjsFJO3Ar8wa.png" alt="image-20210819145603008"></p>
</li>
</ul>
<h4 id="2-三种元注解"><a href="#2-三种元注解" class="headerlink" title="2.三种元注解"></a>2.三种元注解</h4><h5 id="Ⅰ-Target"><a href="#Ⅰ-Target" class="headerlink" title="Ⅰ.@Target"></a>Ⅰ.@Target</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定注解在哪使用</li>
<li>默认：ANNOTATION_TYPE 在哪都可以使用</li>
</ul>
<h5 id="Ⅱ-Retention"><a href="#Ⅱ-Retention" class="headerlink" title="Ⅱ.@Retention"></a>Ⅱ.@Retention</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.SOURCE)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>指定该注解存活时间（编译时，运行时）</li>
</ul>
<h5 id="Ⅲ-Inherited"><a href="#Ⅲ-Inherited" class="headerlink" title="Ⅲ.@Inherited"></a>Ⅲ.@Inherited</h5><ul>
<li>表示修饰的自定义注解可以被子类继承</li>
</ul>
<h3 id="五、junit测试"><a href="#五、junit测试" class="headerlink" title="五、junit测试"></a>五、junit测试</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>是一个第三方的jar包<ul>
<li>可以单独的运行某一个方法</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/19/q4NlRwAB5YnFy9V.png" alt="image-20210819155411352"></p>
<ul>
<li>Before：在Test之前运行</li>
<li>Test：测试这个方法</li>
<li>After：在Test之后运行</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>注解</tag>
        <tag>junit</tag>
      </tags>
  </entry>
  <entry>
    <title>数组</title>
    <url>/2021/08/25/%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h3 id="一、数组"><a href="#一、数组" class="headerlink" title="一、数组"></a>一、数组</h3><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1.什么是数组"></a>1.什么是数组</h4><ul>
<li>概念：数组是存储多个变量的容器（数据类型要一致）<ul>
<li>数组可以存储基本数据类型也可以存储引用数据类型</li>
</ul>
</li>
</ul>
<h4 id="2-定义数组"><a href="#2-定义数组" class="headerlink" title="2.定义数组"></a>2.定义数组</h4><ul>
<li><p>第一种格式：</p>
<ul>
<li><p>数据类型 数组名[] ；</p>
<p>例：<code>int arr1[]</code>；</p>
</li>
</ul>
</li>
<li><p>第二种格式：</p>
<ul>
<li><p>数据类型[] 数组名</p>
<p>例：<code>int[] arr2</code>;</p>
</li>
</ul>
</li>
</ul>
<h4 id="3-数组的定义和初始化格式"><a href="#3-数组的定义和初始化格式" class="headerlink" title="3.数组的定义和初始化格式"></a>3.数组的定义和初始化格式</h4><h5 id="①-概念："><a href="#①-概念：" class="headerlink" title="① 概念："></a>① 概念：</h5><ul>
<li>从内存的原来看，数组是一组存储变量的容器<ul>
<li>并且内存中，堆内存是空闲的，所以我们可以在堆内存中定义一个数组存储数据<ul>
<li>要想在堆内存中创建数组，必须要将Cpu的执行权由栈区交给堆区<font color='#d15252'>（new）</font>关键字</li>
</ul>
</li>
<li>在堆区中，开辟内存的目的是数据，而开辟内存空间，就需要用到数组类型</li>
</ul>
</li>
<li>以上两步可知，在堆区创建数组  <code>new int[];</code></li>
<li>创建数组后，需要在栈区创建一个变量，存储堆区数组的地址值，用来使用数组</li>
</ul>
<h5 id="②动态初始化：只指定长度，初始值默认"><a href="#②动态初始化：只指定长度，初始值默认" class="headerlink" title="②动态初始化：只指定长度，初始值默认"></a>②<font color='#d15252'>动态初始化</font>：只指定长度，初始值默认</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = <span class="keyword">new</span> <span class="keyword">int</span>[数组长度]；</span><br><span class="line"></span><br><span class="line">例：<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>系统初始默认值，int是0 ，String是null</li>
</ul>
<h5 id="③静态初始化：指定初始值，系统默认长度"><a href="#③静态初始化：指定初始值，系统默认长度" class="headerlink" title="③静态初始化：指定初始值，系统默认长度"></a>③静态初始化：指定初始值，系统默认长度</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[] 数组名 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-数组的数据操作"><a href="#4-数组的数据操作" class="headerlink" title="4.数组的数据操作"></a>4.数组的数据操作</h4><h5 id="Ⅰ-赋值操作"><a href="#Ⅰ-赋值操作" class="headerlink" title="Ⅰ.赋值操作"></a>Ⅰ.赋值操作</h5><ul>
<li><code>数组名[索引] = 数组；</code></li>
</ul>
<h5 id="Ⅱ-取值操作"><a href="#Ⅱ-取值操作" class="headerlink" title="Ⅱ.取值操作"></a>Ⅱ.取值操作</h5><p>通过数组自带的索引取值</p>
<ul>
<li>直接取值<ul>
<li>直接打印到控制台，比较方便，但无法对数据继续进行操作</li>
</ul>
</li>
<li><font color='#d15252'>赋值取值</font><ul>
<li>创建一个变量保存数据<ul>
<li><code>变量名 = 数组名[索引]</code></li>
<li>比较繁琐，但可以对数据进行多次操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-数组的特性"><a href="#Ⅲ-数组的特性" class="headerlink" title="Ⅲ.数组的特性"></a>Ⅲ.数组的特性</h5><ul>
<li>length表示数组的长度<ul>
<li><code>arr.length    </code></li>
</ul>
</li>
</ul>
<h5 id="Ⅳ-练习"><a href="#Ⅳ-练习" class="headerlink" title="Ⅳ.练习"></a>Ⅳ.练习</h5><ul>
<li>数组中存5个整数，求和，以及求平均数</li>
<li>数组中存5个数，找出最大、最小的两个数</li>
<li>冒泡排序：从第一个数开始，依次和后一个数比较，小的放前，大的放后</li>
</ul>
<h5 id="Ⅴ-数组常见异常"><a href="#Ⅴ-数组常见异常" class="headerlink" title="Ⅴ.数组常见异常"></a>Ⅴ.数组常见异常</h5><ul>
<li><p>索引超出范围，索引越界</p>
<ul>
<li><code> java.lang.ArrayIndexOutOfBoundsException:</code></li>
</ul>
</li>
<li><p>空指针异常</p>
<ul>
<li><code>java.lang.NullPointerException</code></li>
</ul>
</li>
</ul>
<h3 id="二、二维数组"><a href="#二、二维数组" class="headerlink" title="二、二维数组"></a>二、二维数组</h3><h4 id="1-二维数组的概念"><a href="#1-二维数组的概念" class="headerlink" title="1.二维数组的概念"></a>1.二维数组的概念</h4><ul>
<li>二维数组就是一个元素为一维数组的数组</li>
</ul>
<h4 id="2-二维数组的定义格式"><a href="#2-二维数组的定义格式" class="headerlink" title="2.二维数组的定义格式"></a>2.二维数组的定义格式</h4><h5 id="①动态初始化"><a href="#①动态初始化" class="headerlink" title="①动态初始化"></a>①动态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 变量名 = <span class="keyword">new</span> 数据类型[m][n];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>arr[m] [n] 表示第m+1个一维数组的第n+1个数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 变量名 = <span class="keyword">new</span> 数据类型[m][];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>没有给出一维数组的元素个数，可以动态给出</p>
</blockquote>
<h5 id="②静态初始化"><a href="#②静态初始化" class="headerlink" title="②静态初始化"></a>②静态初始化</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数据类型[][] 变量名 = <span class="keyword">new</span> 数据类型[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;......&#125;;</span><br><span class="line"></span><br><span class="line">简化：</span><br><span class="line">    数据类型[][] 变量名 = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;...&#125;;</span><br><span class="line">例如：<span class="keyword">int</span>[][] arr = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">6</span>&#125;&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-二维数组的数据操作"><a href="#3-二维数组的数据操作" class="headerlink" title="3.二维数组的数据操作"></a>3.二维数组的数据操作</h4><h5 id="Ⅰ-取数据"><a href="#Ⅰ-取数据" class="headerlink" title="Ⅰ.取数据"></a>Ⅰ.取数据</h5><ul>
<li><p>直接取出</p>
<ul>
<li>用双层嵌套循环，第一层循环取出一维数组，第二层循环取出一维数组里的数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="comment">//外层循环取出一位数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="comment">//内存循环遍历一维数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr[i].length;j++)&#123;</span><br><span class="line">		System.out.println(arr[i][j]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>赋值取</p>
<ul>
<li><code>int a = arr[0][1];</code>取出第一个一维数组的第二个数</li>
</ul>
</li>
</ul>
<h5 id="②赋值"><a href="#②赋值" class="headerlink" title="②赋值"></a>②赋值</h5><ul>
<li>格式：<code>变量名[索引第几个数组][索引第几个数] = 数据</code></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title>继承、多态、抽象类和接口</title>
    <url>/2021/08/25/%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h3 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h3><h4 id="1-什么是继承？"><a href="#1-什么是继承？" class="headerlink" title="1.什么是继承？"></a>1.什么是继承？</h4><ul>
<li><p>Java中继承</p>
<ul>
<li>第一步：找到重复代码</li>
<li>第二步：找到封装重复代码的工具</li>
<li>第三步：其他类和公共类没有联系<ul>
<li>使用 <code>extends</code>继承</li>
</ul>
</li>
</ul>
</li>
<li><p>继承的格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类名 <span class="keyword">extends</span> 父类名</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-继承解决了代码的重复性"><a href="#2-继承解决了代码的重复性" class="headerlink" title="2.继承解决了代码的重复性"></a>2.继承解决了代码的重复性</h4><h5 id="开发原则：低耦合，高内聚"><a href="#开发原则：低耦合，高内聚" class="headerlink" title="开发原则：低耦合，高内聚"></a>开发原则：低耦合，高内聚</h5><ul>
<li>耦合：类与类之间的关系</li>
<li>内聚：自己完成某件事的能力</li>
</ul>
<h4 id="3-继承的构造方法之间的关系"><a href="#3-继承的构造方法之间的关系" class="headerlink" title="3.继承的构造方法之间的关系"></a>3.继承的构造方法之间的关系</h4><ul>
<li><p>父类与子类的构造方法不会继承</p>
</li>
<li><p>创建子类对象时，会先运行父类的构造方法（初始化夫），然后运行子类的构造方法</p>
<ul>
<li><p>因为在继承时，子类构造方法有隐藏的super()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//隐藏super</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="number">10</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;子类的无参构造&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="4-继承的成员变量关系"><a href="#4-继承的成员变量关系" class="headerlink" title="4.继承的成员变量关系"></a>4.继承的成员变量关系</h4><ul>
<li><p>私有的是无法被继承的</p>
<ul>
<li>实际上是可以继承的，但是不能访问</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>子类被赋予了访问super内存空间的权限</li>
</ul>
<p><img src="https://i.loli.net/2021/07/29/Q3zvmHiLqKWcJaS.png" alt="image-20210729103202135"></p>
</li>
</ul>
<h4 id="5-继承的方法关系"><a href="#5-继承的方法关系" class="headerlink" title="5.继承的方法关系"></a>5.继承的方法关系</h4><ul>
<li>方法可以被继承</li>
</ul>
<h5 id="Ⅰ-方法重写："><a href="#Ⅰ-方法重写：" class="headerlink" title="Ⅰ.方法重写："></a>Ⅰ.<font color='#d15252'>方法重写</font>：</h5><ul>
<li>概念：子类和父类中的方法声明一模一样，就是方法重写<ul>
<li>方法体可以不一样</li>
</ul>
</li>
<li>子类对象调用方法的<font color='orange'>特点</font><ul>
<li>若方法名不相同，则调用对应名称的方法</li>
<li>若方法名相同，则调用子类自己的</li>
</ul>
</li>
<li>子类重写父类方法时，访问权限不能更低</li>
</ul>
<h4 id="6-继承的总结"><a href="#6-继承的总结" class="headerlink" title="6.继承的总结"></a>6.继承的总结</h4><ul>
<li>Java中只支持单继承，不支持多继承。但是支持多层继承<ul>
<li>即 一个类只能有一个爸爸 ，但是可以有一个爷爷，一个祖爷爷</li>
<li><font color='#d15252'>但多层继承打破了封装性，功能唯一性</font></li>
</ul>
</li>
<li>子类只能继承父类的非私有成员（成员变量、成员方法）</li>
<li>子类不会继承父类的构造方法，但可以通过super()访问</li>
</ul>
<hr>
<h3 id="二、多态"><a href="#二、多态" class="headerlink" title="二、多态"></a>二、多态</h3><h4 id="1-概念："><a href="#1-概念：" class="headerlink" title="1.概念："></a>1.概念：</h4><ul>
<li>某一事物，不同时刻不同状态（扯淡）</li>
<li><font color='#d15252'>赋予父类访问子类的权限</font><ul>
<li>父类要有与子类相同的方法，不然过不了编译</li>
<li>因为对象进实体找方法从上到下</li>
</ul>
</li>
</ul>
<h4 id="2-结论："><a href="#2-结论：" class="headerlink" title="2.结论："></a>2.结论：</h4><ul>
<li>成员变量：<ul>
<li>编译看左边，运行看左边 （就近原则）</li>
</ul>
</li>
<li>成员方法：<ul>
<li>编译看左边，运行看右边（方法重写）</li>
</ul>
</li>
<li>构造方法：<ul>
<li>创建子类对象，先初始化父类</li>
</ul>
</li>
<li>静态方法：<ul>
<li>编译看左边，运行看左边（静态和类相关，不是重写）</li>
</ul>
</li>
</ul>
<h4 id="3-实现多态"><a href="#3-实现多态" class="headerlink" title="3.实现多态"></a>3.<font color='#d15252'>实现多态</font></h4><ul>
<li>要有继承关系<ul>
<li>要有方法的重写</li>
</ul>
</li>
<li>父类引用指向子类对象</li>
</ul>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul>
<li><p>instanceof</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">(x instanceof y)</span></span>&#123;</span><br><span class="line">	<span class="comment">//判断x是否是y的一种</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="三、抽象类"><a href="#三、抽象类" class="headerlink" title="三、抽象类"></a>三、抽象类</h3><p><strong><font color='#d15252'>abstract</font></strong></p>
<h4 id="1-什么是抽象类？"><a href="#1-什么是抽象类？" class="headerlink" title="1.什么是抽象类？"></a>1.什么是抽象类？</h4><ul>
<li>为了让父类能够调用子类的方法<ul>
<li>而父类必须有一个一样的方法<ul>
<li>并且父类方法中不需要写方法体<ul>
<li>但不写方法体会报错，需要抽象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>一个<font color='#d15252'>没有方法体</font>的方法应定义为<font color='#d15252'>抽象方法</font></li>
<li>如果一个类中有抽象方法，则该类<font color='#d15252'>必须定义为抽象类</font></li>
</ul>
<h4 id="2-定义抽象类格式"><a href="#2-定义抽象类格式" class="headerlink" title="2.定义抽象类格式"></a>2.定义抽象类格式</h4><ul>
<li><p>抽象类和抽象方法的定义，必须用abstract来修饰</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-抽象类的使用"><a href="#3-抽象类的使用" class="headerlink" title="3.抽象类的使用"></a>3.抽象类的使用</h4><ul>
<li>抽象类无法直接<font color='#d15252'><strong>实例化</strong></font></li>
</ul>
<h4 id="4-抽象类的组成"><a href="#4-抽象类的组成" class="headerlink" title="4.抽象类的组成"></a>4.抽象类的组成</h4><ul>
<li>构造方法</li>
<li>成员变量</li>
<li>成员方法<ul>
<li>是否包含非抽象方法</li>
</ul>
</li>
</ul>
<hr>
<h3 id="四、接口"><a href="#四、接口" class="headerlink" title="四、接口"></a>四、接口</h3><h4 id="1-接口的定义："><a href="#1-接口的定义：" class="headerlink" title="1.接口的定义："></a>1.接口的定义：</h4><ul>
<li>当我们有额外的业务（功能）时，需要用接口区封装业务</li>
<li>接口体现了扩展性</li>
</ul>
<h4 id="2-接口的格式"><a href="#2-接口的格式" class="headerlink" title="2.接口的格式"></a>2.接口的格式</h4><ul>
<li><p>接口用关键字interface表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="class"><span class="keyword">interface</span> 接口名</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>类实现接口用implements表示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：<span class="class"><span class="keyword">class</span> 类名 <span class="keyword">implements</span> 接口名 </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-接口的组成"><a href="#3-接口的组成" class="headerlink" title="3.接口的组成"></a>3.接口的组成</h4><ul>
<li>构造方法：没有构造方法<ul>
<li>不能实例化</li>
</ul>
</li>
<li>变量：没有变量，只能有常量</li>
<li>方法：只能是抽象方法</li>
</ul>
<h4 id="4-接口的实例化"><a href="#4-接口的实例化" class="headerlink" title="4.接口的实例化"></a>4.接口的实例化</h4><ul>
<li>同抽象方法一样</li>
</ul>
<h5 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h5><ul>
<li>举重：<ul>
<li>教练：姓名 年龄    吃馒头</li>
<li>运动员： 姓名 年龄 吃牛肉</li>
</ul>
</li>
<li>乒乓球： <ul>
<li>教练：姓名 年龄  吃驴肉</li>
<li>教练：姓名 年龄  吃驴肉</li>
</ul>
</li>
</ul>
<p>和乒乓球相关的，都会说英语</p>
<p>和举重相关的，都会说日语</p>
<p>say：输出信息</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>多态</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的生命周期、安全隐患和通信</title>
    <url>/2021/08/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3%E5%92%8C%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<h3 id="一、线程的生命周期"><a href="#一、线程的生命周期" class="headerlink" title="一、线程的生命周期"></a>一、线程的生命周期</h3><ul>
<li>通过API提供的方法让线程声明周期的某个阶段，达到可控状态</li>
</ul>
<h4 id="1-sleep-方法"><a href="#1-sleep-方法" class="headerlink" title="1.sleep()方法"></a>1.sleep()方法</h4><ul>
<li><p>在指定的毫秒数内让正在执行的线程休眠</p>
</li>
<li><p>使当前正在执行的线程停留（暂停执行）指定的毫秒数，这取决于系统定时器和调度程序的精度和准确性</p>
</li>
</ul>
<h4 id="2-join-方法"><a href="#2-join-方法" class="headerlink" title="2.join()方法"></a>2.join()方法</h4><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">join();</span><br></pre></td></tr></table></figure>

<ul>
<li>等待调用该方法的线程结束后才能执行<ul>
<li>谁调用该方法，谁先执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">join(<span class="keyword">long</span> time)</span><br></pre></td></tr></table></figure>

<ul>
<li>等待调用该方法的线程，最多 <code>time</code>秒，然后才执行</li>
</ul>
<p><img src="https://i.loli.net/2021/08/13/9RbLO7FyAetT2nY.png" alt="image-20210813092653883"></p>
<h4 id="3-线程的优先级"><a href="#3-线程的优先级" class="headerlink" title="3.线程的优先级"></a>3.<font color='#d15252'>线程的优先级</font></h4><ul>
<li><p>Fileds常量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY 线程可以拥有的最大优先级。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY 线程可以拥有的最小优先级。  </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY 分配给线程的默认优先级。 </span><br></pre></td></tr></table></figure>

<ul>
<li>Java为线程类提供了10个优先级</li>
<li>优先级可以用整数1—10表示，超过范围会抛出异常<ul>
<li>最先等级 1 </li>
<li>默认等级 5</li>
<li>最大等级 10</li>
</ul>
</li>
</ul>
</li>
<li><p><code>getPriority()</code> 获取线程的优先级</p>
</li>
<li><p><code>setPriority(int b)</code> 设置线程的优先级</p>
</li>
<li><p>查阅main方法的优先级</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前线程对象并保存</span></span><br><span class="line">Thread thread = Thread.currentThread();</span><br><span class="line"><span class="comment">//调用获取优先级方法</span></span><br><span class="line">thread.getPriority();</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="实验：线程优先级的效果"><a href="#实验：线程优先级的效果" class="headerlink" title="实验：线程优先级的效果"></a>实验：线程优先级的效果</h5><p><img src="https://i.loli.net/2021/08/13/vQXdb257gLK9slU.png" alt="image-20210813095931549"></p>
<h3 id="二、线程的安全隐患"><a href="#二、线程的安全隐患" class="headerlink" title="二、线程的安全隐患"></a>二、线程的安全隐患</h3><ul>
<li>隐患：存在发生的可能性,但不一定会发生<ul>
<li>多个线程是通过竞争CPU的时间获得运行机会</li>
<li>多个线程什么时候获得CPU时间，占用多少</li>
<li>一个正在运行着的线程在什么地方暂停，也是不确定的</li>
<li><img src="https://i.loli.net/2021/08/13/KvFtIJ9CmfoXqLd.png" alt="image-20210813105351734"></li>
</ul>
</li>
</ul>
<h4 id="1-线程同步"><a href="#1-线程同步" class="headerlink" title="1.线程同步"></a>1.线程<font color='#d15252'>同步</font></h4><ul>
<li>只允许一个线程执行</li>
<li><font color='#d15252'>synchronized</font>同步锁</li>
</ul>
<h5 id="Ⅰ-同步代码块"><a href="#Ⅰ-同步代码块" class="headerlink" title="Ⅰ.同步代码块"></a>Ⅰ.同步代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Synchronized(对象)&#123;</span><br><span class="line">	<span class="comment">//同步代码（上锁）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>需要传递一个参数</li>
</ul>
<p><img src="https://i.loli.net/2021/08/13/cPWEQwfTSdvgYZH.png"></p>
<p><img src="https://i.loli.net/2021/08/13/sT721vdch593yGn.png" alt="image-20210813105612949"></p>
<ul>
<li>细节问题</li>
</ul>
<h5 id="Ⅱ-同步方法"><a href="#Ⅱ-同步方法" class="headerlink" title="Ⅱ.同步方法"></a>Ⅱ.同步方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span><span class="comment">//this</span></span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/13/Hbej1wsAgymIUo5.png" alt="image-20210813112929968"></p>
<p><img src="https://i.loli.net/2021/08/13/DvtNHRj6WBdunkZ.png" alt="image-20210813114530211"></p>
<ul>
<li>不想加静态就用this </li>
<li>定义一个方法专门放synchronized</li>
</ul>
<h4 id="2-死锁（同步代码块嵌套）"><a href="#2-死锁（同步代码块嵌套）" class="headerlink" title="2.死锁（同步代码块嵌套）"></a>2.死锁（<font color='#d15252'>同步代码块嵌套</font>）</h4><ul>
<li><p>程序没有停止，而且线程不在执行</p>
<ul>
<li>当一个线程拥有A对象锁的时候，并且在等待B对象锁的时候，另一个线程拥有了B对象的锁，并在等待A锁</li>
<li>这种情况就造成了死锁</li>
</ul>
</li>
<li><p>不要嵌套！！！！！！！！！！！！！！！！！！！</p>
</li>
</ul>
<h3 id="三、线程的通信"><a href="#三、线程的通信" class="headerlink" title="三、线程的通信"></a>三、线程的通信</h3><h4 id="1-两个进程之间通信案例"><a href="#1-两个进程之间通信案例" class="headerlink" title="1.两个进程之间通信案例"></a>1.两个进程之间通信案例</h4><ul>
<li><p>在A线程执行时，别的线程不能插入，即不交出cpu执行权</p>
<ul>
<li>synchronized锁住</li>
<li>必须用同一把锁</li>
</ul>
</li>
<li><p>A线程执行之后，需要通知B执行，找一个中间者作为记录</p>
</li>
<li><p>线程1</p>
<p><img src="https://i.loli.net/2021/08/13/uj5agEFkPDmsLVh.png" alt="image-20210813162255432"></p>
</li>
<li><p>线程2</p>
<p><img src="https://i.loli.net/2021/08/13/RnHIzLrvfaiJEAc.png" alt="image-20210813162312051"></p>
</li>
</ul>
<h4 id="2-三个进程间通信案例"><a href="#2-三个进程间通信案例" class="headerlink" title="2.三个进程间通信案例"></a>2.三个进程间通信案例</h4><ul>
<li>while循环实现重复输出</li>
<li>实现同步代码块，确保一个线程执行时不会被抢走执行权<ul>
<li>synchronized 加同步锁</li>
</ul>
</li>
<li>三个线程要用一个锁对象<ul>
<li>public <font color='#d15252'>static </font>Object obj = new Object();</li>
<li>因为main方法是静态的，所以锁对象也要静态</li>
<li>锁对象很灵活，用什么都可以</li>
</ul>
</li>
<li>需要有记录员，记录线程之间通信的情况<ul>
<li>定义一个变量，记录是谁在发消息<ul>
<li>int a = 1;</li>
</ul>
</li>
</ul>
</li>
<li><font color='#d15252'>线程1</font><ul>
<li>当a==1时，发送消息；并将a=2；唤醒所有线程</li>
<li>当a!=1时，处于等待状态</li>
</ul>
</li>
<li>线程2<ul>
<li>当a==2时，发送消息；并将a=3；唤醒其他所有线程</li>
<li>当a!=2时，处于等待状态</li>
</ul>
</li>
<li>线程3<ul>
<li>当a==3时，发送消息；并将a=1；唤醒其他所有线程</li>
<li>当a!=3时，处于等待状态</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/13/gNbj82trWxEfilB.png" alt="image-20210813164127993"></p>
<h4 id="3-通信中用到的方法"><a href="#3-通信中用到的方法" class="headerlink" title="3.通信中用到的方法"></a>3.通信中用到的方法</h4><ul>
<li>wait()<ul>
<li>等待</li>
</ul>
</li>
<li>notifyAll()<ul>
<li>唤醒所有线程3</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/2021/08/24/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="一、网络编程"><a href="#一、网络编程" class="headerlink" title="一、网络编程"></a>一、网络编程</h3><h4 id="1-网络编程的概念"><a href="#1-网络编程的概念" class="headerlink" title="1.网络编程的概念"></a>1.网络编程的概念</h4><ul>
<li>学习Java的操作<ul>
<li>操作内存</li>
<li>本地存储（IO流）</li>
<li>和互联网中的设备产生关系</li>
</ul>
</li>
</ul>
<h4 id="2-网编的三要素"><a href="#2-网编的三要素" class="headerlink" title="2.网编的三要素"></a>2.网编的三要素</h4><ul>
<li>网络协议（网络通道）</li>
<li>IP(设备的地址)</li>
<li>端口号（具体软件）<ul>
<li>0-65535</li>
</ul>
</li>
</ul>
<h3 id="二、InetAddress"><a href="#二、InetAddress" class="headerlink" title="二、InetAddress"></a>二、InetAddress</h3><h4 id="1-API概述"><a href="#1-API概述" class="headerlink" title="1.API概述"></a>1.API概述</h4><ul>
<li>包java.net.InetAddress<ul>
<li>导包</li>
</ul>
</li>
<li>修饰符public</li>
<li>使用InetAddress<ul>
<li>构造方法<ul>
<li>没有构造方法</li>
</ul>
</li>
<li>使用静态方法<ul>
<li>通过类名直接调用</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-getByName"><a href="#Ⅰ-getByName" class="headerlink" title="Ⅰ. getByName()"></a>Ⅰ. getByName()</h5><ul>
<li>确定<font color='#d15252'>主机名称</font>和<font color='#d15252'>IP</font>地址</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> InetAddress getByName​(String host)</span><br><span class="line">    <span class="comment">//确定主机名称和IP地址。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li>能获取自己的，也能获取别人的</li>
</ul>
<h5 id="Ⅱ-getLocalHost"><a href="#Ⅱ-getLocalHost" class="headerlink" title="Ⅱ. getLocalHost()"></a>Ⅱ. getLocalHost()</h5><ul>
<li>返回本机的地址<ul>
<li>只能查看自己的，本机的IP </li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> InetAddress <span class="title">getLocalHost</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//返回本地主机的地址。</span></span></span><br></pre></td></tr></table></figure>





<h5 id="Ⅲ-getHostName"><a href="#Ⅲ-getHostName" class="headerlink" title="Ⅲ. getHostName()"></a>Ⅲ. getHostName()</h5><ul>
<li>获取此IP地址的主机名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHostName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//获取此IP地址的主机名。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值String类型</li>
<li>没有static修饰</li>
</ul>
<h5 id="Ⅳ-getHostAddress"><a href="#Ⅳ-getHostAddress" class="headerlink" title="Ⅳ.  getHostAddress()"></a>Ⅳ.  getHostAddress()</h5><ul>
<li>获取IP</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHostAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="comment">//返回文本显示中的IP地址字符串。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回值String类型</li>
<li>没有static修饰</li>
</ul>
<h3 id="三、网络协议"><a href="#三、网络协议" class="headerlink" title="三、网络协议"></a>三、网络协议</h3><h4 id="1-TCP-IP"><a href="#1-TCP-IP" class="headerlink" title="1. TCP/IP"></a>1. TCP/IP</h4><ul>
<li>应用层 <ul>
<li>http ftp DNS<ul>
<li>应用软件之间的通信   — &gt;  前端开发</li>
</ul>
</li>
</ul>
</li>
<li>传输层<ul>
<li>TCP UDP <ul>
<li>负责网络程序通信 — &gt; 后台开发</li>
</ul>
</li>
</ul>
</li>
<li>网络层<ul>
<li>ip icmp IGMP<ul>
<li>负责数据传输的<font color='#d15252'>目标</font></li>
</ul>
</li>
</ul>
</li>
<li>链路层<ul>
<li>驱动程序、接口   <ul>
<li>硬件部分</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/cfs5AzeaLEKJvW3.png" alt="image-20210816094838044"></p>
<h4 id="2-传输层UDP-快递"><a href="#2-传输层UDP-快递" class="headerlink" title="2.传输层UDP (快递)"></a>2.传输层UDP (快递)</h4><ul>
<li>面向无连接通信<ul>
<li>发送端和接收端<font color='#d15252'>不建立</font>逻辑关系</li>
<li>不在乎对方是否存在/是否接收</li>
<li>耗费资源比较小，通信效率高，通常被用来音频、视频、普通数据的传输</li>
</ul>
</li>
</ul>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="四、DatagramPacket-报包"><a href="#四、DatagramPacket-报包" class="headerlink" title="四、DatagramPacket (报包)"></a>四、DatagramPacket (报包)</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>包<ul>
<li>java.net.DatagramPacket<ul>
<li>需要导包</li>
</ul>
</li>
</ul>
</li>
<li>修饰符<ul>
<li>final 最终类 <ul>
<li>不能被继承</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-发送长度为-length的数据包"><a href="#Ⅰ-发送长度为-length的数据包" class="headerlink" title="Ⅰ.发送长度为 length的数据包"></a>Ⅰ.发送长度为 length的数据包</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> length, InetAddress address, <span class="keyword">int</span> port) </span><br><span class="line"><span class="comment">//构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。  </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>发送长度为 length的数据包偏移量为 offset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramPacket(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length, SocketAddress address) </span><br><span class="line"><span class="comment">//构造一个数据报包，发送长度为 length的数据包，偏移量为 ioffset到指定主机上的指定端口号。  </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-成员方法-1"><a href="#2-成员方法-1" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-getData"><a href="#Ⅰ-getData" class="headerlink" title="Ⅰ. getData()"></a>Ⅰ. getData()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] getData()</span><br><span class="line"> <span class="comment">//返回数据缓冲区。  </span></span><br></pre></td></tr></table></figure>



<h5 id="Ⅱ-getLength"><a href="#Ⅱ-getLength" class="headerlink" title="Ⅱ. getLength()"></a>Ⅱ. getLength()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回要发送的数据的长度或接收到的数据的长度。 </span></span></span><br></pre></td></tr></table></figure>



<h3 id="五、DatagramSocket-发送报包"><a href="#五、DatagramSocket-发送报包" class="headerlink" title="五、DatagramSocket(发送报包)"></a>五、DatagramSocket(发送报包)</h3><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-DatagramSocket"><a href="#Ⅰ-DatagramSocket" class="headerlink" title="Ⅰ. DatagramSocket()"></a>Ⅰ. DatagramSocket()</h5><ul>
<li>```java<br>DatagramSocket()<br>//创建该类的实例，并且将指定的数据报包进行绑定(任意端口号)<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span>成员方法</span><br><span class="line"></span><br><span class="line">##### Ⅰ. send(DatagramPacket p) &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;发送&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">void send(DatagramPacket p) 从此套接字发送数据报包。  </span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/micTFegHh3V9JAl.png" alt="image-20210816111327413"></p>
<h3 id="六、UDP传输接收端"><a href="#六、UDP传输接收端" class="headerlink" title="六、UDP传输接收端"></a>六、UDP传输<font color='#d15252'>接收端</font></h3><h4 id="DatagramSocket：可以用来发送也可以用来接收"><a href="#DatagramSocket：可以用来发送也可以用来接收" class="headerlink" title="DatagramSocket：可以用来发送也可以用来接收"></a>DatagramSocket：可以用来发送也可以用来接收</h4><h4 id="1-构造方法-1"><a href="#1-构造方法-1" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-DatagramSocket-int-port"><a href="#Ⅰ-DatagramSocket-int-port" class="headerlink" title="Ⅰ. DatagramSocket(int port)"></a>Ⅰ. DatagramSocket(int port)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket(<span class="keyword">int</span> port)</span><br><span class="line"><span class="comment">//构造数据报套接字并将其绑定到本地主机上的指定端口。 </span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建该类实例，并指定要接收的端口号</li>
</ul>
<h4 id="2-成员方法-2"><a href="#2-成员方法-2" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><h5 id="Ⅰ-receive-DatagramPacket-p"><a href="#Ⅰ-receive-DatagramPacket-p" class="headerlink" title="Ⅰ. receive(DatagramPacket p)"></a>Ⅰ. receive(DatagramPacket p)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receive</span><span class="params">(DatagramPacket p)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//从此套接字接收数据报包。 </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数需要传递一个DatagramPacket对象<ul>
<li>即创建一个报包，用于接收数据</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/NuHWUCp536ncVk2.png" alt="image-20210816112350372"></p>
<hr>
<h3 id="总结：UDP-发送接收数据报包的步骤"><a href="#总结：UDP-发送接收数据报包的步骤" class="headerlink" title="总结：UDP 发送接收数据报包的步骤"></a>总结：UDP 发送接收数据报包的<font color='#d15252'>步骤</font></h3><h4 id="一、发送"><a href="#一、发送" class="headerlink" title="一、发送"></a>一、发送</h4><ul>
<li><p>将要发送的数据存入byte[]数组</p>
<p><img src="https://i.loli.net/2021/08/16/yUQGD8TclPEWuta.png" alt="image-20210816112518290"></p>
</li>
<li><p>将数据打包</p>
<ul>
<li>使用DatagramPacket的构造方法将数据打包</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/udH9ewWDxJR2Kzj.png" alt="image-20210816112657659"></p>
<ul>
<li>指定byte[]数据，长度，给出InetAddress对象(地址)，端口号</li>
</ul>
</li>
<li><p>准备发送的工具（快递小哥）</p>
<ul>
<li><p>使用DatagtamSocket构建一个对象，调用它的send方法，发送数据</p>
<p><img src="https://i.loli.net/2021/08/16/2fwUVBmbPy3scNj.png" alt="image-20210816112825275"></p>
</li>
<li><p>send方法需要传递一个DatagramPacket类的对象</p>
</li>
</ul>
</li>
</ul>
<h4 id="二、接收"><a href="#二、接收" class="headerlink" title="二、接收"></a>二、接收</h4><ul>
<li><p>首先要准备一个DatagramPacket对象，用于接收发送端发送过来的数据</p>
<ul>
<li><p>使用简单的构造方法，构造一个DatagramPacket，需要一个byte[]数组</p>
<p><img src="https://i.loli.net/2021/08/16/UQJhknG649aYDHj.png" alt="image-20210816113024029"></p>
</li>
</ul>
</li>
<li><p>创建接收数据报包的工具</p>
<ul>
<li><p>使用DatagramSocket构建一个接收数据报包的工具，带参传递一个端口号</p>
<ul>
<li>端口号需要和发送端一致，才能接收到数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/CjWLb57Ofm4FT8l.png" alt="image-20210816113139335"></p>
</li>
</ul>
</li>
<li><p>接收数据</p>
<ul>
<li><p>调用DatagramSocket的<font color='#d15252'>receive</font>方法，接收数据</p>
<ul>
<li>需要传递一个DatagramPacket对象，用于存储接收的数据<ul>
<li>使用之前准备好的dp，接收数据</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/sSLiyVxUnMEzHIZ.png" alt="image-20210816113237009"></p>
</li>
</ul>
</li>
<li><p>将接收到的，存在报包中的数据，<font color='#d15252'>取出</font></p>
<ul>
<li>通过.getLength()方法获取数据报包的长度，因为默认编码不支持中文<ul>
<li>如果需要中文可以进行转换为String类型</li>
</ul>
</li>
<li>通过.getData()方法获取数据包中的数据<ul>
<li>返回值是一个byte[]数组类型，用一个数据进行存储</li>
</ul>
</li>
<li>遍历数组进行查看数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/WhSV6Hntoy8px9r.png" alt="image-20210816113548776"></p>
</li>
</ul>
<hr>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a><font color='#d15252'>TCP</font></h2><ul>
<li>严格区分客户端和服务器端<ul>
<li>面向有链接的</li>
</ul>
</li>
<li>客户端 —-&gt; 服务器端<ul>
<li>以VNC为例</li>
</ul>
</li>
</ul>
<h3 id="七、TCP服务器端ServerSocket类"><a href="#七、TCP服务器端ServerSocket类" class="headerlink" title="七、TCP服务器端ServerSocket类"></a>七、TCP服务器端ServerSocket类</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>包：java.net.ServerSocket <ul>
<li>需要导包</li>
</ul>
</li>
<li>修饰符：public 直接使用</li>
<li>属于网络流，一般服务器端不关流</li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-ServerSocket-int-port"><a href="#Ⅰ-ServerSocket-int-port" class="headerlink" title="Ⅰ. ServerSocket(int port)"></a>Ⅰ. ServerSocket(int port)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket(<span class="keyword">int</span> port) </span><br><span class="line"><span class="comment">//创建实例，绑定端口号</span></span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/16/Cc1oB8eETalW5gf.png" alt="image-20210816135448306"></p>
<h5 id="Ⅱ-其他构造"><a href="#Ⅱ-其他构造" class="headerlink" title="Ⅱ.其他构造"></a>Ⅱ.其他构造</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket​() 创建未绑定的服务器套接字。  </span><br><span class="line">ServerSocket​(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog) 创建服务器套接字并将其绑定到指定的本地端口号，并指定了积压。  </span><br><span class="line">ServerSocket​(<span class="keyword">int</span> port, <span class="keyword">int</span> backlog, InetAddress bindAddr) 创建一个具有指定端口的服务器，侦听backlog和本地IP地址绑定。  </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><h5 id="Ⅰ-accept"><a href="#Ⅰ-accept" class="headerlink" title="Ⅰ. accept()"></a>Ⅰ. accept()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Socket <span class="title">accept</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//侦听要连接到此 套接字(报包) 并接受它。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Socket：返回值类型</p>
</li>
<li><p>等待 侦听/接收  客户端数据，没有就一直等待</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/vxTwnerutZHG5Cs.png" alt="image-20210816135423394"></p>
<h5 id="Ⅱ-getInputStream"><a href="#Ⅱ-getInputStream" class="headerlink" title="Ⅱ. getInputStream()"></a>Ⅱ. getInputStream()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="comment">//返回此套接字的输入流。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以客户端为参照物，服务器端用字节输入流，保存数据</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/chfSwMalk6YEq4B.png" alt="image-20210816141948535"></p>
<h3 id="八、TCP客户端Socket"><a href="#八、TCP客户端Socket" class="headerlink" title="八、TCP客户端Socket"></a>八、TCP客户端Socket</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>包：java.net.Socket </p>
<ul>
<li>需要导包</li>
</ul>
</li>
<li><p>修饰符：public 直接使用</p>
</li>
<li><p>属于网络流，用完需要关流</p>
</li>
</ul>
<h4 id="2-构造方法-2"><a href="#2-构造方法-2" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><h5 id="Ⅰ-Socket-InetAddress-a-int-p"><a href="#Ⅰ-Socket-InetAddress-a-int-p" class="headerlink" title="Ⅰ. Socket(InetAddress a, int p)"></a>Ⅰ. Socket(InetAddress a, int p)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket(InetAddress address, <span class="keyword">int</span> port)</span><br><span class="line"><span class="comment">//创建该类实例，并指定服务器端</span></span><br></pre></td></tr></table></figure>



<h4 id="3-成员方法-1"><a href="#3-成员方法-1" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><ul>
<li>客户端向服务器端发送数据<ul>
<li>实际上依然是通过IO流进行读写</li>
</ul>
</li>
<li>又因为服务器端不能主动请求和发送数据（例如NVC）<ul>
<li>所以IO流要<font color='#d15252'>以客户端为参照物</font></li>
</ul>
</li>
</ul>
<h5 id="Ⅰ-getOutputStream"><a href="#Ⅰ-getOutputStream" class="headerlink" title="Ⅰ. getOutputStream()"></a>Ⅰ. getOutputStream()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//返回此套接字的输出流。  </span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>以客户端为参照物，用字节输出流写入数据到服务器端</li>
</ul>
<p><img src="https://i.loli.net/2021/08/16/fBIdhmq84UPrH1v.png" alt="image-20210816141930558"></p>
<h3 id="服务器端回复消息到客户端"><a href="#服务器端回复消息到客户端" class="headerlink" title="服务器端回复消息到客户端"></a>服务器端回复消息到客户端</h3><ul>
<li><p>步骤</p>
<ul>
<li><p>以服务器端为中心</p>
</li>
<li><p>向客户端用字节输出流写入数据</p>
<p><img src="https://i.loli.net/2021/08/16/cdEkNrMyFpvWSbm.png" alt="image-20210816145040488"></p>
</li>
<li><p>客户端用字节输入流接收数据</p>
<p><img src="https://i.loli.net/2021/08/16/SBcoHyIJTW6r3x7.png" alt="image-20210816145113103"></p>
</li>
<li><p>客户端遍历接收到的数据并打印到控制台</p>
</li>
</ul>
</li>
<li><p><font color='#d15252'>注意事项</font>：如果客户端要接收服务器端的返回数据</p>
<ul>
<li>必须先将客户端之前向服务器端写入的输出流关闭<ul>
<li>否则服务器端会一直处于等待数据状态，不会继续执行操作</li>
<li>也就是read处于阻塞状态</li>
</ul>
</li>
<li>通过<font color='#d15252'>关闭客户端输出流</font>，解决阻塞状态</li>
</ul>
</li>
</ul>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ul>
<li>键盘录入<ul>
<li>当录入no时，停止输入</li>
</ul>
</li>
<li>UDP：多线程的聊天室</li>
<li>TCP：图片上传服务器<ul>
<li>客户端获取图片，发送到服务器</li>
<li>服务器将图片写入另一个文件夹</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>转换流和缓冲流</title>
    <url>/2021/08/25/%E8%BD%AC%E6%8D%A2%E6%B5%81%E5%92%8C%E7%BC%93%E5%86%B2%E6%B5%81/</url>
    <content><![CDATA[<h3 id="y、InputStreamReader输入转换流"><a href="#y、InputStreamReader输入转换流" class="headerlink" title="y、InputStreamReader输入转换流"></a>y、InputStreamReader输入转换流</h3><h3 id="一、InputStreamReader输入转换流"><a href="#一、InputStreamReader输入转换流" class="headerlink" title="一、InputStreamReader输入转换流"></a>一、InputStreamReader输入转换流</h3><ul>
<li><font color='#d15252'>指定编码格式</font></li>
</ul>
<p><img src="https://i.loli.net/2021/08/10/ayLneKBhlFmp4Xi.png" alt="image-20210810100121551"></p>
<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>是从字节流到字符流的桥梁：它读取字节，并使用指定的[<code>charset</code>]将其解码为字符</li>
</ul>
<h4 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader​(InputStream in) 创建一个使用默认字符集的InputStreamReader。  </span><br><span class="line">InputStreamReader​(InputStream in, String charsetName) 创建一个使用命名字符集的InputStreamReader。  </span><br><span class="line">InputStreamReader​(InputStream in, Charset cs) 创建一个使用给定字符集的InputStreamReader。  </span><br><span class="line">InputStreamReader​(InputStream in, CharsetDecoder dec) 创建一个使用给定字符集解码器的InputStreamReader。  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>带参构造需要传递一个InputStream类型的对象</p>
<ul>
<li>InputStream是一个接口<ul>
<li>通过他的已知实现子类进行创建对象<ul>
<li>FileInputStream<ul>
<li>又需要一个File对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>步骤</strong></li>
</ul>
<p><img src="https://i.loli.net/2021/08/10/xg15ot7RzDypGba.png" alt="image-20210810143433304"></p>
</li>
</ul>
<h3 id="二、OutputStreamReader输出转换流"><a href="#二、OutputStreamReader输出转换流" class="headerlink" title="二、OutputStreamReader输出转换流"></a>二、OutputStreamReader输出转换流</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li>同InputStreamReader</li>
</ul>
<p><img src="https://i.loli.net/2021/08/10/e7PhMWVkZQigDLz.png" alt="image-20210810144431017"></p>
<h3 id="缓冲流的概述"><a href="#缓冲流的概述" class="headerlink" title="缓冲流的概述"></a>缓冲流的概述</h3><ul>
<li>效率：读写速度提高</li>
<li>功能<ul>
<li>字节</li>
<li>字符</li>
</ul>
</li>
</ul>
<h3 id="三、字节缓冲流"><a href="#三、字节缓冲流" class="headerlink" title="三、字节缓冲流"></a>三、<font color='#d15252'>字节</font>缓冲流</h3><ul>
<li> BufferedInputStream 输入缓冲流  — &gt; 读取数据到内存</li>
<li> BufferedOutputStream 输出缓冲流 —&gt; 写入数据到目标文件</li>
</ul>
<h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h4><ul>
<li><p>继承体系</p>
<p><img src="https://i.loli.net/2021/08/10/j6FOZDEUCBrnSRv.png" alt="image-20210810151303875"></p>
</li>
<li><p>InputStream –&gt; FilterInputStream —&gt;BufferedInputStream</p>
</li>
<li><p><code>BufferedInputStream</code>为另一个输入流添加了功能，即缓冲输入并支持<code>mark</code>和<code>reset</code>方法的功能</p>
<ul>
<li>  <code>mark</code>操作会记住输入流中的一个点，并且<code>reset</code>操作会导致从最近的<code>mark</code>操作读取的所有字节在从包含的输入流中取出新字节之前重新读取。 </li>
</ul>
</li>
<li><p><code>BufferedInputStream</code>将创建一个内部缓冲区数组</p>
</li>
<li></li>
</ul>
<h4 id="2-构造方法-1"><a href="#2-构造方法-1" class="headerlink" title="2.构造方法"></a>2.构造方法</h4><ul>
<li><p>```java<br>BufferedInputStream (InputStream in) 创建一个 BufferedInputStream并保存其参数，输入流 in供以后使用。<br>BufferedInputStream (InputStream in, int size) 创建具有指定缓冲区大小的 BufferedInputStream ，并保存其参数，输入流 in供以后使用。   //指定缓冲区大小</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">#### <span class="number">3.</span>成员方法</span><br><span class="line"></span><br><span class="line">- read() 、read(byte[] b,int off,int len)</span><br><span class="line"></span><br><span class="line">  ![image<span class="number">-20210810151911879</span>](https:<span class="comment">//i.loli.net/2021/08/10/QriGhqVKH3xywoJ.png)</span></span><br><span class="line"></span><br><span class="line">### &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;作业&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">![image<span class="number">-20210810154638010</span>](https:<span class="comment">//i.loli.net/2021/08/10/hznCeU2r3oB6v4d.png)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 四、&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;字符&lt;/font&gt;缓冲流 </span><br><span class="line"></span><br><span class="line">- BufferedWriter</span><br><span class="line">- BufferedReader</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.</span>概述</span><br><span class="line"></span><br><span class="line">- 修饰符：public 公共的可以直接使用</span><br><span class="line">- 继承 Writer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span>构造方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">BufferedWriter (Writer out) 创建使用默认大小的输出缓冲区的缓冲字符输出流。  </span><br><span class="line">BufferedWriter (Writer out, int sz) 创建一个新的缓冲字符输出流，使用给定大小的输出缓冲区。  <span class="comment">//自定义缓冲区大小</span></span><br></pre></td></tr></table></figure></li>
<li><p>带参构造要传递参数一个 Writer类型的变量</p>
<ul>
<li>Write是一个抽象类，需要通过子类实例化<ul>
<li>使用FileWriter实例化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-成员方法"><a href="#3-成员方法" class="headerlink" title="3.成员方法"></a>3.成员方法</h4><p><img src="https://i.loli.net/2021/08/10/1FpWNTQgoXqP6jf.png" alt="image-20210810170324088"></p>
<p><img src="https://i.loli.net/2021/08/10/u5AIkPoKXnyYVR7.png" alt="image-20210810171553360"></p>
<ul>
<li><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><ul>
<li>字符缓冲流和字符流一样，不能操作文件的复制粘贴（乱码），只能操作纯文本文件</li>
</ul>
</li>
</ul>
<h3 id="五、所有流总结"><a href="#五、所有流总结" class="headerlink" title="五、所有流总结"></a>五、所有流总结</h3><h4 id="1-继承关系"><a href="#1-继承关系" class="headerlink" title="1.继承关系"></a>1.继承关系</h4><ul>
<li><p>字节流</p>
<p><img src="https://i.loli.net/2021/08/10/CTaUoeyz9tsu4R6.png"></p>
</li>
<li><p>字符流</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/08/10/gsDie8LW45RrXbI.png" alt="image-20210810194449230"></p>
<p><img src="https://i.loli.net/2021/08/25/Qq8EsATcXZpzO1h.png" alt="image-20210810184044702"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>转换流</tag>
        <tag>缓冲流</tag>
      </tags>
  </entry>
  <entry>
    <title>集合</title>
    <url>/2021/08/25/%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a><font color='#d15252'>集合</font></h2><h3 id="一、集合和数组的区别"><a href="#一、集合和数组的区别" class="headerlink" title="一、集合和数组的区别"></a>一、集合和数组的区别</h3><ul>
<li>相同点<ul>
<li>都是用来存储数据的</li>
</ul>
</li>
<li>不同点<ul>
<li>数组的长度是固定的，集合的长度是可变的</li>
<li>数组可以存基本数据类型，也可以存引用数据类型</li>
<li>集合只能存引用数据类型 int —&gt; interger</li>
</ul>
</li>
</ul>
<h3 id="二、集合的体系"><a href="#二、集合的体系" class="headerlink" title="二、集合的体系"></a>二、集合的体系</h3><p><font color='orange'>这个颜色是接口</font></p>
<p><font color='cornflowerblue'>这个颜色是具体实现类</font></p>
<h4 id="1-单列集合-Collection"><a href="#1-单列集合-Collection" class="headerlink" title="1.单列集合    Collection"></a>1.单列集合    <font color='orange'>Collection</font></h4><ul>
<li><h5 id="重复的数据-List"><a href="#重复的数据-List" class="headerlink" title="重复的数据    List"></a>重复的数据    <font color='orange'>List</font></h5><ul>
<li><font color='cornflowerblue'>ArrayList </font><ul>
<li>数组结构，有序的</li>
</ul>
</li>
<li><font color='cornflowerblue'>LinkedList </font><ul>
<li>链表结构，无序的</li>
</ul>
</li>
</ul>
</li>
<li><h5 id="不重复的数据-Set"><a href="#不重复的数据-Set" class="headerlink" title="不重复的数据  Set"></a>不重复的数据  <font color='orange'>Set</font></h5><ul>
<li><font color='cornflowerblue'>HashSet </font></li>
<li><font color='cornflowerblue'>TreeSet </font></li>
</ul>
</li>
</ul>
<h4 id="2-双列集合-Map"><a href="#2-双列集合-Map" class="headerlink" title="2.双列集合    Map"></a>2.双列集合    <font color='orange'>Map</font></h4><ul>
<li><font color='cornflowerblue'>HashMap</font> </li>
<li><font color='cornflowerblue'>Three</font> </li>
</ul>
<h3 id="三、单列集合-Collection"><a href="#三、单列集合-Collection" class="headerlink" title="三、单列集合 Collection"></a>三、单列集合 Collection</h3><h4 id="1-Collection的概念"><a href="#1-Collection的概念" class="headerlink" title="1.Collection的概念"></a>1.Collection的概念</h4><ul>
<li><p>Collection是一个接口，不能直接实例化，需要通过子类实例化</p>
<p><img src="https://i.loli.net/2021/08/03/8dg74JoPVunbxER.png" alt="image-20210803153550255"></p>
<ul>
<li>常见的：ArrayList&lt;&gt;</li>
</ul>
</li>
</ul>
<h4 id="2-Collection的成员方法"><a href="#2-Collection的成员方法" class="headerlink" title="2.Collection的成员方法"></a>2.Collection的成员方法</h4><h5 id="①-add-方法"><a href="#①-add-方法" class="headerlink" title="① add()方法"></a>① add()方法</h5><ul>
<li><p>add(数据) 添加一个数据到集合</p>
</li>
<li><p>addAll(集合)，将指定集合中的所有元素添加到此集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      Collection&lt;Integer&gt; con = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      Collection&lt;Integer&gt; con2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      <span class="comment">//使用add方法添加到集合</span></span><br><span class="line">      con.add(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//使用addAll方法，将一个集合添加到另一个集合</span></span><br><span class="line">      con.addAll(con2);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="②-clear-方法"><a href="#②-clear-方法" class="headerlink" title="② clear()方法"></a>② clear()方法</h5><ul>
<li><p>从此集合中删除所有元素（可选操作）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除集合中所有元素</span></span><br><span class="line">con.clear();</span><br></pre></td></tr></table></figure>



<h5 id="③-size"><a href="#③-size" class="headerlink" title="③ size()"></a>③ size()</h5><h5 id="④-remove"><a href="#④-remove" class="headerlink" title="④ remove()"></a>④ remove()</h5></li>
</ul>
<h4 id="3-集合的遍历"><a href="#3-集合的遍历" class="headerlink" title="3.集合的遍历"></a>3.集合的遍历</h4><p>因为collection类中没有定义get方法，所以不能通过get取数据</p>
<ul>
<li><h5 id="遍历集合的第一种方法，用增强for"><a href="#遍历集合的第一种方法，用增强for" class="headerlink" title="遍历集合的第一种方法，用增强for"></a>遍历集合的第一种方法，用增强for</h5><ul>
<li><p>```java</p>
<pre><code>for (int i : arr)&#123;
    System.out.println(i);
&#125;
</code></pre>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ##### &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;集合专属的遍历方式&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">  - **iterator()**  返回此集合中元素的迭代器。</span><br><span class="line"></span><br><span class="line">    - 返回值是iterator类型</span><br><span class="line">    - 迭代：顺序</span><br><span class="line"></span><br><span class="line">  - Interface Iterator是一个接口，不能直接使用，但我们可以通过创建对象，调用</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">            <span class="comment">//遍历集合的第二种方法，用iterator接口</span></span><br><span class="line">            Iterator&lt;Integer&gt; iterator = arr.iterator();</span><br></pre></td></tr></table></figure>

<ul>
<li>iterator中<ul>
<li>有一个next()方法，按顺序返回下一个元素</li>
<li>hasNetx()方法<ul>
<li>如果还有元素，返回true</li>
<li>如果没有元素，返回false</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用iterator遍历数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//hasNext()方法判断是否还有数据</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next()方法按顺序返回值</span></span><br><span class="line">   System.out.println(iterator.next());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="四、单列集合中的-List"><a href="#四、单列集合中的-List" class="headerlink" title="四、单列集合中的 List"></a>四、单列集合中的 List</h3><h4 id="1-List的概述"><a href="#1-List的概述" class="headerlink" title="1.List的概述"></a>1.List的概述</h4><ul>
<li>接口</li>
<li>有序的（怎么放的，怎么拿）</li>
</ul>
<h4 id="2-List的成员方法"><a href="#2-List的成员方法" class="headerlink" title="2.List的成员方法"></a>2.List的成员方法</h4><ul>
<li>拥有get()方法，可以对索引进行操作</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//list可以使用get方法,通过索引取值</span></span><br><span class="line">System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"><span class="comment">//使用get方法遍历集合</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>List集合也可以使用迭代器</li>
<li>add（）、clear（）、equals（）、remove()、等方法</li>
</ul>
<h4 id="3-List的特点"><a href="#3-List的特点" class="headerlink" title="3.List的特点"></a>3.List的特点</h4><ul>
<li>存取有序</li>
<li>可以重复</li>
<li>有索引</li>
</ul>
<h4 id="4-List特有-常用-的方法"><a href="#4-List特有-常用-的方法" class="headerlink" title="4.List特有(常用)的方法"></a>4.List特有(常用)的方法</h4><ul>
<li><p>```java</p>
<ul>
<li>void add (int index,E element) 添加</li>
<li>remove(int index)            根据索引删除</li>
<li>set(int index,E Element)    修改</li>
<li>get(int index)        获取所在索引值<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 五、数据结构特点（记住）</span><br><span class="line"></span><br><span class="line">- 栈和队列</span><br><span class="line">  - 栈结构</span><br><span class="line">    - 先进后出</span><br><span class="line">  - 队列结构</span><br><span class="line">    - 先进先出</span><br><span class="line">- 数组和链表</span><br><span class="line">  - 数组结构</span><br><span class="line">    - 查询快，增删慢</span><br><span class="line">  - 链表结构</span><br><span class="line">    - 查询满，增删快</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 六、ArrayList和LinkedList </span><br><span class="line"></span><br><span class="line">#### <span class="number">1.</span>ArrayList</span><br><span class="line"></span><br><span class="line">- ​	底层结构是**&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;数组结构&lt;/font&gt;**，查询快，增删慢</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>LinkedList</span><br><span class="line"></span><br><span class="line">- 底层结构是&lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;**链表结构**&lt;/font&gt;，查询慢，增删快</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 一、Set集合</span><br><span class="line"></span><br><span class="line">#### <span class="number">1.</span>Set集合的概述</span><br><span class="line"></span><br><span class="line">- 是一个接口，有很多已知实现类</span><br><span class="line">  - 常用子类 HashSet、LinkedHashSet、TreeSet</span><br><span class="line">- 是一个单列集合</span><br><span class="line">- &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;不能存重复的元素&lt;/font&gt;</span><br><span class="line">- &lt;font color=<span class="string">&#x27;#d15252&#x27;</span>&gt;Set集合是无序的，不保证一定无序&lt;/font&gt;</span><br><span class="line">  - 实际上是按照Hash值排列的	</span><br><span class="line">    - 所以最好不要存整数</span><br><span class="line"></span><br><span class="line">#### <span class="number">2.</span>Set集合的使用</span><br><span class="line"></span><br><span class="line">- 用多态的方式实例化接口</span><br><span class="line"></span><br><span class="line">- Set集合有已知子类直接使用</span><br><span class="line"></span><br><span class="line">  ```java</span><br><span class="line">    <span class="comment">//Set集合是一个接口，需要通过多态的方式实例化，重写父类中的方法</span></span><br><span class="line">          <span class="comment">//Set集合不能存重复的数据</span></span><br><span class="line">          Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();</span><br><span class="line">          <span class="comment">//向set集合中添加数据</span></span><br><span class="line">          set.add(<span class="number">1</span>);</span><br><span class="line">          set.add(<span class="number">2</span>);</span><br><span class="line">          set.add(<span class="number">1</span>);</span><br><span class="line">          <span class="comment">//输出集合</span></span><br><span class="line">          System.out.println(set);</span><br><span class="line">          <span class="comment">//可以看到输出了[1,2]</span></span><br><span class="line">          <span class="comment">//1并没有重复保存</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Set集合是无序的</p>
</li>
</ul>
<h3 id="二、HashSet"><a href="#二、HashSet" class="headerlink" title="二、HashSet"></a>二、HashSet</h3><ul>
<li>允许存null值</li>
<li>对迭代顺序不做任何保证 </li>
<li>容量和size是两个概念<ul>
<li>容量：容器的长度</li>
<li>size：内容的长度</li>
</ul>
</li>
<li>开发中ArrayList集合使用的较多</li>
<li>HashSet没有索引</li>
<li>HashSet底层数据结构是：<font color='#d15252'><strong>哈希表+链表结构</strong></font></li>
</ul>
<h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-无参构造"><a href="#Ⅰ-无参构造" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li>实例具有默认初始容量（16）和负载因子（0.75）。</li>
</ul>
<h5 id="Ⅱ-带参构造"><a href="#Ⅱ-带参构造" class="headerlink" title="Ⅱ.带参构造"></a>Ⅱ.带参构造</h5><ul>
<li><p>参数传递一个Int类型的数据，是集合<font color='#d15252'>指定初始容量</font></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅲ-带参构造"><a href="#Ⅲ-带参构造" class="headerlink" title="Ⅲ.带参构造"></a>Ⅲ.带参构造</h5><ul>
<li><p>参数传递一个Collection集合，重复的值不会录入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-成员方法"><a href="#2-成员方法" class="headerlink" title="2.成员方法"></a>2.成员方法</h4><ul>
<li>方法都有返回值，可以通过接收add、remove等方法的返回值（布尔类型），来判断是否操作成功</li>
</ul>
<h5 id="Ⅰ-add-方法"><a href="#Ⅰ-add-方法" class="headerlink" title="Ⅰ.add()方法"></a>Ⅰ.add()方法</h5><ul>
<li><p>将指定的元素添加到此集合（如果尚未存在）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Object&gt; s = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line">s.add(<span class="number">1</span>);</span><br><span class="line">s.add(<span class="number">2</span>);</span><br><span class="line">s.add(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-remove"><a href="#Ⅱ-remove" class="headerlink" title="Ⅱ.remove()"></a>Ⅱ.remove()</h5><ul>
<li><p>如果存在，则从该集合中删除指定的元素 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line">s.remove(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>HashSet<font color='#d15252'>没有索引</font></li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-clear"><a href="#Ⅲ-clear" class="headerlink" title="Ⅲ.clear()"></a>Ⅲ.clear()</h5><ul>
<li>删除集合中的所有元素</li>
</ul>
<h5 id="Ⅳ-size"><a href="#Ⅳ-size" class="headerlink" title="Ⅳ.size()"></a>Ⅳ.size()</h5><ul>
<li>返回集合中的元素数</li>
</ul>
<h5 id="Ⅴ-iterator"><a href="#Ⅴ-iterator" class="headerlink" title="Ⅴ.iterator()"></a>Ⅴ.iterator()</h5><ul>
<li>返回集合中元素的迭代器</li>
</ul>
<h3 id="三、TreeSet"><a href="#三、TreeSet" class="headerlink" title="三、TreeSet"></a>三、TreeSet</h3><ul>
<li>Set是无序的</li>
<li>TreeSet可以自定义排序顺序</li>
</ul>
<h4 id="1-构造方法-1"><a href="#1-构造方法-1" class="headerlink" title="1.构造方法"></a>1.构造方法</h4><h5 id="Ⅰ-无参构造-1"><a href="#Ⅰ-无参构造-1" class="headerlink" title="Ⅰ.无参构造"></a>Ⅰ.无参构造</h5><ul>
<li><p>构造一个新的，空的树组，根据其元素的自然排序进行排序</p>
<ul>
<li>自然排序：自动默认排序，根据哈希码或ASCII码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; t = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Ⅱ-有参构造-集合"><a href="#Ⅱ-有参构造-集合" class="headerlink" title="Ⅱ.有参构造(集合)"></a>Ⅱ.有参构造(集合)</h5><ul>
<li><p>构造一个包含指定集合中的元素的新树集，根据其元素的 <em>自然排序进行排序</em> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeSet​(Collection&lt;? extends E&gt; c)</span><br></pre></td></tr></table></figure>

<ul>
<li>带参一个集合</li>
</ul>
</li>
</ul>
<h5 id="Ⅲ-带参构造-Comparator自定义顺序"><a href="#Ⅲ-带参构造-Comparator自定义顺序" class="headerlink" title="Ⅲ.带参构造(Comparator自定义顺序)"></a>Ⅲ.<font color='#d15252'>带参构造(Comparator自定义顺序)</font></h5><ul>
<li>构造一个新的，空的树集，根据指定的比较器进行排序。</li>
<li>先欠着，以后晚自习将</li>
</ul>
<h3 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h3><h4 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a>1.什么是泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; t = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>&lt;&gt;中的东西</p>
</li>
<li><p>泛型实际的含义就是任意类型（Object）</p>
<ul>
<li>jdk5以后引入的新特性，为了提高编译时的类型安全检测机制</li>
</ul>
</li>
<li><p>Java中出现 E V K ：指的就是任意类型</p>
</li>
</ul>
<h4 id="2-泛型的优点"><a href="#2-泛型的优点" class="headerlink" title="2.泛型的优点"></a>2.泛型的优点</h4><ul>
<li><p>可以将运行时的异常提前到编译时</p>
</li>
<li><p>避免了数据类型的强制转换</p>
</li>
<li><p>Java中如果没有明确标明集合类型，则集合中的数据不管是什么类型，都会<font color='#d15252'>向上转型为Object</font>类型</p>
</li>
</ul>
<h4 id="3-定义泛型类"><a href="#3-定义泛型类" class="headerlink" title="3.定义泛型类"></a>3.定义泛型类</h4><ul>
<li><p>定义格式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&lt;类型&gt;</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符&lt;类型&gt; 返回值类型 方法名（数据类型 变量名）&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 <span class="class"><span class="keyword">interface</span> 接口名&lt;类型&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>定义泛型类、泛型方法的意义：告诉使用者，我这个方法可以传任意的数据</p>
</li>
</ul>
<h3 id="五、类型的通配符"><a href="#五、类型的通配符" class="headerlink" title="五、类型的通配符"></a>五、类型的通配符</h3><h4 id="1-lt-gt"><a href="#1-lt-gt" class="headerlink" title="1.&lt;?&gt;"></a>1.&lt;?&gt;</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;?&gt;：可以匹配任意的类型</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/08/04/ymbeGhsTRi8gEXI.png" alt="image-20210804114626328"></p>
<ul>
<li>通常用于方法定义参数，不知道传递什么类型时，使用&lt;?&gt;</li>
</ul>
<h4 id="2-类型的通配符上限-lt-extends-类型-gt"><a href="#2-类型的通配符上限-lt-extends-类型-gt" class="headerlink" title="2.类型的通配符上限&lt;? extends 类型&gt;"></a>2.类型的通配符上限&lt;? extends 类型&gt;</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;? extends 类型&gt; 表示类型的通配符上限</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如 &lt;? extends number&gt;</span></span><br><span class="line"><span class="comment">//表示Number本身或它的子类</span></span><br></pre></td></tr></table></figure>



<h4 id="3-类型通配符的下限-lt-super-类型-gt"><a href="#3-类型通配符的下限-lt-super-类型-gt" class="headerlink" title="3.类型通配符的下限&lt;? super 类型&gt;"></a>3.类型通配符的下限&lt;? super 类型&gt;</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;? <span class="keyword">super</span> 类型&gt; 表示类型通配符的下限</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如 &lt;? super number&gt;</span></span><br><span class="line"><span class="comment">//表示Number本身或它的父类</span></span><br></pre></td></tr></table></figure>



<h3 id="六、Map-双列集合"><a href="#六、Map-双列集合" class="headerlink" title="六、Map(双列集合)"></a>六、<font color='#d15252'>Map(双列集合)</font></h3><ul>
<li>是一个泛型接口</li>
<li>该容器，能够存储两列<ul>
<li>1</li>
<li>键值对关系，通过键去取值</li>
</ul>
</li>
<li>将键映射到值的对象。 双列集合<font color='#d15252'>不能包含重复的键</font>，每个键可以映射到最多一个值。 <ul>
<li>键：Key</li>
<li>值：value</li>
</ul>
</li>
</ul>
<h4 id="1-存数"><a href="#1-存数" class="headerlink" title="1.存数"></a>1.存数</h4><ul>
<li><p>使用.put()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">put(键、值);</span><br></pre></td></tr></table></figure>

<ul>
<li>将指定的值与该映射中的指定键相关联（可选操作）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">//Map双列集合</span></span><br><span class="line">        Map&lt;Integer,String&gt; s = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//输出集合</span></span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="comment">//向双列数组中存数</span></span><br><span class="line">        s.put(<span class="number">1</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.put(<span class="number">2</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s.put(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line"><span class="comment">//输出&#123;&#125;  &#123;1=b,2=a&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>key键值<font color='#d15252'>不能重复</font></li>
<li>value可以重复</li>
</ul>
</li>
<li><p>如果存入相同的键，则随机抛出一个</p>
</li>
<li><p>put()方法返回值是返回 之前覆盖掉的数据</p>
</li>
</ul>
<h4 id="2-取值"><a href="#2-取值" class="headerlink" title="2.取值"></a>2.取值</h4><h5 id="Ⅰ-可以使用get-方法取值"><a href="#Ⅰ-可以使用get-方法取值" class="headerlink" title="Ⅰ.可以使用get()方法取值"></a>Ⅰ.可以使用get()方法取值</h5><ul>
<li><p>但是键值不是固定的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用get方法取值</span></span><br><span class="line">System.out.println(map.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>不能通过for循环遍历集合中的键值对</p>
</li>
</ul>
<h5 id="Ⅱ-entrySet"><a href="#Ⅱ-entrySet" class="headerlink" title="Ⅱ.entrySet"></a>Ⅱ.entrySet</h5><ul>
<li>是Map的内部类<ul>
<li>为了保存K和V<ul>
<li>但键和值并不是个别的，有很多个</li>
</ul>
</li>
<li>所以将得到的值<font color='#d15252'>封装到一个Set集合</font>中</li>
</ul>
</li>
<li>返回值为Map.Entry类型（内部类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br></pre></td></tr></table></figure>

<ul>
<li>返回A双列集合中包含的映射的键值对。该集合由A双列集合支持，因此对双列集合的更改将反映在集合A中，反之亦然。 </li>
<li>即定义一个Set集合，保存entrySet()方法返回的数据</li>
</ul>
<h6 id="for循环-Map-Entry取值"><a href="#for循环-Map-Entry取值" class="headerlink" title="for循环+Map.Entry取值"></a>for循环+Map.Entry取值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增强for循环取出值   数据类型 变量名 ： 要取的数据</span></span><br><span class="line"><span class="keyword">for</span> ( Map.Entry&lt;Integer,String&gt; i : set )&#123;</span><br><span class="line">    System.out.println(i.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Iterator迭代器-Map-Entry取值"><a href="#Iterator迭代器-Map-Entry取值" class="headerlink" title="Iterator迭代器+Map.Entry取值"></a>Iterator迭代器+Map.Entry取值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用entrySet()方法，取出双列集合中的键值对</span></span><br><span class="line"><span class="comment">//并用一个Set集合保存，此时 Set集合中存的键值对就是Map.Entry类型的</span></span><br><span class="line">Set&lt;Map.Entry&lt;Integer,String&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="comment">//set调用迭代器，按顺序取出Set集合中的键值对</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//用取出的键值对，调用Map.Entry的get方法，获取数据</span></span><br><span class="line">    System.out.println(it.next().getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Ⅳ-keySet-方法取值"><a href="#Ⅳ-keySet-方法取值" class="headerlink" title="Ⅳ.keySet()方法取值"></a>Ⅳ.keySet()方法取值</h5><ul>
<li><p>返回此双列集合中包含的键的[<code>Set</code>]视图。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Set&lt;K&gt; <span class="title">keySet</span> <span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>取出map集合中的键，并存入Set集合</li>
</ul>
</li>
</ul>
<h6 id="for循环-keySet-取值"><a href="#for循环-keySet-取值" class="headerlink" title="for循环+keySet()取值"></a>for循环+keySet()取值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用KeySet方法取出Map集合中的键值</span></span><br><span class="line"><span class="comment">//因为键值是Integer类型的，所以泛型设置Integer</span></span><br><span class="line">Set&lt;Integer&gt; it = map.keySet();</span><br><span class="line"><span class="comment">//用增强for循环取出Set中的键值，通过键值调用get方法</span></span><br><span class="line"><span class="keyword">for</span> ( Integer i : it ) &#123;</span><br><span class="line">    <span class="comment">//用map调用get方法取值，放入keySet取出的键值</span></span><br><span class="line">    System.out.println(map.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="Iterator迭代器-keySet-取值"><a href="#Iterator迭代器-keySet-取值" class="headerlink" title="Iterator迭代器+keySet()取值"></a>Iterator迭代器+keySet()取值</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代器取值</span></span><br><span class="line">Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    System.out.println(map.get(it.next()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-作业"><a href="#3-作业" class="headerlink" title="3.作业"></a>3.作业</h4><ul>
<li>第一题<ul>
<li>ll创建一个Map集合java，存入Java一班的学生数据</li>
<li>创建一个Map集合c，存入c语言班的学生数据</li>
<li>创建一个Map集合，存入Java、c</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Date</tag>
        <tag>DateFormat</tag>
        <tag>Calender</tag>
        <tag>迭代器</tag>
        <tag>集合</tag>
        <tag>单列集合</tag>
        <tag>双列集合</tag>
      </tags>
  </entry>
</search>
